{
    "decompcode": [
        "\nvoid func_ad0628cbbb674d4d(void)\n\n{\n  func_6969d79e84024797();\n  func_72dbcef465d1434e();\n  return;\n}\n\n",
        "\nvoid func_0cb6531d26a2466e(undefined4 param_1)\n\n{\n  func_c5cff8781c114bea(param_1);\n  return;\n}\n\n",
        "\nvoid func_330d4775aff44ade(undefined8 param_1)\n\n{\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_50aa760cbc864a1a(&uStack_78,99,param_1);\n  func_eef7a2685a7f43b3(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_c132e8084d664d27(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uStack_278;\n  undefined8 uStack_270;\n  undefined8 uStack_268;\n  undefined8 uStack_260;\n  undefined8 uStack_258;\n  undefined8 uStack_250;\n  undefined8 uStack_248;\n  undefined8 uStack_240;\n  undefined8 uStack_238;\n  undefined8 uStack_230;\n  undefined8 uStack_228;\n  undefined8 uStack_220;\n  undefined8 uStack_218;\n  undefined8 uStack_210;\n  undefined8 uStack_208;\n  undefined8 uStack_200;\n  undefined8 uStack_1f8;\n  undefined8 uStack_1f0;\n  undefined8 uStack_1e8;\n  undefined8 uStack_1e0;\n  undefined8 uStack_1d8;\n  undefined8 uStack_1d0;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  ulong uStack_1b8;\n  undefined auStack_1a8 [408];\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_1a8;\n  iVar1 = func_81106e2014334eb0();\n  if (iVar1 == 0) {\n    func_7779adaa3065497e(puStack_10,0x41,0x31);\n    *(undefined4 *)(puStack_10 + 0xc4) = 0;\n  }\n  else {\n    func_7779adaa3065497e(puStack_10,0x41,99);\n    *(undefined4 *)(puStack_10 + 0x18c) = 0;\n  }\n  uStack_278 = 0;\n  uStack_270 = 0;\n  uStack_268 = 0;\n  uStack_260 = 0;\n  uStack_258 = 0;\n  uStack_250 = 0;\n  uStack_248 = 0;\n  uStack_240 = 0;\n  uStack_238 = 0;\n  uStack_230 = 0;\n  uStack_228 = 0;\n  uStack_220 = 0;\n  uStack_218 = 0;\n  uStack_210 = 0;\n  uStack_208 = 0;\n  uStack_200 = 0;\n  uStack_1f8 = 0;\n  uStack_1f0 = 0;\n  uStack_1e8 = 0;\n  uStack_1e0 = 0;\n  uStack_1d8 = 0;\n  uStack_1d0 = 0;\n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  uStack_1b8 = 0;\n  lVar2 = func_d2e6eaa0dc5b459f(puStack_10);\n  func_5f821cfed6b34c0a(&uStack_278,puStack_10,lVar2 * 4);\n  uStack_1b8 = uStack_1b8 & 0xffffffff;\n  func_0fb8db24c02143c0(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_05a17cee601846af(int param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  ulong uStack_10;\n  \n  lVar1 = func_f73ba00372a34efa(&UNK_00401398,&UNK_004013a7);\n  if (lVar1 == 0) {\n    func_d10b1be17fc24792(1);\n  }\n  for (uStack_10 = 0; uStack_10 < (ulong)(long)param_1; uStack_10 = uStack_10 + 1) {\n    lVar2 = func_f6afe0b1ee4347ec(&UNK_004013b0,1,0x32,lVar1);\n    if (lVar2 != 0x32) {\n      func_d10b1be17fc24792(1);\n    }\n  }\n  if (lVar1 != 0) {\n    func_c1bbebd991e34b9d(lVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_6f4973979c0a40ea(void)\n\n{\n  long lVar1;\n  undefined8 uStack_1b;\n  undefined2 uStack_13;\n  undefined uStack_11;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  uStack_10 = func_34ba0f8f6aa04039(0);\n  uStack_1b = 0x4141414141414141;\n  uStack_13 = 0x4141;\n  uStack_11 = 0;\n  lVar1 = func_20e4d2323b0b444a(&uStack_1b);\n  func_e621c6a35c1d48c4(uStack_10,&uStack_1b,lVar1 + 1);\n  func_9d13881ce4c64257(uStack_10);\n  func_e0022638b33c4fe5(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_ab08532682fb44aa(void)\n\n{\n  func_3ed7a180c0014aec();\n  return;\n}\n\n",
        "\nvoid func_16d74b0f543f4bc9(undefined8 param_1)\n\n{\n  func_347862c3cc6744ca(param_1);\n  return;\n}\n\n",
        "\nvoid func_aa25d4c0c2e34320(void)\n\n{\n  int iVar1;\n  ulong uStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)0x0;\n  iVar1 = func_0c4724b3a2a34f65();\n  if (iVar1 != 0) {\n    puStack_10 = (undefined4 *)func_f740985763ce4318(400);\n    for (uStack_18 = 0; uStack_18 < 100; uStack_18 = uStack_18 + 1) {\n      puStack_10[uStack_18] = 5;\n    }\n    func_b7097e3594f044bf(puStack_10);\n  }\n  iVar1 = func_0c4724b3a2a34f65();\n  if (iVar1 != 0) {\n    func_54a5134441284029(*puStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_35f1f779d6c94d09(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = func_952631f27aff4200(400);\n  func_5c20850315ee41f9(uVar1);\n  return;\n}\n\n",
        "\nvoid func_65f78d37b8314167(void)\n\n{\n  short sStack_1a;\n  long lStack_18;\n  int iStack_c;\n  \n  sStack_1a = 0;\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    func_79b63eb1a39144ee(stdin,&UNK_00401304,&sStack_1a);\n  }\n  if (sStack_1a < 100) {\n    lStack_18 = func_dd514fd07f8d4b9f((long)sStack_1a);\n    func_16410559aa8c457f(lStack_18,0x41,(long)(sStack_1a + -1));\n    *(undefined *)(lStack_18 + (long)sStack_1a + -1) = 0;\n    func_ad4db837928c4a42(lStack_18);\n    func_8b0d17fc5241491d(lStack_18);\n  }\n  return;\n}\n\n",
        "\nvoid func_da5705c24b6848c7(long param_1)\n\n{\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  \n  func_79253b3eb3424b61(auStack_78,0x43,99);\n  uStack_15 = 0;\n  func_7672023d1b0c4e89(param_1,auStack_78,99);\n  *(undefined *)(param_1 + 99) = 0;\n  func_fd48468f55444be2(param_1);\n  return;\n}\n\n",
        "\nvoid func_3be7a5426edb4a03(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined auStack_420 [416];\n  undefined4 auStack_280 [50];\n  undefined auStack_1b8 [396];\n  undefined4 uStack_2c;\n  undefined *puStack_20;\n  undefined4 *puStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_18 = auStack_280;\n  puStack_20 = auStack_420;\n  iVar1 = func_df7d969d01e04f00(param_1,0x10,7);\n  if (iVar1 != 0) {\n    puStack_10 = puStack_18;\n    *puStack_18 = 0;\n  }\n  func_3687548873e34c14(auStack_1b8,0x43,99);\n  uStack_2c = 0;\n  func_656147db9a554938(puStack_10,auStack_1b8,400);\n  puStack_10[99] = 0;\n  func_13f006a46a6141b3(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_0e094750175143f6(void)\n\n{\n  undefined auStack_510 [816];\n  undefined auStack_1e0 [408];\n  undefined auStack_48 [16];\n  undefined *puStack_38;\n  undefined *puStack_20;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_38 = auStack_1e0;\n  puStack_18 = auStack_510;\n  puStack_20 = puStack_38;\n  puStack_10 = puStack_38;\n  func_14b89f3c4913472a(auStack_48,0x10,7);\n  return;\n}\n\n",
        "\nvoid func_f4cf564a04cc4e4a(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined4 uStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_18 = 0xffffffff;\n  iStack_10 = 0xffffffff;\n  iStack_c = -1;\n  iStack_10 = func_e8897673a2f84ddd(2,1,6);\n  if (iStack_10 != -1) {\n    func_600dea644610425d(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_890d4efbb5134906(0x6987);\n    iVar1 = func_cbfc6ae129684221(iStack_10,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_e3ec832daf1a413d(iStack_10,5), iVar1 != -1)) &&\n        (iStack_c = func_936854f77bf2484f(iStack_10,0,0), iStack_c != -1)) &&\n       ((iStack_14 = func_ed42b79994ae473b(iStack_c,auStack_36,0xd,0), iStack_14 != -1 && (iStack_14 != 0)\n        ))) {\n      auStack_36[iStack_14] = 0;\n      uStack_18 = func_9e9f66f8920343d8(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_24514ace7f764417(iStack_10);\n  }\n  if (iStack_c != -1) {\n    func_24514ace7f764417(iStack_c);\n  }\n  func_89b4dabe934343d2(&uStack_18);\n  return;\n}\n\n",
        "\nvoid func_c33a941b2f2b4457(undefined8 param_1)\n\n{\n  int iVar1;\n  int iStack_1c;\n  undefined8 uStack_18;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_18 = param_1;\n  iVar1 = func_a5d47dc9141d4f1e(param_1,&UNK_00401484,&iStack_1c);\n  if (iVar1 == 1) {\n    iStack_10 = 0;\n    for (iStack_c = 0; iStack_c < iStack_1c; iStack_c = iStack_c + 1) {\n      iStack_10 = iStack_10 + 1;\n    }\n    func_45ab64341e4f4245(iStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_9364354ec8c54d97(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_e7e41c6f2f3c4948(2,1,6);\n  if (iStack_14 != -1) {\n    func_53d6bc86574c4b46(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_04b4cbcf0bd344db(0x6987);\n    iVar1 = func_b632cdad7a8c4265(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_dcb34a8716cc471c(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_d09ba8bcb4bd47bf(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_e7455d0b760946e4(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      uStack_c = func_061384c2db3c4f6a(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_bce4c599227f4a26(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_bce4c599227f4a26(iStack_10);\n  }\n  func_9bb031f4ff8f42b6(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_c2c2ca6b66424b8f(void)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  \n  iVar1 = func_686e3a11217b4ad0();\n  iVar2 = func_686e3a11217b4ad0();\n  uVar3 = func_686e3a11217b4ad0();\n  func_9da0d037ad1e4600\n            (uVar3 ^ iVar1 << 0x1e ^ iVar2 << 0xf);\n  return;\n}\n\n",
        "\nvoid func_fb61267724fb4106(undefined8 param_1)\n\n{\n  func_311e1bdeed0840be(&UNK_0040120b,&UNK_0040120b,&UNK_00401208,&UNK_00401204,param_1,0);\n  return;\n}\n\n",
        "\nvoid func_22352ff3b25e499a(short param_1)\n\n{\n  func_bd45eb1e7f194d49((int)param_1);\n  return;\n}\n\n",
        "\nvoid func_2f33a0d3e3654def(void)\n\n{\n  long lVar1;\n  undefined8 uStack_f8;\n  undefined8 uStack_f0;\n  undefined8 uStack_e8;\n  undefined8 uStack_e0;\n  undefined8 uStack_d8;\n  undefined8 uStack_d0;\n  undefined8 uStack_c8;\n  undefined8 uStack_c0;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined4 uStack_98;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_566023789d7b4d96(puStack_10);\n  if ((1 < 100U - lStack_18) &&\n     (lStack_20 = func_189729a180864b6c(&UNK_0040145a,&UNK_00401458), lStack_20 != 0)) {\n    lVar1 = func_adaab2062a494187((long)puStack_10 + lStack_18,100 - (int)lStack_18,lStack_20);\n    if (lVar1 == 0) {\n      func_c7e7c7fe597741fd(&UNK_00401468);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    func_2f4311ffcca64e94(lStack_20);\n  }\n  uStack_f8 = 0;\n  uStack_f0 = 0;\n  uStack_e8 = 0;\n  uStack_e0 = 0;\n  uStack_d8 = 0;\n  uStack_d0 = 0;\n  uStack_c8 = 0;\n  uStack_c0 = 0;\n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  func_cb9c2aac4cd34143(&uStack_f8,99,puStack_10);\n  func_c7e7c7fe597741fd(&uStack_f8);\n  return;\n}\n\n",
        "\nvoid func_72e8bf8bf4b84466(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_7102d1219cdc4954(100);\n  *pcStack_10 = '\\0';\n  lVar2 = func_95d2004caf2c4199(pcStack_10);\n  if ((1 < 100U - lVar2) && (lVar3 = func_d073a21514424cd9(&UNK_004013a6,&UNK_004013a4), lVar3 != 0)) {\n    lVar4 = func_fbe5070e9f8f47e8(pcStack_10 + lVar2,100 - (int)lVar2,lVar3);\n    if (lVar4 == 0) {\n      func_e9ab19ce85ef4766(&UNK_004013b4);\n      pcStack_10[lVar2] = '\\0';\n    }\n    func_2cf6c6f93db548ab(lVar3);\n  }\n  iVar1 = func_f5fef157b3cf413d();\n  if (iVar1 != 0) {\n    for (; *pcStack_10 != '\\0'; pcStack_10 = pcStack_10 + 1) {\n      if (*pcStack_10 == 'S') {\n        func_e9ab19ce85ef4766(&UNK_004013c3);\n        break;\n      }\n    }\n    func_45595fc46da84a51(pcStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_c7ebd06800ee4a43(void)\n\n{\n  undefined auStack_420 [416];\n  undefined4 auStack_280 [50];\n  undefined auStack_1b8 [396];\n  undefined4 uStack_2c;\n  undefined4 *puStack_20;\n  undefined *puStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_20 = auStack_280;\n  puStack_18 = auStack_420;\n  auStack_280[0] = 0;\n  puStack_10 = puStack_20;\n  func_7bc31b276e8f43b1(auStack_1b8,0x43,99);\n  uStack_2c = 0;\n  func_c035046e9a624a06(puStack_20,auStack_1b8);\n  func_c36ddd5975d44b16(puStack_20);\n  return;\n}\n\n",
        "\nvoid func_36433d9b8f094115(void)\n\n{\n  undefined **ppuVar1;\n  undefined auStack_88 [8];\n  undefined auStack_80 [104];\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  ppuVar1 = &puStack_18;\n  puStack_10 = (undefined *)0x0;\n  if (GLOBAL_CONST_TRUE != 0) {\n    ppuVar1 = (undefined **)auStack_88;\n    puStack_18 = auStack_80;\n    func_d81d9ab9fda5445a(puStack_18,0x41,99);\n    puStack_18[99] = 0;\n    puStack_10 = puStack_18;\n  }\n  *(undefined **)((long)ppuVar1 + -8) = &UNK_00400c55;\n  func_659fb2920e504272(puStack_10);\n  *(undefined **)((long)ppuVar1 + -8) = &UNK_00400c61;\n  func_393adaed45914655(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_a42906e0aa7d4001(void)\n\n{\n  func_03d810429be647a0();\n  func_1ad5cce1745b4dda();\n  return;\n}\n\n",
        "\nvoid func_e2031c1618ab4f84(short param_1)\n\n{\n  func_ab2a6268a7ce42a3((int)param_1);\n  return;\n}\n\n",
        "\nvoid func_f0f93adedef2481f(void)\n\n{\n  long lVar1;\n  undefined8 uStack_1e;\n  undefined4 uStack_16;\n  undefined2 uStack_12;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = 0;\n  uStack_1e = 0;\n  uStack_16 = 0;\n  uStack_12 = 0;\n  lVar1 = func_afff1cb285564d41(&uStack_1e,0xe,stdin);\n  if (lVar1 == 0) {\n    func_4e1633b52eb444fd(&UNK_00401218);\n  }\n  else {\n    iStack_c = func_7925a4eca2844677(&uStack_1e);\n  }\n  iStack_10 = iStack_c * iStack_c;\n  func_a64fe4fcc24d4f61(iStack_10);\n  return;\n}\n\n",
        "\nvoid func_560713ace3034c3e(void)\n\n{\n  undefined auStack_1c8 [24];\n  undefined *puStack_1b0;\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined *puStack_10;\n  \n  puStack_1b0 = &UNK_00400c16;\n  func_0bc307cfd4b24400(auStack_1a8,0x41,99);\n  uStack_1c = 0;\n  puStack_10 = auStack_1c8;\n  puStack_1b0 = &UNK_00400c38;\n  func_f761e6980e554718(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_a7fc4627746445b7(undefined8 *param_1)\n\n{\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined8 uStack_10;\n  \n  uStack_10 = *param_1;\n  func_eb17a834d8264ce1(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_9d5badecdb6f477d(uStack_10,auStack_1a8,100);\n  func_519dcbe28a494a80(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_689e74742be14fe5(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_40 [8];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  short sStack_20;\n  short sStack_1e;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  short sStack_a;\n  \n  sStack_a = 0;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_7e1d7026696c44f8(2,1,6);\n  if (iStack_14 != -1) {\n    func_71d72fd820be4603(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_5e1ece7abb474d9d(0x6987);\n    iVar1 = func_6834be5b6d884033(iStack_14,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_1b0e64ff7e4b47a8(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_f247a8ecba224c82(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_aae32433b6b3471b(iStack_10,auStack_40,7,0), iStack_18 != -1 && (iStack_18 != 0))\n       )) {\n      auStack_40[iStack_18] = 0;\n      iStack_1c = func_a409c8fd940b45cd(auStack_40);\n      if ((iStack_1c < 0x8000) && (-0x8001 < iStack_1c)) {\n        sStack_a = (short)iStack_1c;\n      }\n      else {\n        sStack_a = -1;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_91c1a3f66afa40e8(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_91c1a3f66afa40e8(iStack_10);\n  }\n  sStack_1e = sStack_a;\n  sStack_20 = sStack_a;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_71d72fd820be4603(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (sStack_20 < 100) {\n    func_dba3d404b5a04ab9(&uStack_a8,auStack_118,(long)sStack_20);\n    *(undefined *)((long)&uStack_a8 + (long)(int)sStack_20) = 0;\n  }\n  func_8915b6ca14a64b64(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_f82c64a075784f02(int *param_1)\n\n{\n  if (*param_1 == -0x80000000) {\n    func_637ceeb33ea7443e(&UNK_00401598);\n  }\n  else {\n    func_7e8c8d70c16f4963(*param_1 + -1);\n  }\n  return;\n}\n\n",
        "\nvoid func_0ca927e5f6b34f14(int param_1)\n\n{\n  if (param_1 < 0) {\n    func_9e0617a232a345f9(param_1 * 2);\n  }\n  return;\n}\n\n",
        "\nvoid func_58c0dea0562f4c13(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined4 uStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_7b0fe8c85a55480b(2,1,6);\n  if (iStack_10 != -1) {\n    func_6a04006b34ac48fc(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_8c40e62a71f14a15(&UNK_004014b4);\n    uStack_26 = func_17953be1d6f74f94(0x6987);\n    iVar1 = func_c6f58deca3344500(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_d16e1f406b6a428f(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      uStack_c = func_def43d72d5064d35(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_ae315fa205d84a9c(iStack_10);\n  }\n  uStack_18 = uStack_c;\n  func_5385bc0c2c1c431d(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_f40f93dd92434feb(undefined8 *param_1)\n\n{\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  uint uStack_28;\n  \n  func_3026f0488ae944db(&uStack_88,0x43,99);\n  uStack_28 = uStack_28 & 0xffffff;\n  *param_1 = uStack_88;\n  param_1[1] = uStack_80;\n  param_1[2] = uStack_78;\n  param_1[3] = uStack_70;\n  param_1[4] = uStack_68;\n  param_1[5] = uStack_60;\n  param_1[6] = uStack_58;\n  param_1[7] = uStack_50;\n  param_1[8] = uStack_48;\n  param_1[9] = uStack_40;\n  param_1[10] = uStack_38;\n  param_1[0xb] = uStack_30;\n  *(uint *)(param_1 + 0xc) = uStack_28;\n  *(undefined *)((long)param_1 + 99) = 0;\n  func_9060222f78a242c9(param_1);\n  return;\n}\n\n",
        "\nvoid func_470bfa372bc34e8e(void)\n\n{\n  func_f72acd1f4fd941fa();\n  func_cc99718743a94062();\n  return;\n}\n\n",
        "\nvoid func_ede6c0c07b084cde(undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = func_d318ba95aba54bc2(*param_1,&UNK_00401264);\n  if (lVar1 != 0) {\n    func_4005ddc158204945(lVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_f045967684094f4c\n               (undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_280 [408];\n  undefined8 uStack_e8;\n  undefined8 uStack_e0;\n  undefined8 uStack_d8;\n  undefined8 uStack_d0;\n  undefined8 uStack_c8;\n  undefined8 uStack_c0;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_18 = auStack_280;\n  badStatic = 1;\n  puStack_10 = puStack_18;\n  puStack_18 = (undefined *)func_f19a75181965444c(puStack_18,param_2,7);\n  uStack_e8 = 0;\n  uStack_e0 = 0;\n  uStack_d8 = 0;\n  uStack_d0 = 0;\n  uStack_c8 = 0;\n  uStack_c0 = 0;\n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  func_410657f943af4ed2(&uStack_e8,puStack_18);\n  func_bd026f3455b249d5(puStack_18);\n  return;\n}\n\n",
        "\nlong func_8d437acbe7b64cac(long param_1)\n\n{\n  long lStack_10;\n  \n  lStack_10 = param_1;\n  if (CWE126_Buffer_Overread__malloc_wchar_t_loop_22_goodG2B2Global != 0) {\n    lStack_10 = func_b2a1211edcc84e3d(400);\n    func_9999e999494e4e74(lStack_10,0x41,99);\n    *(undefined4 *)(lStack_10 + 0x18c) = 0;\n  }\n  return lStack_10;\n}\n\n",
        "\nvoid func_dae6327e9d754dc7(void)\n\n{\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  long lStack_38;\n  undefined8 *puStack_30;\n  undefined8 *puStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_a8 = 0x2068732f6e69622f;\n  uStack_a0 = 0x20616c2d20736c;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_10 = &uStack_a8;\n  lStack_18 = func_24ed6a0947b84abd(puStack_10);\n  lStack_20 = func_a353e8f101284bd6(&UNK_00401384);\n  if (lStack_20 != 0) {\n    func_c1ef8d7800d24652((long)puStack_10 + lStack_18,lStack_20,99 - lStack_18);\n  }\n  puStack_28 = puStack_10;\n  puStack_30 = puStack_10;\n  lStack_38 = func_2ce6bf50e38e4898(puStack_10,&UNK_00401388);\n  if (lStack_38 != 0) {\n    func_a86828f4117c4aaa(lStack_38);\n  }\n  return;\n}\n\n",
        "\nvoid func_9e1da6ce619047f2(void)\n\n{\n  undefined auStack_1a8 [408];\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_1a8;\n  func_ccbce4b2d5f34672(puStack_10,0x41,99);\n  *(undefined4 *)(puStack_10 + 0x18c) = 0;\n  func_b6f4cc0bde764477(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_b8b87adfe51d41db(void)\n\n{\n  func_1b10c0de116e49c6();\n  func_0eac813525d049b4();\n  return;\n}\n\n",
        "\nvoid func_2f2ff7a552374438(void)\n\n{\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  puStack_10 = &uStack_78;\n  puStack_10 = (undefined8 *)func_d2f8c77a3a514ba8(puStack_10);\n  func_a536aba9b9db4948(puStack_10,puStack_10);\n  return;\n}\n\n",
        "\nvoid func_a30e6a04b3ac48ff(void)\n\n{\n  undefined4 auStack_338 [200];\n  ulong uStack_18;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  uStack_10 = func_e99dc8ed4e444216(400);\n  for (uStack_18 = 0; uStack_18 < 100; uStack_18 = uStack_18 + 1) {\n    auStack_338[uStack_18 * 2] = 0;\n    auStack_338[uStack_18 * 2 + 1] = 0;\n  }\n  func_15da7032e55a49f8(uStack_10,auStack_338,800);\n  func_9414309c96994bd5(uStack_10);\n  func_b4a33d5818e8432e(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_e977027190764f5f(undefined8 param_1)\n\n{\n  func_616f8a9e365e4585(param_1);\n  return;\n}\n\n",
        "\nvoid func_5cb630f886b9405a(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  byte bVar3;\n  undefined8 auStack_1a8 [51];\n  undefined4 *puStack_10;\n  \n  bVar3 = 0;\n  puStack_10 = (undefined4 *)0x0;\n  func_5cb630f886b9405aGlobal = 1;\n  puStack_10 = (undefined4 *)func_1db428b14b084b6d(0);\n  puVar2 = auStack_1a8;\n  for (lVar1 = 0x32; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + (ulong)bVar3 * -2 + 1;\n  }\n  func_4b9ab0f73d44448d(puStack_10,auStack_1a8,400);\n  func_4c5ad688cfe740c9(*puStack_10);\n  func_edd88e34ad814ec6(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_8a1f2bee7f0d42d3(void)\n\n{\n  func_7a07d022dbd347b0();\n  return;\n}\n\n",
        "\nvoid func_d1fde1d519924132(undefined4 param_1)\n\n{\n  func_16ab342832eb4a09(param_1);\n  return;\n}\n\n",
        "\nvoid func_64a36f53a6504cb2(void)\n\n{\n  int iVar1;\n  undefined2 uStack_b8;\n  undefined2 uStack_b6;\n  undefined4 uStack_b4;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined8 *puStack_38;\n  undefined *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_10 = &uStack_a8;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_e2cb8259896b4daf(puStack_10);\n  iStack_14 = func_191198fe9baf4ba0(2,1,6);\n  if (iStack_14 != -1) {\n    func_06fd0a4600e44caa(&uStack_b8,0,0x10);\n    uStack_b8 = 2;\n    uStack_b4 = func_4587eb20604c45ef(&UNK_00401614);\n    uStack_b6 = func_2951a09003344502(0x6987);\n    iVar1 = func_38718c46f78d4e36(iStack_14,&uStack_b8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_fbcb2c88d5bd418a(iStack_14,(long)puStack_10 + lStack_20,99 - lStack_20,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      *(undefined *)((long)puStack_10 + iStack_24 + lStack_20) = 0;\n      puStack_30 = (undefined *)func_7a79f7cb54394605(puStack_10,0xd);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined *)func_7a79f7cb54394605(puStack_10,10);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_057bdeefd2604811(iStack_14);\n  }\n  puStack_38 = puStack_10;\n  func_ba2a4740d8d345ab(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_272cb94587584dbc(void)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  int iStack_c;\n  \n  iStack_c = 0xffffffff;\n  func_272cb94587584dbcGlobal = 1;\n  iStack_c = func_272cb94587584dbcSource(0xffffffff);\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_129812a79f8e485b(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (iStack_c < 100) {\n    func_d77fd94379354fee(&uStack_78,auStack_e8,(long)iStack_c);\n    *(undefined *)((long)&uStack_78 + (long)iStack_c) = 0;\n  }\n  func_2b159a3a8ba54aff(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_c885122cf4e84f4e(void)\n\n{\n  undefined auStack_78 [104];\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_78;\n  func_d9adf99749ab4e58(puStack_10,0x41,99);\n  puStack_10[99] = 0;\n  func_a1c75866aaed43db(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_31acc89640454e6b(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_70f135a7eb694190(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lStack_20 = func_ff5eb809e2504b45(&UNK_004013c6,&UNK_004013c4);\n    if (lStack_20 != 0) {\n      lVar1 = func_51ba55ef6cc54a06((long)puStack_10 + lStack_18,100 - (int)lStack_18,lStack_20);\n      if (lVar1 == 0) {\n        func_dc9b67bbab214cb9(&UNK_004013d4);\n        *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n      }\n      func_cf50d08fa6794cc5(lStack_20);\n    }\n  }\n  func_a7ccbbea36344a46(stdout,puStack_10);\n  return;\n}\n\n",
        "\nvoid func_017c6f36b0534b96(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_3ffc2f6be3114bd7(2,1,6);\n  if (iStack_10 != -1) {\n    func_546ee12cee52454d(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_d4414a0527aa44a4(&UNK_004014a4);\n    uStack_26 = func_243d258ed4cc48b0(0x6987);\n    iVar1 = func_32d14a46040e48c4(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_d5ebcd56c6514276(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      uStack_c = func_22e772383cf6499f(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_138f33843d244370(iStack_10);\n  }\n  func_017c6f36b0534b96Data = uStack_c;\n  func_95bd309da8b34d97();\n  return;\n}\n\n",
        "\nvoid func_255174632028489f(short param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_0241ddea0f4e45ba(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (param_1 < 100) {\n    func_61c03442f1814b0b(&uStack_78,auStack_e8,(long)param_1);\n    *(undefined *)((long)&uStack_78 + (long)(int)param_1) = 0;\n  }\n  func_52210cbf8ce54ccd(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_6e04b4d637c34cb7(short param_1)\n\n{\n  func_8e690a1c43fc4b2e((int)param_1);\n  return;\n}\n\n",
        "\nvoid func_2b1534a25a7a47e7(void)\n\n{\n  func_1482064819ac4b1f();\n  return;\n}\n\n",
        "\nvoid func_9cfe24e036574244(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  ushort uStack_18;\n  \n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  uVar1 = func_29039b41f9b14f0c(param_1);\n  func_a918dd67b27a418e(&uStack_48,param_1,uVar1);\n  uStack_18 = uStack_18 & 0xff;\n  func_5aae8b7e534f4201(param_1);\n  func_72fcfed9ab1148fa(param_1);\n  return;\n}\n\n",
        "\nvoid func_b6ac7d8013534183(void)\n\n{\n  func_653a22aa6ac64b81();\n  return;\n}\n\n",
        "\nvoid func_0e56478b0f414124(void)\n\n{\n  undefined *puStack_80;\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  undefined **ppuStack_10;\n  \n  puStack_80 = &UNK_00400bf0;\n  func_df2537e9c7b64c1d(auStack_78,0x41,99);\n  uStack_15 = 0;\n  ppuStack_10 = &puStack_80;\n  puStack_80 = &UNK_00400c0c;\n  func_86a8280d2f014ac1(&ppuStack_10);\n  return;\n}\n\n",
        "\nvoid func_d6ddfff3b99e415b(void)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  if (staticTrue != 0) {\n    puVar2 = (undefined8 *)func_61ab62a0583c4826(8);\n    puVar1 = (undefined4 *)*puVar2;\n    func_390484647e114a89(puVar2);\n    func_12b18520a2394b7a(*puVar1);\n    func_12b18520a2394b7a(puVar1[1]);\n  }\n  return;\n}\n\n",
        "\nvoid func_4b2ba2f892bb4621(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_1a8;\n  undefined8 uStack_1a0;\n  undefined8 auStack_198 [49];\n  undefined8 *puStack_10;\n  \n  if (globalFive == 5) {\n    uStack_1a8 = 0;\n    uStack_1a0 = 0;\n    puVar2 = auStack_198;\n    for (lVar1 = 0x30; lVar1 != 0; lVar1 = lVar1 + -1) {\n      *puVar2 = 0;\n      puVar2 = puVar2 + 1;\n    }\n    puStack_10 = &uStack_1a8;\n    func_ea5b601ec1634927(puStack_10,&UNK_004011f8);\n    func_5029b2d3b2124ed7(puStack_10 + 3,puStack_10 + 2,0x28);\n    func_900c67bd66c24422(puStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_acc2c4498fba43e0(void)\n\n{\n  func_4405fc58719d4b40();\n  func_dff6346600974259();\n  func_6710d7890d35467f();\n  func_ea7ee098ee984520();\n  return;\n}\n\n",
        "\nvoid func_befa6931d3724e97(void)\n\n{\n  func_dbea0a8f61744262();\n  func_251ead0041e945b2();\n  return;\n}\n\n",
        "\nvoid func_d67269d7c3814485(void)\n\n{\n  long lVar1;\n  undefined8 uStack_20;\n  code *pcStack_18;\n  short sStack_a;\n  \n  pcStack_18 = badSink;\n  sStack_a = 0;\n  uStack_20 = 0;\n  lVar1 = func_879456be80964e2c(&uStack_20,8,stdin);\n  if (lVar1 == 0) {\n    func_1ed200bc9b614c6f(&UNK_004013b4);\n  }\n  else {\n    sStack_a = func_c36c1752f6f146e9(&uStack_20);\n  }\n  (*pcStack_18)((int)sStack_a);\n  return;\n}\n\n",
        "\nvoid func_485878c2e6d4498b(char param_1)\n\n{\n  func_170bd026f0e349bf((int)param_1);\n  return;\n}\n\n",
        "\nvoid func_bce9bebdc51348a9(void)\n\n{\n  undefined auStack_1b0 [408];\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_1b0;\n  func_ac4bd8a3e2ff4164(puStack_10,0x41,99);\n  *(undefined4 *)(puStack_10 + 0x18c) = 0;\n  puStack_18 = puStack_10 + -0x20;\n  func_6a8348b565934009(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_b444165bfb264b0b(short param_1)\n\n{\n  func_8e2763f024ae4bfc((int)param_1);\n  return;\n}\n\n",
        "\nvoid func_77bf84a9a90c4c76(undefined4 param_1)\n\n{\n  func_a248c517b52a48c8(param_1);\n  return;\n}\n\n",
        "\nvoid func_002a49165cd9478a(undefined8 param_1)\n\n{\n  func_8eebc5d451724792(param_1);\n  return;\n}\n\n",
        "\nvoid func_c872382f4abe4be9(void)\n\n{\n  int iVar1;\n  \n  iVar1 = func_1263867eda104272();\n  if (iVar1 != 0) {\n    func_cb20edf587c54c0e(2,0);\n    if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad != (undefined4 *)0x0) {\n      func_6a653c4bee304fba(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad);\n      CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = (undefined4 *)0x0;\n    }\n    CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad =\n         (undefined4 *)func_a39998e180ff40a9(4);\n    *CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = 1;\n    func_cb20edf587c54c0e(2,helperBad);\n    if (CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad != (undefined4 *)0x0) {\n      func_6a653c4bee304fba(CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad);\n      CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = (undefined4 *)0x0;\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_c7f73c749ff84f2b(void)\n\n{\n  func_e873bdd812c54247(0);\n  return;\n}\n\n",
        "\nvoid func_3bb43862d77b4c0b(undefined8 param_1)\n\n{\n  func_4b37c704c50944de(param_1);\n  return;\n}\n\n",
        "\nvoid func_37050cc530f9473c(undefined8 param_1)\n\n{\n  func_b3cce347f46c4d96(param_1);\n  return;\n}\n\n",
        "\nvoid func_0537a809e43a497b(undefined8 param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  byte bVar4;\n  undefined auStack_810 [816];\n  undefined8 auStack_4e0 [51];\n  undefined8 auStack_348 [101];\n  undefined *puStack_20;\n  undefined8 *puStack_18;\n  undefined8 *puStack_10;\n  \n  bVar4 = 0;\n  puStack_18 = auStack_4e0;\n  puStack_20 = auStack_810;\n  iVar1 = func_d362e5528f3e4afa(param_1,0x10,7);\n  if (iVar1 != 0) {\n    puStack_10 = puStack_18;\n  }\n  puVar3 = auStack_348;\n  for (lVar2 = 100; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n  }\n  func_05be296229984013(puStack_10,auStack_348,800);\n  func_79be266fb4424e4c(*puStack_10);\n  return;\n}\n\n",
        "\nvoid func_d351d1fae60f487b(void)\n\n{\n  long lVar1;\n  long lVar2;\n  int *piStack_10;\n  \n  piStack_10 = (int *)func_49ca387ab52e4da4(400);\n  *piStack_10 = 0;\n  lVar1 = func_55d964b08f0b4348(piStack_10);\n  lVar2 = func_c28406c14c0a4031(&UNK_00401324);\n  if (lVar2 != 0) {\n    func_f669d4d15cfb4349(piStack_10 + lVar1,lVar2,99 - lVar1);\n  }\n  if (staticFive == 5) {\n    for (; *piStack_10 != 0; piStack_10 = piStack_10 + 1) {\n      if (*piStack_10 == 0x53) {\n        func_7b89a9f6e01a45bf(&UNK_00401334);\n        break;\n      }\n    }\n    func_a2ae235f73cd49d3(piStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_d863217e2b5c4a0a(void)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = CWE194_Unexpected_Sign_Extension__fgets_strncpy_68_badData;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_fac88196787049d8(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_dca2ac0c7ab54c72(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_2fd691c7ce774416(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_026a1c82d15a419a(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_3ae60803d4494003(2,1,6);\n  if (iStack_14 != -1) {\n    func_5ec957db4d7148cd(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_db6f2cd0648e44af(0x6987);\n    iVar1 = func_6588ed4e8b4d4d13(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_1a11107f69fd479b(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_f315b31e75da4f5d(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_991ed28ff33e4488(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      iStack_c = func_c21ebe81817b4615(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_9bb287e0ed7b4e84(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_9bb287e0ed7b4e84(iStack_10);\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_5ec957db4d7148cd(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_77308a313d5941f7(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_c10709c14a544194(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_219daad141a64cfa(undefined8 param_1)\n\n{\n  func_730068bdf74249de(param_1);\n  return;\n}\n\n",
        "\nvoid func_1c0eb3a6216541b4\n               (undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined8 uStack_18;\n  undefined4 uStack_10;\n  \n  uStack_38 = 0x4100000041;\n  uStack_30 = 0x4100000041;\n  uStack_28 = 0x4100000041;\n  uStack_20 = 0x4100000041;\n  uStack_18 = 0x4100000041;\n  uStack_10 = 0;\n  lVar1 = func_a9dcaa00d0fa44ac(&uStack_38);\n  func_b08df5c4a181482b(param_1,&uStack_38,(lVar1 + 1) * 4);\n  func_8dbc10c149de4c0c(param_1);\n  return;\n}\n\n",
        "\nvoid func_474933e44e404ef5(void)\n\n{\n  int iVar1;\n  undefined auStack_58 [32];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_28;\n  int iStack_24;\n  code *pcStack_20;\n  int iStack_14;\n  undefined8 uStack_10;\n  \n  pcStack_20 = badSink;\n  uStack_10 = 0;\n  iStack_24 = 0xffffffff;\n  iStack_14 = -1;\n  iStack_24 = func_050a32f90efd466d(2,1,6);\n  if (iStack_24 != -1) {\n    func_83668502f7144501(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_fb867ed797874139(0x6987);\n    iVar1 = func_f4f53ff3ffce4aa4(iStack_24,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_719bac80a6e44e56(iStack_24,5), iVar1 != -1)) &&\n        (iStack_14 = func_f4fcde414d5d4903(iStack_24,0,0), iStack_14 != -1)) &&\n       ((iStack_28 = func_65cb88367cd944d9(iStack_14,auStack_58,0x19,0), iStack_28 != -1 &&\n        (iStack_28 != 0)))) {\n      auStack_58[iStack_28] = 0;\n      uStack_10 = func_f83fdfb879bc4497(auStack_58,0,0);\n    }\n  }\n  if (iStack_24 != -1) {\n    func_07383579903f4f22(iStack_24);\n  }\n  if (iStack_14 != -1) {\n    func_07383579903f4f22(iStack_14);\n  }\n  (*pcStack_20)(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_82119cd0455d4187(void)\n\n{\n  int iVar1;\n  undefined auStack_58 [32];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  undefined4 *puStack_20;\n  int iStack_18;\n  int iStack_14;\n  ulong uStack_10;\n  \n  uStack_10 = 0;\n  if (globalFive == 5) {\n    iStack_14 = 0xffffffff;\n    iStack_14 = func_f2f405a1c8934a1e(2,1,6);\n    if (iStack_14 != -1) {\n      func_11c8a5bfa1684d21(&uStack_38,0,0x10);\n      uStack_38 = 2;\n      uStack_34 = func_d42296dca1d947b5(&UNK_00401548);\n      uStack_36 = func_fe82c603e88c4636(0x6987);\n      iVar1 = func_1e84c4cf8fd44e4f(iStack_14,&uStack_38,0x10);\n      if (((iVar1 != -1) &&\n          (iStack_18 = func_d8b4959ecebc4ba0(iStack_14,auStack_58,0x19,0), iStack_18 != -1)) &&\n         (iStack_18 != 0)) {\n        auStack_58[iStack_18] = 0;\n        uStack_10 = func_5f15f10f358d47ad(auStack_58,0,0);\n      }\n    }\n    if (iStack_14 != -1) {\n      func_e6d294842f394ac4(iStack_14);\n    }\n  }\n  if (globalFive == 5) {\n    if (uStack_10 < 6) {\n      func_4ed5936ccae94238(&UNK_00401558);\n    }\n    else {\n      puStack_20 = (undefined4 *)func_6f13378815224d35(uStack_10);\n      *puStack_20 = 0x6c6c6568;\n      *(undefined2 *)(puStack_20 + 1) = 0x6f;\n      func_4ed5936ccae94238(puStack_20);\n      func_98972ac657fc4cc5(puStack_20);\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_f281269f974443b4(void)\n\n{\n  int iVar1;\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)0x0;\n  iVar1 = func_062076d7ccad4111();\n  if (iVar1 != 0) {\n    puStack_10 = (undefined4 *)func_f10be18685c44a11(200);\n    *puStack_10 = 0;\n  }\n  func_6f3d5adbbc5c41df(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_ec603daded074b45(puStack_10,auStack_1a8);\n  func_4a110171138149e9(puStack_10);\n  func_cd636d9640d54cef(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_6b3637f57c704ddb(undefined8 param_1)\n\n{\n  func_276819ae85fe4ca0(param_1);\n  return;\n}\n\n",
        "\nvoid func_5ea183d32fdb4d3f(void)\n\n{\n  undefined auStack_1a8 [408];\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_1a8;\n  func_eb471ad8a6c14261(&puStack_10);\n  return;\n}\n\n",
        "\nvoid func_1f52507214db4ab7(void)\n\n{\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  ulong uStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)0x0;\n  if (GLOBAL_CONST_FIVE == 5) {\n    puStack_10 = (undefined4 *)func_69021bfdc3584dce(10);\n  }\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  for (uStack_18 = 0; uStack_18 < 10; uStack_18 = uStack_18 + 1) {\n    puStack_10[uStack_18] = *(undefined4 *)((long)&uStack_48 + uStack_18 * 4);\n  }\n  func_501476af3ee14ff6(*puStack_10);\n  func_7ea0d4e7f9b54292(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_aba62bb95a974f3d(void)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_d612eceb07bc458d(100);\n  *pcStack_10 = '\\0';\n  lVar1 = func_acd71ee91a3e4a09(pcStack_10);\n  if ((1 < 100U - lVar1) && (lVar2 = func_8ddb884756c14201(&UNK_00401396,&UNK_00401394), lVar2 != 0)) {\n    lVar3 = func_271274ec14414293(pcStack_10 + lVar1,100 - (int)lVar1,lVar2);\n    if (lVar3 == 0) {\n      func_3c46155080ae4e98(&UNK_004013a4);\n      pcStack_10[lVar1] = '\\0';\n    }\n    func_bda7dff20a044332(lVar2);\n  }\n  if (GLOBAL_CONST_TRUE != 0) {\n    for (; *pcStack_10 != '\\0'; pcStack_10 = pcStack_10 + 1) {\n      if (*pcStack_10 == 'S') {\n        func_3c46155080ae4e98(&UNK_004013b3);\n        break;\n      }\n    }\n    func_b18e6a5bf74a4dcf(pcStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_2c9481d6b5594d74(void)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_c4f2768defd54dcb(100);\n  *pcStack_10 = '\\0';\n  lVar1 = func_7f721ba5fff84388(pcStack_10);\n  if ((1 < 100U - lVar1) && (lVar2 = func_091a1e16b0a043a4(&UNK_0040139e,&UNK_0040139c), lVar2 != 0)) {\n    lVar3 = func_e4ba9e47e4dd4f87(pcStack_10 + lVar1,100 - (int)lVar1,lVar2);\n    if (lVar3 == 0) {\n      func_3d023b5078d3408e(&UNK_004013ac);\n      pcStack_10[lVar1] = '\\0';\n    }\n    func_ed2a0595b2d643fc(lVar2);\n  }\n  do {\n    if (*pcStack_10 == '\\0') {\ncode_r0x00400e0d:\n      func_04f93bfffb3945cd(pcStack_10);\n      return;\n    }\n    if (*pcStack_10 == 'S') {\n      func_3d023b5078d3408e(&UNK_004013bb);\n      goto code_r0x00400e0d;\n    }\n    pcStack_10 = pcStack_10 + 1;\n  } while( true );\n}\n\n",
        "\nvoid func_fa702a5f6f504eab(undefined8 param_1)\n\n{\n  func_666d920c6e5b48d6(param_1);\n  return;\n}\n\n",
        "\nvoid func_a483a4d71b414d1d(void)\n\n{\n  func_80f1f16213a64de0();\n  func_c32a990ae2e04075();\n  return;\n}\n\n",
        "\nvoid func_be7f3ff848e24d4b(void)\n\n{\n  undefined auStack_1b0 [408];\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_1b0;\n  func_45867a618f0a45c3(puStack_10,0x41,99);\n  *(undefined4 *)(puStack_10 + 0x18c) = 0;\n  puStack_18 = puStack_10 + -0x20;\n  func_738557494e0143ae(&puStack_18);\n  return;\n}\n\n",
        "\nvoid func_b997dce0289341a5\n               (undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 extraout_RDX;\n  undefined *puVar3;\n  undefined auVar4 [16];\n  undefined auStack_368 [8];\n  undefined4 auStack_360 [200];\n  undefined *puStack_40;\n  undefined auStack_38 [8];\n  undefined4 *puStack_30;\n  undefined4 *puStack_28;\n  ulong uStack_20;\n  ulong uStack_18;\n  undefined4 *puStack_10;\n  \n  puVar3 = auStack_38;\n  puStack_10 = (undefined4 *)0x0;\n  puStack_40 = &UNK_00400c3c;\n  iVar1 = func_0761449725384409();\n  if (iVar1 == 0) {\n    puStack_40 = &UNK_00400cd7;\n    auVar4 = func_f1ec1a22d06c41bd(800);\n    puStack_28 = auVar4._0_8_;\n    if (puStack_28 == (undefined4 *)0x0) {\n      puStack_40 = &UNK_00400cec;\n      func_cd0f86ffd92d4fd4(&UNK_004012e4);\n      puStack_40 = &UNK_00400cf6;\n      func_edb208a0b40c4293(1);\n      auVar4._8_8_ = extraout_RDX;\n      auVar4._0_8_ = puStack_28;\n    }\n    lVar2 = auVar4._8_8_;\n    puStack_28 = auVar4._0_8_;\n    for (uStack_20 = 0; uStack_20 < 100; uStack_20 = uStack_20 + 1) {\n      puStack_28[uStack_20 * 2] = 1;\n      lVar2 = uStack_20 * 8;\n      puStack_28[uStack_20 * 2 + 1] = 1;\n    }\n    puStack_10 = puStack_28;\n  }\n  else {\n    lVar2 = 7;\n    puVar3 = auStack_368;\n    puStack_30 = auStack_360;\n    for (uStack_18 = 0; puStack_10 = puStack_30, uStack_18 < 100; uStack_18 = uStack_18 + 1) {\n      puStack_30[uStack_18 * 2] = 1;\n      lVar2 = uStack_18 * 8;\n      auStack_360[uStack_18 * 2 + 1] = 1;\n    }\n  }\n  *(undefined **)(puVar3 + -8) = &UNK_00400d53;\n  func_d3366f49e358410f(puStack_10,param_2,lVar2);\n  *(undefined **)(puVar3 + -8) = &UNK_00400d5f;\n  func_47def90e186c423d(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_7801df7670b24eed(void)\n\n{\n  func_cad774ca02e84fec();\n  return;\n}\n\n",
        "\nvoid func_ba354fd3a2824194(undefined8 param_1)\n\n{\n  func_50af6afe9e38402f(param_1,param_1);\n  return;\n}\n\n",
        "\nvoid func_c56758e8d6d345f9(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined2 uStack_1d8;\n  undefined2 uStack_1d6;\n  undefined4 uStack_1d4;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [48];\n  undefined4 *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  code *pcStack_10;\n  \n  pcStack_10 = CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65b_badSink;\n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_18 = &uStack_1c8;\n  iStack_1c = 0xffffffff;\n  lStack_28 = func_e9f3fb922ed3413e(puStack_18);\n  iStack_1c = func_5fd9a585604c4673(2,1,6);\n  if (iStack_1c != -1) {\n    func_1d083df697be4377(&uStack_1d8,0,0x10);\n    uStack_1d8 = 2;\n    uStack_1d4 = func_a2ca76b0a9c74c32(&UNK_004015c4);\n    uStack_1d6 = func_9c9d720b1f72412b(0x6987);\n    iVar1 = func_f89d65dab61f431c(iStack_1c,&uStack_1d8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_2c = func_27143a6aab814a56(iStack_1c,lStack_28 * 4 + (long)puStack_18,(99 - lStack_28) * 4\n                                     ,0), iStack_2c != -1)) && (iStack_2c != 0)) {\n      *(undefined4 *)((long)puStack_18 + (lStack_28 + ((ulong)(long)iStack_2c >> 2)) * 4) = 0;\n      puStack_38 = (undefined4 *)func_d6d0e1ec2f5b4ff9(puStack_18,0xd);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n      puStack_38 = (undefined4 *)func_d6d0e1ec2f5b4ff9(puStack_18,10);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n    }\n  }\n  if (iStack_1c != -1) {\n    func_33cbcab4c35c4a76(iStack_1c);\n  }\n  (*pcStack_10)(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_1ebd0ef029f84bd3(undefined8 param_1)\n\n{\n  func_d3a327fc8463472c(param_1);\n  return;\n}\n\n",
        "\nvoid func_fc6b0f72694b4cbe(void)\n\n{\n  func_bd6638e45db54fd4();\n  func_548090fc524d490d();\n  return;\n}\n\n",
        "\nvoid func_1e388628bdff49bb(void)\n\n{\n  undefined auStack_430 [416];\n  undefined4 auStack_290 [50];\n  undefined auStack_1c8 [396];\n  undefined4 uStack_3c;\n  undefined4 *puStack_30;\n  undefined4 *puStack_28;\n  undefined4 *puStack_20;\n  undefined *puStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_30 = auStack_290;\n  puStack_18 = auStack_430;\n  auStack_290[0] = 0;\n  puStack_28 = puStack_30;\n  puStack_20 = puStack_30;\n  puStack_10 = puStack_30;\n  func_88bc108cd6454907(auStack_1c8,0x43,99);\n  uStack_3c = 0;\n  func_3234a41eff5d461d(puStack_30,auStack_1c8);\n  func_f3ec02070a554ceb(puStack_30);\n  return;\n}\n\n",
        "\nvoid func_d22630111c5349ac(void)\n\n{\n  func_dbeb67dad2cb4615();\n  return;\n}\n\n",
        "\nvoid func_817cac1dfc8742ef(undefined8 param_1)\n\n{\n  func_e0b95fe593514fd5(&UNK_004013c0,&UNK_004013c0,&UNK_004013b4,&UNK_004013a4,param_1,0);\n  return;\n}\n\n",
        "\nvoid func_036376c4159f4766(long param_1)\n\n{\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  \n  func_06ce506e7c994a58(auStack_78,0x43,99);\n  uStack_15 = 0;\n  func_b05b15bb68a64e02(param_1,auStack_78,100);\n  *(undefined *)(param_1 + 99) = 0;\n  func_f0ccf3fa02a44673(param_1);\n  return;\n}\n\n",
        "\nvoid func_46e7eaaef37a42eb(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_37bc7963af94464a(2,1,6);\n  if (iStack_10 != -1) {\n    func_52164f40b18d42e4(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_ce96b6341b7f47eb(&UNK_004014c4);\n    uStack_26 = func_0232571e38894e9d(0x6987);\n    iVar1 = func_abf2a055d5d341b2(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_5a9a90cee3084fc5(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      uStack_c = func_5146ea21a1c64f87(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_7c8096af5a78427d(iStack_10);\n  }\n  func_5114661cd1904d94(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_325ef372110b42b4\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n               undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined8 uStack_138;\n  undefined8 uStack_130;\n  undefined8 uStack_128;\n  undefined8 uStack_120;\n  undefined8 uStack_118;\n  undefined8 uStack_110;\n  undefined8 uStack_108;\n  undefined8 uStack_100;\n  undefined8 uStack_f8;\n  undefined8 uStack_f0;\n  undefined8 uStack_e8;\n  undefined8 uStack_e0;\n  undefined4 uStack_d8;\n  undefined4 uStack_d0;\n  undefined4 uStack_cc;\n  undefined *puStack_c8;\n  undefined *puStack_c0;\n  undefined auStack_b8 [8];\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined4 uStack_88;\n  undefined4 uStack_78;\n  undefined4 uStack_68;\n  undefined4 uStack_58;\n  undefined4 uStack_48;\n  undefined4 uStack_38;\n  undefined4 uStack_28;\n  undefined4 uStack_18;\n  \n  if (in_AL != '\\0') {\n    uStack_88 = param_1;\n    uStack_78 = param_2;\n    uStack_68 = param_3;\n    uStack_58 = param_4;\n    uStack_48 = param_5;\n    uStack_38 = param_6;\n    uStack_28 = param_7;\n    uStack_18 = param_8;\n  }\n  if (CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_22_goodB2G2Global != 0) {\n    uStack_138 = 0;\n    uStack_130 = 0;\n    uStack_128 = 0;\n    uStack_120 = 0;\n    uStack_118 = 0;\n    uStack_110 = 0;\n    uStack_108 = 0;\n    uStack_100 = 0;\n    uStack_f8 = 0;\n    uStack_f0 = 0;\n    uStack_e8 = 0;\n    uStack_e0 = 0;\n    uStack_d8 = 0;\n    uStack_d0 = 8;\n    uStack_cc = 0x30;\n    puStack_c8 = &stack0x00000008;\n    puStack_c0 = auStack_b8;\n    uStack_b0 = param_10;\n    uStack_a8 = param_11;\n    uStack_a0 = param_12;\n    uStack_98 = param_13;\n    uStack_90 = param_14;\n    func_0c592619a5c04dff(&uStack_138,99,&UNK_00401969,&uStack_d0);\n    func_4a97bac7f32d423e(&uStack_138);\n  }\n  return;\n}\n\n",
        "\nvoid func_082972115c4c4620(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = func_310d7e5dcf534901(0,0x14);\n  func_ff638181abfa4936(uVar1);\n  return;\n}\n\n",
        "\nvoid func_fce7bea86f14416a(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  undefined8 *puStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_10dcd0ab442149cc(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lVar1 = func_0237c6bf3abf4d5e((long)puStack_10 + lStack_18,100 - (int)lStack_18,stdin);\n    if (lVar1 == 0) {\n      func_b7bde060a5b04709(&UNK_004013c4);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    else {\n      lStack_18 = func_10dcd0ab442149cc(puStack_10);\n      if ((lStack_18 != 0) && (*(char *)((long)puStack_10 + lStack_18 + -1) == '\\n')) {\n        *(undefined *)((long)puStack_10 + lStack_18 + -1) = 0;\n      }\n    }\n  }\n  puStack_20 = puStack_10;\n  func_9d99bb896dd14128(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_3c9f4e2b2e42469a(void)\n\n{\n  undefined auStack_88 [99];\n  undefined uStack_25;\n  undefined *puStack_20;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = (undefined *)0x0;\n  puStack_20 = (undefined *)func_9e86ebc4d8d549f6(0x32);\n  *puStack_20 = 0;\n  puStack_18 = puStack_20;\n  puStack_10 = puStack_20;\n  func_b14c05420bfe435e(auStack_88,0x43,99);\n  uStack_25 = 0;\n  func_fb9dff0ddea74d98(puStack_18,auStack_88,100);\n  func_905ba0b02e224f14(puStack_18);\n  func_7e507e0d81394d18(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_00e40076d3e74faa(short param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_9d06aaa017334242(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (param_1 < 100) {\n    func_c0f35e9dd93047c4(&uStack_78,auStack_e8,(long)param_1);\n    *(undefined *)((long)&uStack_78 + (long)(int)param_1) = 0;\n  }\n  func_854eae6348194257(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_b561c10171b24823(void)\n\n{\n  int iVar1;\n  int iVar2;\n  uint auStack_1c [3];\n  \n  auStack_1c[0] = 0xffffffff;\n  iVar1 = func_a07d25c721814432();\n  iVar2 = func_a07d25c721814432();\n  auStack_1c[0] = func_a07d25c721814432();\n  auStack_1c[0] = auStack_1c[0] ^ iVar1 << 0x1e ^ iVar2 << 0xf;\n  func_1731bcfe1b0246e5(auStack_1c);\n  return;\n}\n\n",
        "\nvoid func_1654e0cc6763427e(void)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_40413b59e48d4d42(100);\n  *pcStack_10 = '\\0';\n  lVar1 = func_e11a0fc8090e4d12(pcStack_10);\n  if ((1 < 100U - lVar1) && (lVar2 = func_fdd06e0b8b534331(&UNK_00401396,&UNK_00401394), lVar2 != 0)) {\n    lVar3 = func_5c9be09474194154(pcStack_10 + lVar1,100 - (int)lVar1,lVar2);\n    if (lVar3 == 0) {\n      func_523a807b2e5a4720(&UNK_004013a4);\n      pcStack_10[lVar1] = '\\0';\n    }\n    func_ff169790a8b6479c(lVar2);\n  }\n  do {\n    if (*pcStack_10 == '\\0') {\ncode_r0x00400e05:\n      func_74b6cd9c9fcb4171(pcStack_10);\n      return;\n    }\n    if (*pcStack_10 == 'S') {\n      func_523a807b2e5a4720(&UNK_004013b3);\n      goto code_r0x00400e05;\n    }\n    pcStack_10 = pcStack_10 + 1;\n  } while( true );\n}\n\n",
        "\nvoid func_4fafa9ec759a4ef3(int param_1)\n\n{\n  undefined4 *puVar1;\n  ulong uStack_10;\n  \n  puVar1 = (undefined4 *)func_8afa7d294b3c43ce((long)param_1 << 2);\n  for (uStack_10 = 0; uStack_10 < (ulong)(long)param_1; uStack_10 = uStack_10 + 1) {\n    puVar1[uStack_10] = 0;\n  }\n  func_ec87bdb021324799(*puVar1);\n  func_27fa028a81124b8f(puVar1);\n  return;\n}\n\n",
        "\nvoid func_8f9ec7232eee4c6b(void)\n\n{\n  undefined8 uVar1;\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  long lStack_10;\n  \n  lStack_10 = 0;\n  if (staticTrue != 0) {\n    lStack_10 = func_a5b1d88361fd49d0(0x32);\n    func_8ced85419a734257(lStack_10,0x41,0x31);\n    *(undefined *)(lStack_10 + 0x31) = 0;\n  }\n  func_8ced85419a734257(auStack_78,0x43,99);\n  uStack_15 = 0;\n  uVar1 = func_13353a6cb3df4812(auStack_78);\n  func_065cd0d1813e4da0(auStack_78,lStack_10,uVar1);\n  uStack_15 = 0;\n  func_251a8dc329544546(auStack_78);\n  func_4768474f3c744d2e(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_c4328e8220144400(void)\n\n{\n  int iVar1;\n  undefined2 uStack_48;\n  undefined2 uStack_46;\n  undefined4 uStack_44;\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_18;\n  int iStack_14;\n  int *piStack_10;\n  \n  piStack_10 = (int *)func_c84e151dfb704647(400);\n  *piStack_10 = 0;\n  iStack_18 = 0xffffffff;\n  iStack_14 = -1;\n  lStack_20 = func_4f64218127484ad3(piStack_10);\n  iStack_18 = func_1b755848c3f742be(2,1,6);\n  if (iStack_18 != -1) {\n    func_b918d6c0850442c9(&uStack_48,0,0x10);\n    uStack_48 = 2;\n    uStack_44 = 0;\n    uStack_46 = func_e28f2cf1b2a8412d(0x6987);\n    iVar1 = func_382d1160b82b4bcf(iStack_18,&uStack_48,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_8e764d17dd044a1c(iStack_18,5), iVar1 != -1)) &&\n        (iStack_14 = func_fe8a8821f9a0496f(iStack_18,0,0), iStack_14 != -1)) &&\n       ((iStack_24 = func_a62f3bc5ff614c08(iStack_14,piStack_10 + lStack_20,(99 - lStack_20) * 4,0),\n        iStack_24 != -1 && (iStack_24 != 0)))) {\n      piStack_10[lStack_20 + ((ulong)(long)iStack_24 >> 2)] = 0;\n      puStack_30 = (undefined4 *)func_772c355ae7544bfe(piStack_10,0xd);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined4 *)func_772c355ae7544bfe(piStack_10,10);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_18 != -1) {\n    func_18af8b3a86ee42a0(iStack_18);\n  }\n  if (iStack_14 != -1) {\n    func_18af8b3a86ee42a0(iStack_14);\n  }\n  do {\n    if (*piStack_10 == 0) {\ncode_r0x004010fd:\n      func_459ed1d6b9964cb8(piStack_10);\n      return;\n    }\n    if (*piStack_10 == 0x53) {\n      func_9533ac01f2bb4a40(&UNK_00401684);\n      goto code_r0x004010fd;\n    }\n    piStack_10 = piStack_10 + 1;\n  } while( true );\n}\n\n",
        "\nvoid func_8bea84955d894630(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_42c998856d26451e(2,1,6);\n  if (iStack_14 != -1) {\n    func_6de51dcddf2c425f(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_c7fbe166ae1d40d8(0x6987);\n    iVar1 = func_ba692fb74d224132(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_e96058c4bbca41a6(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_0f5454212ded4e53(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_e7e3017e2d734b7b(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      uStack_c = func_92c53449e2f74424(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_3359f1d5021a4e1d(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_3359f1d5021a4e1d(iStack_10);\n  }\n  func_8bea84955d894630Data = uStack_c;\n  func_eadbd3742e204fc0();\n  return;\n}\n\n",
        "\nvoid func_40b022a574f345cd(void)\n\n{\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  uint uStack_28;\n  undefined8 *puStack_20;\n  \n  puStack_20 = (undefined8 *)0x0;\n  badStatic = 1;\n  puStack_20 = (undefined8 *)func_cb38bc96c8d14cc7(0);\n  func_7433264d14ea41c2(&uStack_88,0x43,99);\n  uStack_28 = uStack_28 & 0xffffff;\n  *puStack_20 = uStack_88;\n  puStack_20[1] = uStack_80;\n  puStack_20[2] = uStack_78;\n  puStack_20[3] = uStack_70;\n  puStack_20[4] = uStack_68;\n  puStack_20[5] = uStack_60;\n  puStack_20[6] = uStack_58;\n  puStack_20[7] = uStack_50;\n  puStack_20[8] = uStack_48;\n  puStack_20[9] = uStack_40;\n  puStack_20[10] = uStack_38;\n  puStack_20[0xb] = uStack_30;\n  *(uint *)(puStack_20 + 0xc) = uStack_28;\n  *(undefined *)((long)puStack_20 + 99) = 0;\n  func_99975eb74cbb4aa9(puStack_20);\n  func_8ef7784776af4984(puStack_20);\n  return;\n}\n\n",
        "\nvoid func_67f1bb1b83f64de0(void)\n\n{\n  int iVar1;\n  ushort auStack_1a [5];\n  \n  auStack_1a[0] = 0;\n  func_c7484024f4c5432c();\n  iVar1 = func_c7484024f4c5432c();\n  auStack_1a[0] = func_c7484024f4c5432c();\n  auStack_1a[0] = auStack_1a[0] ^ (ushort)(iVar1 << 0xf);\n  func_02088cc7169f43ee(auStack_1a);\n  return;\n}\n\n",
        "\nvoid func_3f793f47a9b14cb2(void)\n\n{\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  badStatic = 1;\n  uStack_10 = func_d34397613e4145cc(0);\n  func_4f646ae75d814be2(auStack_78,0x43,99);\n  uStack_15 = 0;\n  func_b4c585b128db4c8c(uStack_10,auStack_78,100);\n  func_c13e82748eea4fc9(uStack_10);\n  func_64ad8fe9e3844ccc(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_759b1ed54a8a4526(undefined8 param_1)\n\n{\n  func_abc2385989364b10(param_1);\n  return;\n}\n\n",
        "\nvoid func_a23da15c06cc4594(undefined8 param_1)\n\n{\n  func_99a7e1cbb17a4958(param_1);\n  return;\n}\n\n",
        "\nvoid func_685679133d744e21(void)\n\n{\n  func_bc752db66e044e09();\n  func_db694b3fcacb47f5();\n  return;\n}\n\n",
        "\nvoid func_67cb76bc1b504dbc(void)\n\n{\n  int iVar1;\n  undefined2 uStack_a8;\n  undefined2 uStack_a6;\n  undefined4 uStack_a4;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined4 uStack_38;\n  undefined *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  puStack_10 = &uStack_98;\n  if (globalTrue != 0) {\n    iStack_14 = 0xffffffff;\n    lStack_20 = func_6aa015c8ae2647e6(puStack_10);\n    iStack_14 = func_41c4eb1a76684a75(2,1,6);\n    if (iStack_14 != -1) {\n      func_84ef314bbaaf4ee5(&uStack_a8,0,0x10);\n      uStack_a8 = 2;\n      uStack_a4 = func_bd4689776abe4f49(&UNK_004015f4);\n      uStack_a6 = func_f8c6d0a3b0c34105(0x6987);\n      iVar1 = func_dcce6bd29b2c4a6e(iStack_14,&uStack_a8,0x10);\n      if (((iVar1 != -1) &&\n          (iStack_24 = func_2290062822934453(iStack_14,(long)puStack_10 + lStack_20,99 - lStack_20,0),\n          iStack_24 != -1)) && (iStack_24 != 0)) {\n        *(undefined *)((long)puStack_10 + iStack_24 + lStack_20) = 0;\n        puStack_30 = (undefined *)func_bee29e6af4934ec9(puStack_10,0xd);\n        if (puStack_30 != (undefined *)0x0) {\n          *puStack_30 = 0;\n        }\n        puStack_30 = (undefined *)func_bee29e6af4934ec9(puStack_10,10);\n        if (puStack_30 != (undefined *)0x0) {\n          *puStack_30 = 0;\n        }\n      }\n    }\n    if (iStack_14 != -1) {\n      func_2eff085d995140a5(iStack_14);\n    }\n  }\n  func_729e9f1bb610402c(&UNK_00401605,&UNK_00401605,&UNK_00401602,&UNK_004015fe,puStack_10,0);\n  return;\n}\n\n",
        "\nvoid func_25b660fcd9724d64(void)\n\n{\n  func_9d6b88d6a3bc4fe9();\n  return;\n}\n\n",
        "\nvoid func_ebd585a9d8644482(void)\n\n{\n  func_3f3e4c91a577472e();\n  func_f6a24369f4a442db();\n  return;\n}\n\n",
        "\nvoid func_d70b591533014218\n               (undefined8 *param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uStack_d8;\n  undefined8 uStack_d0;\n  undefined8 uStack_c8;\n  undefined8 uStack_c0;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  ulong uStack_18;\n  undefined8 uStack_10;\n  \n  uStack_10 = *param_1;\n  uStack_d8 = 0;\n  uStack_d0 = 0;\n  uStack_c8 = 0;\n  uStack_c0 = 0;\n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  uVar1 = func_2d604eb56b1c4be0(uStack_10);\n  func_40062b37892d4495(&uStack_d8,uStack_10,uVar1);\n  uStack_18 = uStack_18 & 0xffffffff;\n  func_941a07bac6754836(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_a13b8202f1274fde(undefined4 param_1)\n\n{\n  func_4400c0a4965642bd(param_1);\n  return;\n}\n\n",
        "\nvoid func_c076de59d0f34ddc(void)\n\n{\n  long lVar1;\n  undefined8 uStack_12;\n  undefined2 uStack_a;\n  \n  uStack_a = 0;\n  uStack_12 = 0;\n  lVar1 = func_c18bb88da3e84323(&uStack_12,8,stdin);\n  if (lVar1 == 0) {\n    func_744b3e68fae142e0(&UNK_00401374);\n  }\n  else {\n    uStack_a = func_cd6ec9e4d92b41ee(&uStack_12);\n  }\n  func_ae13c7ddb0dd46c8(&uStack_a);\n  return;\n}\n\n",
        "\nvoid func_0d926e3e00294e46(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  byte bVar4;\n  undefined8 uStack_368;\n  undefined8 uStack_360;\n  undefined8 auStack_358 [48];\n  undefined2 uStack_1d8;\n  undefined2 uStack_1d6;\n  undefined4 uStack_1d4;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [48];\n  undefined4 *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_c;\n  \n  bVar4 = 0;\n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_18 = &uStack_1c8;\n  iStack_1c = 0xffffffff;\n  iStack_c = -1;\n  lStack_28 = func_b174a70cd5d74189(puStack_18);\n  iStack_1c = func_7e05dcf9e74245a8(2,1,6);\n  if (iStack_1c != -1) {\n    func_9dda6356971e434a(&uStack_1d8,0,0x10);\n    uStack_1d8 = 2;\n    uStack_1d4 = 0;\n    uStack_1d6 = func_869bb2a501bb4600(0x6987);\n    iVar1 = func_abdb95f48b69495f(iStack_1c,&uStack_1d8,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_e8067b39f9cd4b4e(iStack_1c,5), iVar1 != -1)) &&\n        (iStack_c = func_3d7363ad85f246ba(iStack_1c,0,0), iStack_c != -1)) &&\n       ((iStack_2c = func_5ca0ba4a519c4e3f(iStack_c,lStack_28 * 4 + (long)puStack_18,(99 - lStack_28) * 4,\n                                     0), iStack_2c != -1 && (iStack_2c != 0)))) {\n      *(undefined4 *)((long)puStack_18 + (lStack_28 + ((ulong)(long)iStack_2c >> 2)) * 4) = 0;\n      puStack_38 = (undefined4 *)func_25bb5239ad354db2(puStack_18,0xd);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n      puStack_38 = (undefined4 *)func_25bb5239ad354db2(puStack_18,10);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n    }\n  }\n  if (iStack_1c != -1) {\n    func_142832f3de0f4243(iStack_1c);\n  }\n  if (iStack_c != -1) {\n    func_142832f3de0f4243(iStack_c);\n  }\n  uStack_368 = 0;\n  uStack_360 = 0;\n  puVar3 = auStack_358;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n  }\n  func_a30ae8bf69034582(&uStack_368,99,puStack_18);\n  func_aa7407405bde4819(&uStack_368);\n  return;\n}\n\n",
        "\nvoid func_240f9deffb6a49c4(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined4 uStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_14 = 0xffffffff;\n  iStack_c = 0xffffffff;\n  iStack_c = func_fbe74c41f78d4567(2,1,6);\n  if (iStack_c != -1) {\n    func_4849aa173f56453d(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_1c40594f91434773(&UNK_00401484);\n    uStack_26 = func_dc49f260fa3d4a41(0x6987);\n    iVar1 = func_ae9c7b0afed0461c(iStack_c,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_10 = func_b514c58cdf294bc3(iStack_c,auStack_36,0xd,0), iStack_10 != -1))\n       && (iStack_10 != 0)) {\n      auStack_36[iStack_10] = 0;\n      uStack_14 = func_22eed4da1e4e42cd(auStack_36);\n    }\n  }\n  if (iStack_c != -1) {\n    func_5c877975c58f47b3(iStack_c);\n  }\n  func_3927daa1031b4daf(&uStack_14);\n  return;\n}\n\n",
        "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nvoid func_a22567d5178b4a0c(void)\n\n{\n  undefined auStack_1c8 [396];\n  undefined4 uStack_3c;\n  long lStack_38;\n  long lStack_30;\n  long lStack_28;\n  long lStack_20;\n  long *plStack_18;\n  long *plStack_10;\n  \n  plStack_10 = &lStack_38;\n  plStack_18 = &lStack_38;\n  lStack_38 = 0;\n  lStack_20 = 0;\n  lStack_28 = func_d99127fc21394917(400);\n  func_51cbb1f1cc274374(lStack_28,0x41,99);\n  *(undefined4 *)(lStack_28 + 0x18c) = 0;\n  lStack_20 = lStack_28 + -0x20;\n  *plStack_10 = lStack_20;\n  lStack_30 = *plStack_18;\n  func_51cbb1f1cc274374(auStack_1c8,0x43,99);\n  uStack_3c = 0;\n  func_cdd2aa7b5a264ada(auStack_1c8,lStack_30,400);\n  uStack_3c = 0;\n  func_d63520f9407748bc(auStack_1c8);\n  return;\n}\n\n",
        "\nvoid func_f8f83e003b7f439f\n               (undefined8 *param_1)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 auStack_328 [100];\n  \n  puVar2 = auStack_328;\n  for (lVar1 = 100; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  func_e77989ce2d1645cf(param_1,auStack_328,800);\n  func_d6aebcf846f5409e(*param_1);\n  return;\n}\n\n",
        "\nvoid func_5cc200908315418e(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uStack_80;\n  ulong uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  int iStack_c;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  iStack_c = 0xffffffff;\n  uStack_80 = &UNK_00400e50;\n  lVar2 = func_49a3a5a6bd8244f1(&uStack_78,100,stdin);\n  if (lVar2 == 0) {\n    uStack_80 = &UNK_00400e5f;\n    func_91c4f69d15fb41eb(&UNK_00401484);\n    uStack_78 = uStack_78 & 0xffffffffffffff00;\n  }\n  if ((char)uStack_78 != '\\0') {\n    uStack_80 = &UNK_00400e7a;\n    lVar2 = func_23499abb9289447e(&uStack_78);\n    *(undefined *)((long)&uStack_80 + lVar2 + 7) = 0;\n  }\n  uStack_80 = &UNK_00400e94;\n  iVar1 = func_9755b7cfad1a4952(&uStack_78,2);\n  if (iVar1 == -1) {\n    uStack_80 = &UNK_00400ea3;\n    func_6c2b45b61fe847f0(1);\n  }\n  uStack_80 = &UNK_00400eb9;\n  iStack_c = func_4c18baf7924a4c29(&uStack_78,2);\n  if (iStack_c == -1) {\n    uStack_80 = &UNK_00400ecc;\n    func_6c2b45b61fe847f0(1);\n  }\n  uStack_80 = &UNK_00400ee0;\n  lVar2 = func_452dcedf8dbf4e75(iStack_c,&UNK_00401493,0xb);\n  if (lVar2 == -1) {\n    uStack_80 = &UNK_00400ef0;\n    func_6c2b45b61fe847f0(1);\n  }\n  if (iStack_c != -1) {\n    uStack_80 = &UNK_00400f00;\n    func_41a287be8670426b(iStack_c);\n  }\n  return;\n}\n\n",
        "\nvoid func_7a045909101349c8(void)\n\n{\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined2 uStack_18;\n  long lStack_10;\n  \n  lStack_10 = func_893dff67b925480d(100);\n  func_2eff7c5480994959(lStack_10,0x41,99);\n  *(undefined *)(lStack_10 + 99) = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_eb924cafae9f4dc0(&uStack_48,lStack_10);\n  func_6c7c2b41f70d44a0(lStack_10);\n  func_463854f20ef2410b(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_d5172a2456a145d1(void)\n\n{\n  int iVar1;\n  undefined2 uStack_a8;\n  undefined2 uStack_a6;\n  undefined4 uStack_a4;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined4 uStack_38;\n  undefined *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  puStack_10 = &uStack_98;\n  if (GLOBAL_CONST_FIVE == 5) {\n    iStack_14 = 0xffffffff;\n    lStack_20 = func_8d55f8d6f8e14083(puStack_10);\n    iStack_14 = func_819da346dfa44a67(2,1,6);\n    if (iStack_14 != -1) {\n      func_c5498eeba30247fb(&uStack_a8,0,0x10);\n      uStack_a8 = 2;\n      uStack_a4 = func_bc31eabae5fb415b(&UNK_00401734);\n      uStack_a6 = func_12926698548e481a(0x6987);\n      iVar1 = func_ffa6c9c36197440a(iStack_14,&uStack_a8,0x10);\n      if (((iVar1 != -1) &&\n          (iStack_24 = func_72d3fd1fd21842b0(iStack_14,(long)puStack_10 + lStack_20,99 - lStack_20,0),\n          iStack_24 != -1)) && (iStack_24 != 0)) {\n        *(undefined *)((long)puStack_10 + iStack_24 + lStack_20) = 0;\n        puStack_30 = (undefined *)func_3e143ce51c6b4b8e(puStack_10,0xd);\n        if (puStack_30 != (undefined *)0x0) {\n          *puStack_30 = 0;\n        }\n        puStack_30 = (undefined *)func_3e143ce51c6b4b8e(puStack_10,10);\n        if (puStack_30 != (undefined *)0x0) {\n          *puStack_30 = 0;\n        }\n      }\n    }\n    if (iStack_14 != -1) {\n      func_86918b784d224aa5(iStack_14);\n    }\n  }\n  if (GLOBAL_CONST_FIVE == 5) {\n    func_f1645144edf34f86(puStack_10,puStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_3ffd2210585c4680(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iVar1 = func_5619ec2dde20440b();\n  if (iVar1 == 0) {\n    iStack_c = 99;\n  }\n  else {\n    iStack_14 = 0xffffffff;\n    iStack_10 = -1;\n    iStack_14 = func_c2a2231ecc2847fb(2,1,6);\n    if (iStack_14 != -1) {\n      func_fd2187165e0a4839(&uStack_28,0,0x10);\n      uStack_28 = 2;\n      uStack_24 = 0;\n      uStack_26 = func_af6253a62bdb44b3(0x6987);\n      iVar1 = func_3a33b53179c341b8(iStack_14,&uStack_28,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_151775b0214049f0(iStack_14,5), iVar1 != -1)) &&\n          (iStack_10 = func_5cb8619eb2c443b2(iStack_14,0,0), iStack_10 != -1)) &&\n         ((iStack_18 = func_96cadeaded324c4c(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n          (iStack_18 != 0)))) {\n        auStack_36[iStack_18] = 0;\n        iStack_c = func_c060387b5f404859(auStack_36);\n      }\n    }\n    if (iStack_14 != -1) {\n      func_d9873b1b6c1a426e(iStack_14);\n    }\n    if (iStack_10 != -1) {\n      func_d9873b1b6c1a426e(iStack_10);\n    }\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_fd2187165e0a4839(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_f5ae676bbf064d9e(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_a92d9c23d6fd4307(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_4d9393f4d4994b8f(void)\n\n{\n  func_178349ce9cd9486b();\n  return;\n}\n\n",
        "\nvoid func_e17547ca5d7b4e08(void)\n\n{\n  undefined *puVar1;\n  long lVar2;\n  long lVar3;\n  \n  puVar1 = (undefined *)func_8229bb2189b64230(100);\n  *puVar1 = 0;\n  lVar2 = func_59b4ff2073a44f3e(puVar1);\n  lVar3 = func_1f9afc7465004e44(&UNK_00401355);\n  if (lVar3 != 0) {\n    func_da96d53965ee46c0(puVar1 + lVar2,lVar3,99 - lVar2);\n  }\n  badStatic = 1;\n  func_c588bc01410b431e(puVar1);\n  return;\n}\n\n",
        "\nvoid func_13506684b3254ba7(undefined4 param_1)\n\n{\n  func_ecfa5e2e78404d6e(param_1);\n  return;\n}\n\n",
        "\nvoid func_c6640775f51c4dfa(void)\n\n{\n  func_d0a3e457309b44fa();\n  return;\n}\n\n",
        "\nvoid func_5888ef1da97d460b(void)\n\n{\n  long lVar1;\n  undefined8 uStack_1a;\n  undefined4 uStack_12;\n  undefined2 uStack_e;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  uStack_1a = 0;\n  uStack_12 = 0;\n  uStack_e = 0;\n  lVar1 = func_6d584648181b4e26(&uStack_1a,0xe,stdin);\n  if (lVar1 == 0) {\n    func_2d9a310fe0b14da0(&UNK_00401384);\n  }\n  else {\n    uStack_c = func_f39f3e26fd974088(&uStack_1a);\n  }\n  func_8055d38cf5de4f02(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_65ce46953d264259(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = func_bfd3cf87ba48474c(param_1);\n  uVar2 = func_6435a1e3e3294683(lVar1 + 1,1);\n  func_ee973cb0a39345bd(uVar2,param_1,lVar1 + 1);\n  func_8ce31fbdaf3947e0(uVar2);\n  func_e03a761bf96b4ff3(uVar2);\n  return;\n}\n\n",
        "\nvoid func_ce238290bb8e410b\n               (undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_128;\n  undefined8 uStack_120;\n  undefined8 auStack_118 [31];\n  undefined8 *puStack_20;\n  long lStack_18;\n  long lStack_10;\n  \n  uStack_128 = 0x3d48544150;\n  uStack_120 = 0;\n  puVar2 = auStack_118;\n  for (lVar1 = 0x1d; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  *(undefined2 *)puVar2 = 0;\n  puStack_20 = &uStack_128;\n  lStack_10 = func_4e985239c4004dd0(puStack_20,param_2,(undefined2 *)((long)puVar2 + 2));\n  lStack_18 = func_4ebbebdb715b430f(&UNK_004012c4);\n  if (lStack_18 != 0) {\n    func_3c7ce7e213714715((long)puStack_20 + lStack_10,lStack_18,0xf9 - lStack_10);\n  }\n  func_c8316c9d61a04d63(&puStack_20);\n  return;\n}\n\n",
        "\nvoid func_b64b542e7b574465(void)\n\n{\n  int iVar1;\n  undefined auStack_340 [408];\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_18 = auStack_340;\n  func_ed19e8cbc82244dd(puStack_18,0x41,99);\n  *(undefined4 *)(puStack_18 + 0x18c) = 0;\n  iVar1 = func_c108a161df294efa();\n  if (iVar1 == 0) {\n    puStack_10 = puStack_18;\n  }\n  else {\n    puStack_10 = puStack_18 + -0x20;\n  }\n  func_ed19e8cbc82244dd(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_4928872b08fc4d8e(puStack_10,auStack_1a8,99);\n  *(undefined4 *)(puStack_10 + 0x18c) = 0;\n  func_c0741c1ce2574939(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_794c62abcb7f4e12(void)\n\n{\n  undefined auStack_1a8 [408];\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_1a8;\n  func_a33170ff2ef24331(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_4a12603630cd41a1(void)\n\n{\n  func_96a402c7f1ed413f();\n  return;\n}\n\n",
        "\nvoid func_326f1028c8584d2f(undefined8 param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = func_da40c4e90c464e5c(param_1);\n  if (iVar1 < 1) {\n    func_b983d4ac0ee64065(&UNK_004013b4);\n    func_f29e0d17df154275(1);\n  }\n  return;\n}\n\n",
        "\nvoid func_360752eb1fed43ba(void)\n\n{\n  func_c3e39177d68444fe();\n  func_505492825fb44698();\n  func_c11d63a288fd4f1e();\n  func_1dd7e19b171a481d();\n  return;\n}\n\n",
        "\nvoid func_cfe1ee5de06b4dec(void)\n\n{\n  int iVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  \n  iVar1 = func_b5cf9911cfed43af();\n  uVar2 = func_cef3ab40dd86429d(&UNK_0040126c);\n  if (uVar2 < (ulong)(long)iVar1) {\n    uVar3 = func_af4c14670ba44f29((long)iVar1 << 2);\n    func_d6b827206faa43b0(uVar3,&UNK_0040126c);\n    func_bf07bf2fe6d148a9(uVar3);\n    func_1cf8d4d6c93842b3(uVar3);\n  }\n  else {\n    func_672e3ebf153c43c4(&UNK_00401288);\n  }\n  return;\n}\n\n",
        "\nvoid func_abaf7ec1595b4e05(void)\n\n{\n  func_6e1d767f77084a07();\n  func_0e3254d8c8244974();\n  return;\n}\n\n",
        "\nvoid func_e2e7a0e5aa494d39(undefined8 param_1)\n\n{\n  func_8068afd5d81f4143(param_1);\n  return;\n}\n\n",
        "\nundefined2 func_6903e886d01f4cc3(undefined2 param_1)\n\n{\n  int iVar1;\n  undefined2 uStack_3c;\n  undefined auStack_30 [8];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_3c = param_1;\n  if (CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_badGlobal != 0) {\n    iStack_10 = 0xffffffff;\n    iStack_c = -1;\n    iStack_10 = func_9e82e8e1d547477e(2,1,6);\n    if (iStack_10 != -1) {\n      func_b6c92f08280d489b(&uStack_28,0,0x10);\n      uStack_28 = 2;\n      uStack_24 = 0;\n      uStack_26 = func_31fe0574cf704eb1(0x6987);\n      iVar1 = func_20504f5768a640f2(iStack_10,&uStack_28,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_838207b5e0584099(iStack_10,5), iVar1 != -1)) &&\n          (iStack_c = func_7f3543662cba4ce8(iStack_10,0,0), iStack_c != -1)) &&\n         ((iStack_14 = func_24c7d33d514a4e57(iStack_c,auStack_30,7,0), iStack_14 != -1 && (iStack_14 != 0)\n          ))) {\n        auStack_30[iStack_14] = 0;\n        iStack_18 = func_6666ed2e0c63472b(auStack_30);\n        if ((iStack_18 < 0x8000) && (-0x8001 < iStack_18)) {\n          uStack_3c = (undefined2)iStack_18;\n        }\n        else {\n          uStack_3c = 0xffff;\n        }\n      }\n    }\n    if (iStack_10 != -1) {\n      func_83e2d8b6f13a40d7(iStack_10);\n    }\n    if (iStack_c != -1) {\n      func_83e2d8b6f13a40d7(iStack_c);\n    }\n  }\n  return uStack_3c;\n}\n\n",
        "\nvoid func_07873fcf158649cd(void)\n\n{\n  undefined *puStack_80;\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  undefined **ppuStack_10;\n  \n  puStack_80 = &UNK_00400c40;\n  func_152e814e81e14720(auStack_78,0x41,99);\n  uStack_15 = 0;\n  ppuStack_10 = &puStack_80;\n  puStack_80 = &UNK_00400c5c;\n  func_cd3ffc33fa5041c5(ppuStack_10);\n  return;\n}\n\n",
        "\nvoid func_ad1f9e6b895a4e1b(void)\n\n{\n  undefined auStack_128 [99];\n  undefined uStack_c5;\n  undefined auStack_48 [56];\n  undefined *puStack_10;\n  \n  if (staticFive == 5) {\n    puStack_10 = auStack_48;\n    auStack_48[0] = 0;\n  }\n  func_ca007671b3b04050(auStack_128,0x43,99);\n  uStack_c5 = 0;\n  func_961e78ea00cb484f(puStack_10,auStack_128,100);\n  puStack_10[99] = 0;\n  func_23749b1e4e0f44e0(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_f54fa77f205e4524(void)\n\n{\n  undefined auStack_338 [368];\n  undefined auStack_1c8 [28];\n  undefined4 uStack_1ac;\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined *puStack_10;\n  \n  func_f01bda3db0a04f0f(auStack_1a8,0x41,99);\n  uStack_1c = 0;\n  if (GLOBAL_CONST_FIVE == 5) {\n    puStack_10 = auStack_1c8;\n  }\n  func_f01bda3db0a04f0f(auStack_338,0x43,99);\n  uStack_1ac = 0;\n  func_7638574ee2cb421d(auStack_338,puStack_10,400);\n  uStack_1ac = 0;\n  func_6887c197161d435e(auStack_338);\n  return;\n}\n\n",
        "\nvoid func_8162c28a7cbe47ca(void)\n\n{\n  func_e5b42a0d88ee4f79();\n  return;\n}\n\n",
        "\nvoid func_2939adfe4148419c(void)\n\n{\n  func_6537ff5479784805();\n  return;\n}\n\n",
        "\nvoid func_df2870440f6d4f64(void)\n\n{\n  int iVar1;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  undefined4 uStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_54977f7355f74b1b(2,1,6);\n  if (iStack_14 != -1) {\n    func_a1821149a86d4b01(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_8a0e39bd9f534f0a(0x6987);\n    iVar1 = func_a0a301109fcc40f9(iStack_14,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_f36b4337f1904e3b(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_778017c0c417479d(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_68f23ba8f97241b0(iStack_10,auStack_46,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_46[iStack_18] = 0;\n      uStack_c = func_be7be8d6eaeb4d84(auStack_46);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_997dd1c6ce46400c(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_997dd1c6ce46400c(iStack_10);\n  }\n  uStack_1c = uStack_c;\n  func_f2c1e303b8224eb3(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_aafeb674a00a440b(undefined8 *param_1)\n\n{\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined8 uStack_10;\n  \n  uStack_10 = *param_1;\n  func_709402ede5894e53(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_a122ff1dcd004d58(uStack_10,auStack_1a8);\n  func_2a6b7cd17ed34367(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_bae03deca8d444c8(int *param_1)\n\n{\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  int iStack_1c;\n  int *piStack_18;\n  int iStack_c;\n  \n  piStack_18 = param_1;\n  iStack_1c = *param_1;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  if ((iStack_1c < 0) || (9 < iStack_1c)) {\n    func_4433ea34df084aff(&UNK_00401378);\n  }\n  else {\n    *(undefined4 *)((long)&uStack_48 + (long)iStack_1c * 4) = 1;\n    for (iStack_c = 0; iStack_c < 10; iStack_c = iStack_c + 1) {\n      func_ebdf2d8367d94494(*(undefined4 *)((long)&uStack_48 + (long)iStack_c * 4));\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_7699b7b85100442e(long param_1)\n\n{\n  func_f1f288db25e542ab(100 % (long)*(int *)(param_1 + 8) & 0xffffffff);\n  return;\n}\n\n",
        "\nvoid func_422b3c7151cc4d77(void)\n\n{\n  undefined auStack_290 [416];\n  undefined4 auStack_f0 [50];\n  undefined4 *puStack_28;\n  undefined4 *puStack_20;\n  undefined *puStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_28 = auStack_f0;\n  puStack_18 = auStack_290;\n  auStack_f0[0] = 0;\n  puStack_20 = puStack_28;\n  puStack_10 = puStack_28;\n  func_b88dd1ab99ef4be1(puStack_28,0x10,7);\n  return;\n}\n\n",
        "\nvoid func_f879a500da594379(void)\n\n{\n  undefined auStack_1c8 [24];\n  undefined *puStack_1b0;\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined *puStack_10;\n  \n  puStack_1b0 = &UNK_00400cbd;\n  func_0a20aca07b2f4a13(auStack_1a8,0x41,99);\n  uStack_1c = 0;\n  func_f879a500da594379Data = auStack_1c8;\n  puStack_1b0 = &UNK_00400ce8;\n  puStack_10 = func_f879a500da594379Data;\n  func_fd90c5f3531541e3();\n  return;\n}\n\n",
        "\nvoid func_340ef72817644016(void)\n\n{\n  long lVar1;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  lVar1 = func_1fecd41023e14c1b(0x50);\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    for (iStack_14 = 0; iStack_14 < 5; iStack_14 = iStack_14 + 1) {\n      *(double *)(lVar1 + (long)iStack_14 * 8) = (double)iStack_14;\n    }\n  }\n  for (iStack_10 = 0; iStack_10 < 1; iStack_10 = iStack_10 + 1) {\n    for (iStack_18 = 0; iStack_18 < 10; iStack_18 = iStack_18 + 1) {\n      func_592a586b8d454fa3(*(undefined8 *)(lVar1 + (long)iStack_18 * 8));\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_295d2701964f45c9(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = func_acb137a7a37b4985(0x28);\n  func_a87cc4cb3d7841a8(uVar1);\n  return;\n}\n\n",
        "\nvoid func_1e8013c924204ac3(void)\n\n{\n  func_fca0673208774e5f();\n  func_21e0927e648b48e3();\n  return;\n}\n\n",
        "\nvoid func_7d5e4768d6d14ebf(void)\n\n{\n  func_32f7721ad0e4407d();\n  func_ba240d229f764c0d();\n  return;\n}\n\n",
        "\nvoid func_54fbe3b39cba46e6(void)\n\n{\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  long lStack_10;\n  \n  lStack_10 = 0;\n  lStack_10 = func_46e365a0c4c24418(0);\n  func_db6925cdc10a4132(auStack_78,0x43,99);\n  uStack_15 = 0;\n  func_a76a4764f9374df3(lStack_10,auStack_78,100);\n  *(undefined *)(lStack_10 + 99) = 0;\n  func_6f422a54b1fb4142(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_8622cd663ea44b06(short param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  sStack_a = param_1;\n  func_0e7a858673174752(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_364b0836abca4370(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_bff5b54143384c90(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_21d3a696641041ce(void)\n\n{\n  undefined auStack_420 [416];\n  undefined4 auStack_280 [50];\n  undefined auStack_1b8 [396];\n  undefined4 uStack_2c;\n  undefined *puStack_20;\n  undefined4 *puStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_18 = auStack_280;\n  puStack_20 = auStack_420;\n  auStack_280[0] = 0;\n  puStack_10 = puStack_18;\n  func_03e2a72653534c20(auStack_1b8,0x43,99);\n  uStack_2c = 0;\n  func_794b6c35370a47c7(puStack_10,auStack_1b8,100);\n  func_984d350de4644942(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_e4c08d2c76ba4919(void)\n\n{\n  func_945edeb901354540();\n  func_5d3306c1e71149d4();\n  return;\n}\n\n",
        "\nvoid func_770daf3a53294a0f(int param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  ulong uStack_10;\n  \n  lVar1 = func_91312a482624423d(&UNK_00401618,&UNK_00401627);\n  if (lVar1 == 0) {\n    func_520c1dc122004c2c(1);\n  }\n  for (uStack_10 = 0; uStack_10 < (ulong)(long)param_1; uStack_10 = uStack_10 + 1) {\n    lVar2 = func_feb56ee6b3ba40c6(&UNK_00401630,1,0x32,lVar1);\n    if (lVar2 != 0x32) {\n      func_520c1dc122004c2c(1);\n    }\n  }\n  if (lVar1 != 0) {\n    func_43f2a7502a2c4472(lVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_135781289c0f4c56(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined auVar3 [16];\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined auStack_118 [264];\n  double dStack_10;\n  undefined auVar6 [12];\n  undefined8 extraout_XMM0_Qb;\n  undefined8 extraout_XMM0_Qb_00;\n  \n  iVar1 = func_1f4bad347d98414d();\n  if (iVar1 != 0) {\n    dStack_10 = 0.0;\n    lVar2 = func_aeeac7490931490f(auStack_118,0x100,stdin);\n    if (lVar2 == 0) {\n      auVar4._0_8_ = func_4eec9d7a209242c2(&UNK_00401214);\n      auVar4._8_8_ = extraout_XMM0_Qb_00;\n      auVar6 = auVar4._4_12_;\n    }\n    else {\n      auVar3._0_8_ = (double)func_918768f1d9a14615(auStack_118);\n      auVar3._8_8_ = extraout_XMM0_Qb;\n      auVar6 = auVar3._4_12_;\n      dStack_10 = auVar3._0_8_;\n    }\n    auVar5._0_4_ = (float)dStack_10;\n    auVar5._4_12_ = auVar6;\n    func_cfbebfba08e9493e(auVar5._0_8_);\n  }\n  return;\n}\n\n",
        "\nvoid func_d1dddcd8fde94519\n               (undefined8 *param_1)\n\n{\n  long lVar1;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined4 uStack_20;\n  undefined8 uStack_10;\n  \n  uStack_10 = *param_1;\n  uStack_48 = 0x4100000041;\n  uStack_40 = 0x4100000041;\n  uStack_38 = 0x4100000041;\n  uStack_30 = 0x4100000041;\n  uStack_28 = 0x4100000041;\n  uStack_20 = 0;\n  lVar1 = func_24d09987178d4593(&uStack_48);\n  func_a9cd40a76baf4bda(uStack_10,&uStack_48,(lVar1 + 1) * 4);\n  func_c1d26898607b4825(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_9eca718bdde84326(void)\n\n{\n  func_bb9f9aa678564555();\n  return;\n}\n\n",
        "\nvoid func_830f5e9845604bd5(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined4 uStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_14 = 0xffffffff;\n  iStack_c = 0xffffffff;\n  iStack_c = func_9bd5e69354234de5(2,1,6);\n  if (iStack_c != -1) {\n    func_da61816f477740ea(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_94a9eadc3d9e4aea(&UNK_00401624);\n    uStack_26 = func_2541ceafe8aa4500(0x6987);\n    iVar1 = func_7df3dcda6fc244aa(iStack_c,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_10 = func_a404b3f9062149ce(iStack_c,auStack_36,0xd,0), iStack_10 != -1))\n       && (iStack_10 != 0)) {\n      auStack_36[iStack_10] = 0;\n      uStack_14 = func_10ced655d600459c(auStack_36);\n    }\n  }\n  if (iStack_c != -1) {\n    func_a39b1a88d18047b2(iStack_c);\n  }\n  func_dd63f894ad0d47e4(&uStack_14);\n  return;\n}\n\n",
        "\nvoid func_18a922c587424855(undefined8 param_1)\n\n{\n  func_e936e76d33614f2e(&UNK_0040134b,&UNK_0040134b,&UNK_00401348,&UNK_00401344,param_1,0);\n  return;\n}\n\n",
        "\nvoid func_b71d3260615f4dd6(void)\n\n{\n  func_ed8d34c19d45457b();\n  func_6e3a8fefc5174359();\n  return;\n}\n\n",
        "\nvoid func_3119c9c4a72f472e(int param_1)\n\n{\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined8 uStack_18;\n  \n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  if (param_1 < 0) {\n    func_ce72999c97114e5b(&UNK_00401358);\n  }\n  else {\n    func_39d536a8b1674a45(*(undefined4 *)((long)&uStack_38 + (long)param_1 * 4));\n  }\n  return;\n}\n\n",
        "\nvoid func_0b5e678c2c1d4eda(void)\n\n{\n  int iVar1;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  undefined4 uStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_3d924038fb9e4e31(2,1,6);\n  if (iStack_14 != -1) {\n    func_4983ef028294458a(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_943eb5c0c8ae46bf(0x6987);\n    iVar1 = func_a31a8a62a1f94fa2(iStack_14,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_7360d1f523e44be4(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_4e6162ae764a4482(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_e378e20e98d649b1(iStack_10,auStack_46,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_46[iStack_18] = 0;\n      uStack_c = func_b5034e00c3e7460c(auStack_46);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_50f0e88477b54897(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_50f0e88477b54897(iStack_10);\n  }\n  uStack_1c = uStack_c;\n  func_cd66946dc0b54ae5(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_5e64e162ca24412d(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_1b8;\n  undefined8 uStack_1b0;\n  undefined8 auStack_1a8 [48];\n  long lStack_28;\n  long lStack_20;\n  undefined8 *puStack_18;\n  code *pcStack_10;\n  \n  pcStack_10 = CWE134_Uncontrolled_Format_String__wchar_t_file_vfprintf_65b_badVaSink;\n  uStack_1b8 = 0;\n  uStack_1b0 = 0;\n  puVar2 = auStack_1a8;\n  for (lVar1 = 0x30; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  puStack_18 = &uStack_1b8;\n  lStack_20 = func_0c6a58e6d4474e10(puStack_18);\n  if (1 < 100U - lStack_20) {\n    lStack_28 = func_b0f52600e7584bb3(&UNK_00401456,&UNK_00401454);\n    if (lStack_28 != 0) {\n      lVar1 = func_7916dd2e081a47d5(lStack_20 * 4 + (long)puStack_18,100 - (int)lStack_20,lStack_28);\n      if (lVar1 == 0) {\n        func_8b0d55dcc9214678(&UNK_00401464);\n        *(undefined4 *)((long)puStack_18 + lStack_20 * 4) = 0;\n      }\n      func_8eaf1d067bfc41dc(lStack_28);\n    }\n  }\n  (*pcStack_10)(puStack_18,puStack_18);\n  return;\n}\n\n",
        "\nvoid func_9d5dcb4dd3844a16(void)\n\n{\n  ulong uStack_20;\n  undefined1 *puStack_18;\n  int iStack_c;\n  \n  puStack_18 = (undefined1 *)0x0;\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    for (uStack_20 = 0; uStack_20 < 100; uStack_20 = uStack_20 + 1) {\n      *(undefined8 *)(dataBuffer_3778 + uStack_20 * 8) = 5;\n    }\n    puStack_18 = dataBuffer_3778;\n  }\n  func_121b5e90582949ed(*(undefined8 *)puStack_18);\n  func_248784dbbf0c45b4(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_b1fd7fcc35ee4379(long *param_1)\n\n{\n  undefined8 uStack_e8;\n  undefined8 uStack_e0;\n  undefined8 uStack_d8;\n  undefined8 uStack_d0;\n  undefined8 uStack_c8;\n  undefined8 uStack_c0;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  ulong uStack_28;\n  ulong uStack_20;\n  long lStack_18;\n  ulong uStack_10;\n  \n  lStack_18 = *param_1;\n  uStack_e8 = 0;\n  uStack_e0 = 0;\n  uStack_d8 = 0;\n  uStack_d0 = 0;\n  uStack_c8 = 0;\n  uStack_c0 = 0;\n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = func_0275923d53754c07(lStack_18);\n  for (uStack_10 = 0; uStack_10 < uStack_20; uStack_10 = uStack_10 + 1) {\n    *(undefined4 *)((long)&uStack_e8 + uStack_10 * 4) = *(undefined4 *)(lStack_18 + uStack_10 * 4);\n  }\n  uStack_28 = uStack_28 & 0xffffffff;\n  func_8130defd34df4bf4(lStack_18);\n  return;\n}\n\n",
        "\nvoid func_cca2deda1cf34096(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_1a8;\n  undefined8 uStack_1a0;\n  undefined8 auStack_198 [49];\n  undefined8 *puStack_10;\n  \n  if (GLOBAL_CONST_TRUE != 0) {\n    uStack_1a8 = 0;\n    uStack_1a0 = 0;\n    puVar2 = auStack_198;\n    for (lVar1 = 0x30; lVar1 != 0; lVar1 = lVar1 + -1) {\n      *puVar2 = 0;\n      puVar2 = puVar2 + 1;\n    }\n    puStack_10 = &uStack_1a8;\n    func_6d1d5fffcc3a44e1(puStack_10,&UNK_004011f8);\n    func_6c2fd7240e834757(puStack_10 + 3,puStack_10 + 2,0x28);\n    func_58d3ae82bf4545ce(puStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_7cc6ab8989804863(undefined8 param_1)\n\n{\n  func_601acfa832c2474c(param_1);\n  return;\n}\n\n",
        "\nvoid func_845ed4dbc83f483b(void)\n\n{\n  int iVar1;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = 0;\n  if (globalFive == 5) {\n    iStack_14 = 0xffffffff;\n    iStack_10 = -1;\n    iStack_14 = func_2cd0c5c7aa19492b(2,1,6);\n    if (iStack_14 != -1) {\n      func_a31a57d81a5f4251(&uStack_38,0,0x10);\n      uStack_38 = 2;\n      uStack_34 = 0;\n      uStack_36 = func_65702f9072e64d5b(0x6987);\n      iVar1 = func_6b7005f4e0344973(iStack_14,&uStack_38,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_66c311bbab74468e(iStack_14,5), iVar1 != -1)) &&\n          (iStack_10 = func_0e6d52824c8b401c(iStack_14,0,0), iStack_10 != -1)) &&\n         ((iStack_18 = func_33a7e1081ee046ed(iStack_10,auStack_46,0xd,0), iStack_18 != -1 &&\n          (iStack_18 != 0)))) {\n        auStack_46[iStack_18] = 0;\n        iStack_c = func_eb6cc2ad9b6043f2(auStack_46);\n      }\n    }\n    if (iStack_14 != -1) {\n      func_1b071e8531b548d8(iStack_14);\n    }\n    if (iStack_10 != -1) {\n      func_1b071e8531b548d8(iStack_10);\n    }\n  }\n  if ((globalFive == 5) && (0 < iStack_c)) {\n    iStack_1c = iStack_c * 2;\n    func_4ce75e714fd349da(iStack_1c);\n  }\n  return;\n}\n\n",
        "\nvoid func_515406989d15480b(undefined8 param_1)\n\n{\n  func_5133e6a5d89c454d(param_1);\n  return;\n}\n\n",
        "\nvoid func_30284e9aa98b4fad(void)\n\n{\n  int iVar1;\n  undefined auStack_88 [99];\n  undefined uStack_25;\n  long lStack_20;\n  long lStack_18;\n  long lStack_10;\n  \n  lStack_10 = 0;\n  iVar1 = func_af88521ed9c94c24();\n  if (iVar1 == 0) {\n    lStack_18 = func_fce7fe4f6f05436f(100);\n    func_33cc2a658d974bb6(lStack_18,0x41,99);\n    *(undefined *)(lStack_18 + 99) = 0;\n    lStack_10 = lStack_18;\n  }\n  else {\n    lStack_20 = func_fce7fe4f6f05436f(100);\n    func_33cc2a658d974bb6(lStack_20,0x41,99);\n    *(undefined *)(lStack_20 + 99) = 0;\n    lStack_10 = lStack_20 + -8;\n  }\n  func_33cc2a658d974bb6(auStack_88,0x43,99);\n  uStack_25 = 0;\n  func_9e0381286acc4bcd(lStack_10,auStack_88,100);\n  *(undefined *)(lStack_10 + 99) = 0;\n  func_3cd11caebeab45eb(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_c8bf458f4d4b447a(undefined8 *param_1)\n\n{\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  uint uStack_28;\n  \n  func_296a2675e3364963(&uStack_88,0x43,99);\n  uStack_28 = uStack_28 & 0xffffff;\n  *param_1 = uStack_88;\n  param_1[1] = uStack_80;\n  param_1[2] = uStack_78;\n  param_1[3] = uStack_70;\n  param_1[4] = uStack_68;\n  param_1[5] = uStack_60;\n  param_1[6] = uStack_58;\n  param_1[7] = uStack_50;\n  param_1[8] = uStack_48;\n  param_1[9] = uStack_40;\n  param_1[10] = uStack_38;\n  param_1[0xb] = uStack_30;\n  *(uint *)(param_1 + 0xc) = uStack_28;\n  *(undefined *)((long)param_1 + 99) = 0;\n  func_d53fbf40c78a4ff2(param_1);\n  return;\n}\n\n",
        "\nvoid func_0a4125a87770471a\n               (undefined8 *param_1)\n\n{\n  undefined4 auStack_348 [202];\n  undefined8 uStack_20;\n  undefined8 *puStack_18;\n  ulong uStack_10;\n  \n  uStack_20 = *param_1;\n  for (uStack_10 = 0; uStack_10 < 100; uStack_10 = uStack_10 + 1) {\n    auStack_348[uStack_10 * 2] = 0;\n    auStack_348[uStack_10 * 2] = 0;\n  }\n  puStack_18 = param_1;\n  func_0b634f2e63c548ed(uStack_20,auStack_348,800);\n  func_a470cbc8cbde4cfd(uStack_20);\n  return;\n}\n\n",
        "\nvoid func_fb1e7b9a4c034760(int *param_1)\n\n{\n  if (*param_1 < 6) {\n    func_58cdd33d4b134e57(&UNK_00401380,&UNK_004012a0,0x22,__PRETTY_FUNCTION___3505);\n  }\n  return;\n}\n\n",
        "\nvoid func_d1ad8d25d6334818\n               (undefined8 param_1)\n\n{\n  func_a52a5ef211e44c98(param_1);\n  return;\n}\n\n",
        "\nvoid func_f90940f246494252\n               (undefined8 param_1)\n\n{\n  func_476df7d14ec84526(param_1);\n  return;\n}\n\n",
        "\nvoid func_41b62a746ee4472a(void)\n\n{\n  long lVar1;\n  long lVar2;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_697813908ba34af6(100);\n  *pcStack_10 = '\\0';\n  lVar1 = func_96398b5769ed4549(pcStack_10);\n  lVar2 = func_bdfdaabd8c274937(&UNK_00401314);\n  if (lVar2 != 0) {\n    func_404f0b640d9e49f4(pcStack_10 + lVar1,lVar2,99 - lVar1);\n  }\n  do {\n    if (*pcStack_10 == '\\0') {\ncode_r0x00400d83:\n      func_613a00234f3f40c6(pcStack_10);\n      return;\n    }\n    if (*pcStack_10 == 'S') {\n      func_147fedd2b4cb4061(&UNK_00401318);\n      goto code_r0x00400d83;\n    }\n    pcStack_10 = pcStack_10 + 1;\n  } while( true );\n}\n\n",
        "\nvoid func_e90db04b6d42402c(void)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = 0;\n  func_63cdee8806c647bc(stdin,&UNK_004012d4,&sStack_a);\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_c59a9bfcfe43408a(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_4f385d93cd184274(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_c0b355ef31cd4536(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_14447047557e4322(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  if (globalFive == 5) {\n    iStack_14 = 0xffffffff;\n    iStack_10 = -1;\n    iStack_14 = func_a71dbe6c1d1a44d8(2,1,6);\n    if (iStack_14 != -1) {\n      func_b04a4e927a2f408f(&uStack_28,0,0x10);\n      uStack_28 = 2;\n      uStack_24 = 0;\n      uStack_26 = func_40e62d6609084d30(0x6987);\n      iVar1 = func_25c7156aa6dc4f04(iStack_14,&uStack_28,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_e09c54908bee4102(iStack_14,5), iVar1 != -1)) &&\n          (iStack_10 = func_fc8fd36833cb485c(iStack_14,0,0), iStack_10 != -1)) &&\n         ((iStack_18 = func_f237c09be7904ef2(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n          (iStack_18 != 0)))) {\n        auStack_36[iStack_18] = 0;\n        iStack_c = func_be86f904cd034eac(auStack_36);\n      }\n    }\n    if (iStack_14 != -1) {\n      func_dd8c9c4dd3604474(iStack_14);\n    }\n    if (iStack_10 != -1) {\n      func_dd8c9c4dd3604474(iStack_10);\n    }\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_b04a4e927a2f408f(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_f5f78d62561f4d64(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_4840ac2142cb435c(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_59d3e549b33f43d6(long *param_1)\n\n{\n  undefined auStack_88 [99];\n  undefined uStack_25;\n  long lStack_18;\n  long *plStack_10;\n  \n  lStack_18 = *param_1;\n  plStack_10 = param_1;\n  func_a6461924cba246e7(auStack_88,0x43,99);\n  uStack_25 = 0;\n  func_763fac36fae1415e(lStack_18,auStack_88,99);\n  *(undefined *)(lStack_18 + 99) = 0;\n  func_d671ce68c61b44ef(lStack_18);\n  return;\n}\n\n",
        "\nvoid func_293debb0522440f9(void)\n\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  int iStack_c;\n  \n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    puVar2 = (undefined4 *)func_7d28cf7bb2564e12(4);\n    uVar1 = *puVar2;\n    func_a1ab134034f84dab(puVar2);\n    func_e9c384d058f04c2c(uVar1);\n  }\n  return;\n}\n\n",
        "\nlong func_6c21c0f496f24562(long param_1)\n\n{\n  int iVar1;\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  undefined4 *puStack_28;\n  int iStack_1c;\n  long lStack_18;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_10 = 0xffffffff;\n  iStack_c = -1;\n  lStack_18 = func_085afb670f954953(param_1);\n  iStack_10 = func_e18a65fe33c04a59(2,1,6);\n  if (iStack_10 != -1) {\n    func_367f4a44e71d4713(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_76a11611e11b4e57(0x6987);\n    iVar1 = func_3f940a311d72460f(iStack_10,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_f527297c71044431(iStack_10,5), iVar1 != -1)) &&\n        (iStack_c = func_cf740716834f44c3(iStack_10,0,0), iStack_c != -1)) &&\n       ((iStack_1c = func_465d2d0c23814ffe(iStack_c,lStack_18 * 4 + param_1,(99 - lStack_18) * 4,0),\n        iStack_1c != -1 && (iStack_1c != 0)))) {\n      *(undefined4 *)(param_1 + (lStack_18 + ((ulong)(long)iStack_1c >> 2)) * 4) = 0;\n      puStack_28 = (undefined4 *)func_d6f1fc0c2618477f(param_1,0xd);\n      if (puStack_28 != (undefined4 *)0x0) {\n        *puStack_28 = 0;\n      }\n      puStack_28 = (undefined4 *)func_d6f1fc0c2618477f(param_1,10);\n      if (puStack_28 != (undefined4 *)0x0) {\n        *puStack_28 = 0;\n      }\n    }\n  }\n  if (iStack_10 != -1) {\n    func_af4a706d90494e02(iStack_10);\n  }\n  if (iStack_c != -1) {\n    func_af4a706d90494e02(iStack_c);\n  }\n  return param_1;\n}\n\n",
        "\nvoid func_2313fc34d5774cdd(undefined8 param_1)\n\n{\n  func_9c37c3e3aff74d8a(param_1);\n  return;\n}\n\n",
        "\nvoid func_889d46d556c94d06(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uStack_13;\n  undefined2 uStack_b;\n  undefined uStack_9;\n  \n  uStack_13 = 0x4141414141414141;\n  uStack_b = 0x4141;\n  uStack_9 = 0;\n  lVar1 = func_f57eaf1aa9b3440a(&uStack_13);\n  func_670242e882fc4c3d(param_1,&uStack_13,lVar1 + 1);\n  func_1a3c424f992744e8(param_1);\n  func_435baf384b544e39(param_1);\n  return;\n}\n\n",
        "\nvoid func_699dad1fd8544dcf(void)\n\n{\n  int iVar1;\n  undefined auStack_40 [8];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined2 uStack_a;\n  \n  uStack_a = 0;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_2172b602a5924a58(2,1,6);\n  if (iStack_14 != -1) {\n    func_d7df9eb458294f72(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_e13664a68a4c4fdd(0x6987);\n    iVar1 = func_d6db3d16b484410b(iStack_14,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_e320b20d6fbd405d(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_d9a9802872ed430b(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_5b438372335d44df(iStack_10,auStack_40,7,0), iStack_18 != -1 && (iStack_18 != 0))\n       )) {\n      auStack_40[iStack_18] = 0;\n      iStack_1c = func_e1b43ec021e14135(auStack_40);\n      if ((iStack_1c < 0x8000) && (-0x8001 < iStack_1c)) {\n        uStack_a = (undefined2)iStack_1c;\n      }\n      else {\n        uStack_a = 0xffff;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_9982e1e96eed4d21(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_9982e1e96eed4d21(iStack_10);\n  }\n  func_699dad1fd8544dcfData = uStack_a;\n  func_fd56a76a4e1c4d41();\n  return;\n}\n\n",
        "\nvoid func_ea1e8770dccb4711(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uStack_c8;\n  undefined8 uStack_c0;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  ushort uStack_98;\n  undefined auStack_88 [104];\n  undefined *puStack_20;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_88;\n  func_9e52770d0eb8454a(puStack_10,0x41,99);\n  puStack_10[99] = 0;\n  puStack_18 = puStack_10;\n  puStack_20 = puStack_10;\n  uStack_c8 = 0;\n  uStack_c0 = 0;\n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uVar1 = func_081ad7fb9b6e44b3(puStack_10);\n  func_ba68a00360ef45b8(&uStack_c8,puStack_20,uVar1);\n  uStack_98 = uStack_98 & 0xff;\n  func_68e5f9d44a614be2(puStack_20);\n  return;\n}\n\n",
        "\nvoid func_6db085c0c49845e2(void)\n\n{\n  func_7862f33111804430();\n  func_e9dc20dc2ba94681();\n  return;\n}\n\n",
        "\nvoid func_55d16f893e294be8(undefined8 param_1)\n\n{\n  func_2cc3e6b3fedf4a6d(param_1);\n  return;\n}\n\n",
        "\nvoid func_a631b15f27c348c5(void)\n\n{\n  func_b7b4c12fc4074eb3();\n  func_fc89f936c35049b2();\n  return;\n}\n\n",
        "\nvoid func_d7157f73537b4bbc(undefined8 *param_1)\n\n{\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined4 uStack_20;\n  undefined8 uStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_18 = *param_1;\n  uStack_48 = 0x4100000041;\n  uStack_40 = 0x4100000041;\n  uStack_38 = 0x4100000041;\n  uStack_30 = 0x4100000041;\n  uStack_28 = 0x4100000041;\n  uStack_20 = 0;\n  puStack_10 = param_1;\n  func_b894889089434070(uStack_18,&uStack_48);\n  func_3adeca2fe2054d3e(uStack_18);\n  func_507d850941ee4ba6(uStack_18);\n  return;\n}\n\n",
        "\nvoid func_d077fea9ab0f4f2a(void)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_68_badData;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_489c37991a0d411a(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_342209ad650b4d18(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_38c76766bca44e8e(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_b5382d4216084369(int param_1)\n\n{\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined8 uStack_18;\n  int iStack_c;\n  \n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  if (param_1 < 0) {\n    func_f3fe3b6665374b09(&UNK_00401608);\n  }\n  else {\n    *(undefined4 *)((long)&uStack_38 + (long)param_1 * 4) = 1;\n    for (iStack_c = 0; iStack_c < 10; iStack_c = iStack_c + 1) {\n      func_5b17dfc9561d4e0f(*(undefined4 *)((long)&uStack_38 + (long)iStack_c * 4));\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_59b6cba9e8d64f4e(undefined8 param_1)\n\n{\n  func_58fbfcb663bb4d82(param_1);\n  return;\n}\n\n",
        "\nvoid func_27b5327118ab4e91(void)\n\n{\n  func_d266103ae33a4bcc();\n  func_1b508b725a5a4853();\n  return;\n}\n\n",
        "\nvoid func_332f5845d34f4b5a(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  ushort uStack_88;\n  undefined auStack_78 [104];\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_78;\n  iVar1 = func_04228f60651b4bd2();\n  if (iVar1 != 0) {\n    func_e4893d2a34d14068(puStack_10,0x41,99);\n    puStack_10[99] = 0;\n  }\n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uVar2 = func_fead85803046412c(puStack_10);\n  func_7dff2b69a72b4d06(&uStack_b8,puStack_10,uVar2);\n  uStack_88 = uStack_88 & 0xff;\n  func_118d966f0a8f426d(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_dc651fba4c274be2(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_61e29738723045ca(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lStack_20 = func_0896dfb422a44c36(&UNK_004014a6,&UNK_004014a4);\n    if (lStack_20 != 0) {\n      lVar1 = func_24792c2dd4b94aa5((long)puStack_10 + lStack_18,100 - (int)lStack_18,lStack_20);\n      if (lVar1 == 0) {\n        func_0ba03798a9044c58(&UNK_004014b4);\n        *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n      }\n      func_d03f98c0934e4f4b(lStack_20);\n    }\n  }\n  func_4052edb65cab49d4(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_04c49c77e7144d2f(void)\n\n{\n  int iVar1;\n  undefined auStack_30 [8];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined2 uStack_16;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_16 = 0xffff;\n  iStack_10 = 0xffffffff;\n  iStack_c = -1;\n  iStack_10 = func_62f2836dbbc04d8b(2,1,6);\n  if (iStack_10 != -1) {\n    func_b1e19ed491714e27(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_87bcf1cf0ddb47fb(0x6987);\n    iVar1 = func_b32feee5bc89436c(iStack_10,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_ca78bbb17f2845f7(iStack_10,5), iVar1 != -1)) &&\n        (iStack_c = func_fd4f1410a9044272(iStack_10,0,0), iStack_c != -1)) &&\n       ((iStack_14 = func_0e771a20ebd64aa0(iStack_c,auStack_30,7,0), iStack_14 != -1 && (iStack_14 != 0)))\n       ) {\n      auStack_30[iStack_14] = 0;\n      uStack_16 = func_a758dd57a3bf4858(auStack_30);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_2e5d26583dfd474a(iStack_10);\n  }\n  if (iStack_c != -1) {\n    func_2e5d26583dfd474a(iStack_c);\n  }\n  func_1e0f729a4a5f4874(&uStack_16);\n  return;\n}\n\n",
        "\nvoid func_05403789c079436f(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_f8ce3a35edfb4e31(2,1,6);\n  if (iStack_14 != -1) {\n    func_028e72d5090e4fa0(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_b36c2463346d4e3f(0x6987);\n    iVar1 = func_71e9f62763004f41(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_1b0b7c25b4b24f0a(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_c53a391db67149a6(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_5d40494a266e4630(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      iStack_c = func_bf86eb7a2c054db6(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_46a114d8d1f94c2a(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_46a114d8d1f94c2a(iStack_10);\n  }\n  if (iStack_c < 6) {\n    func_bc893f217457462d(&UNK_00401647,&UNK_00401560,0x7c,__PRETTY_FUNCTION___4463);\n  }\n  return;\n}\n\n",
        "\nvoid func_7b8364c94ce84ef9(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  byte bVar4;\n  undefined8 uStack_368;\n  undefined8 uStack_360;\n  undefined8 auStack_358 [48];\n  undefined2 uStack_1d8;\n  undefined2 uStack_1d6;\n  undefined4 uStack_1d4;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [49];\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  bVar4 = 0;\n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_10 = &uStack_1c8;\n  if (GLOBAL_CONST_TRUE != 0) {\n    iStack_14 = 0xffffffff;\n    lStack_20 = func_f354b1d26c8f4078(puStack_10);\n    iStack_14 = func_562137ed46e448e3(2,1,6);\n    if (iStack_14 != -1) {\n      func_0f8407e1fb1a41a1(&uStack_1d8,0,0x10);\n      uStack_1d8 = 2;\n      uStack_1d4 = func_75f22e9aea324432(&UNK_00401614);\n      uStack_1d6 = func_fb129e70fefc4ce0(0x6987);\n      iVar1 = func_2139dfcc6f1e4374(iStack_14,&uStack_1d8,0x10);\n      if (((iVar1 != -1) &&\n          (iStack_24 = func_17279272279440c9(iStack_14,lStack_20 * 4 + (long)puStack_10,\n                                       (99 - lStack_20) * 4,0), iStack_24 != -1)) &&\n         (iStack_24 != 0)) {\n        *(undefined4 *)((long)puStack_10 + (lStack_20 + ((ulong)(long)iStack_24 >> 2)) * 4) = 0;\n        puStack_30 = (undefined4 *)func_5460be01749c48b4(puStack_10,0xd);\n        if (puStack_30 != (undefined4 *)0x0) {\n          *puStack_30 = 0;\n        }\n        puStack_30 = (undefined4 *)func_5460be01749c48b4(puStack_10,10);\n        if (puStack_30 != (undefined4 *)0x0) {\n          *puStack_30 = 0;\n        }\n      }\n    }\n    if (iStack_14 != -1) {\n      func_a186933ef58b4db4(iStack_14);\n    }\n  }\n  if (GLOBAL_CONST_TRUE != 0) {\n    uStack_368 = 0;\n    uStack_360 = 0;\n    puVar3 = auStack_358;\n    for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n      *puVar3 = 0;\n      puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n    }\n    func_dfcd3437a33f4134(&uStack_368,99,puStack_10);\n    func_beff517f02b64708(&uStack_368);\n  }\n  return;\n}\n\n",
        "\nvoid func_93683d645b284a0d(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)func_db0ce226bbc141ba(8);\n  puVar1 = (undefined8 *)*puVar2;\n  func_7497c2ddd11d4973(puVar2);\n  func_7e53607e871440f5(*puVar1);\n  return;\n}\n\n",
        "\nvoid func_6c828f0c167945fd(void)\n\n{\n  int iVar1;\n  int iVar2;\n  uint auStack_1c [3];\n  \n  auStack_1c[0] = 0xffffffff;\n  iVar1 = func_c65f4c5155f148c4();\n  iVar2 = func_c65f4c5155f148c4();\n  auStack_1c[0] = func_c65f4c5155f148c4();\n  auStack_1c[0] = auStack_1c[0] ^ iVar1 << 0x1e ^ iVar2 << 0xf;\n  func_f5992d4cfca74e73(auStack_1c);\n  return;\n}\n\n",
        "\nvoid func_a85e3d0159a04e01(void)\n\n{\n  func_409a19e2c04a48ee();\n  return;\n}\n\n",
        "\nvoid func_87e821e6a2cb4089(void)\n\n{\n  func_b4fa1490df6c4fba();\n  return;\n}\n\n",
        "\nvoid func_fedd1dd35a2b4a1d(void)\n\n{\n  func_e20327e7fc95465a();\n  func_13acccfaa6da41a2();\n  return;\n}\n\n",
        "\nvoid func_fb95c08e76374828(void)\n\n{\n  undefined auStack_420 [416];\n  undefined4 auStack_280 [50];\n  undefined auStack_1b8 [396];\n  undefined4 uStack_2c;\n  undefined4 *puStack_20;\n  undefined *puStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_20 = auStack_280;\n  puStack_18 = auStack_420;\n  auStack_280[0] = 0;\n  puStack_10 = puStack_20;\n  func_f755991978734d9a(auStack_1b8,0x43,99);\n  uStack_2c = 0;\n  func_21644a2ac745436d(puStack_20,auStack_1b8,100);\n  func_3e24f038f79241f1(puStack_20);\n  return;\n}\n\n",
        "\nvoid func_9793ec6e62854735(void)\n\n{\n  func_4843fd757fc141a6();\n  func_7afb868625a041c0();\n  return;\n}\n\n",
        "\nvoid func_b455ac11a8f54896(void)\n\n{\n  func_5aeafbceaa9243bd();\n  func_47700315515448ac();\n  return;\n}\n\n",
        "\nvoid func_5fa44da948154d77(void)\n\n{\n  long lVar1;\n  undefined auStack_c0 [64];\n  undefined4 auStack_80 [10];\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined4 uStack_30;\n  undefined *puStack_28;\n  undefined4 *puStack_20;\n  undefined4 *puStack_18;\n  int iStack_c;\n  \n  puStack_20 = auStack_80;\n  puStack_28 = auStack_c0;\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    puStack_18 = puStack_20;\n    *puStack_20 = 0;\n  }\n  uStack_58 = 0x4100000041;\n  uStack_50 = 0x4100000041;\n  uStack_48 = 0x4100000041;\n  uStack_40 = 0x4100000041;\n  uStack_38 = 0x4100000041;\n  uStack_30 = 0;\n  lVar1 = func_4d451de5e13945fb(&uStack_58);\n  func_4e8ad1529bb64558(puStack_18,&uStack_58,(lVar1 + 1) * 4);\n  func_d5b0a42cafac46ec(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_786b1ddd1cf94b39(void)\n\n{\n  long lVar1;\n  undefined auStack_f8 [99];\n  undefined uStack_95;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  undefined8 uStack_16;\n  short sStack_e;\n  int iStack_c;\n  \n  sStack_e = 0;\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    uStack_16 = 0;\n    lVar1 = func_efe01495be0e4939(&uStack_16,8,stdin);\n    if (lVar1 == 0) {\n      func_83dcc4cc9f094ff4(&UNK_00401394);\n    }\n    else {\n      sStack_e = func_7f20663d398f43f7(&uStack_16);\n    }\n  }\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  func_b7f571a90eee4553(auStack_f8,0x41,99);\n  uStack_95 = 0;\n  if (sStack_e < 100) {\n    func_9772d74fb2e94b49(&uStack_88,auStack_f8,(long)sStack_e);\n    *(undefined *)((long)&uStack_88 + (long)(int)sStack_e) = 0;\n  }\n  func_83dcc4cc9f094ff4(&uStack_88);\n  return;\n}\n\n",
        "\nvoid func_f7ab63850a724535(void)\n\n{\n  func_2721193c067b4445();\n  func_143be9f7ba3848f2();\n  return;\n}\n\n",
        "\nvoid func_b9a6850f908e4dc9(void)\n\n{\n  int iVar1;\n  undefined4 auStack_1b8 [102];\n  long lStack_20;\n  ulong uStack_18;\n  long lStack_10;\n  \n  lStack_10 = 0;\n  iVar1 = func_409445f1f6324126();\n  if (iVar1 != 0) {\n    lStack_20 = func_49bf869622fe46dc(400);\n    func_7773fd9f892e4db5(lStack_20,0x41,99);\n    *(undefined4 *)(lStack_20 + 0x18c) = 0;\n    lStack_10 = lStack_20 + -0x20;\n  }\n  func_7773fd9f892e4db5(auStack_1b8,0x43,99);\n  auStack_1b8[99] = 0;\n  for (uStack_18 = 0; uStack_18 < 100; uStack_18 = uStack_18 + 1) {\n    *(undefined4 *)(uStack_18 * 4 + lStack_10) = auStack_1b8[uStack_18];\n  }\n  *(undefined4 *)(lStack_10 + 0x18c) = 0;\n  func_8295f29839fc4b37(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_10e75ffc63464169(int param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  ulong uStack_10;\n  \n  lVar1 = func_d5cc326c32b74683(&UNK_00401408,&UNK_00401417);\n  if (lVar1 == 0) {\n    func_4b8313f3a38a4c08(1);\n  }\n  for (uStack_10 = 0; uStack_10 < (ulong)(long)param_1; uStack_10 = uStack_10 + 1) {\n    lVar2 = func_eb1d2e64d7bd42ff(&UNK_00401420,1,0x32,lVar1);\n    if (lVar2 != 0x32) {\n      func_4b8313f3a38a4c08(1);\n    }\n  }\n  if (lVar1 != 0) {\n    func_8ba8ae3db8b74d96(lVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_afa3ce178a4b4eb3(short param_1)\n\n{\n  func_bbdf73c72f954118((int)param_1);\n  return;\n}\n\n",
        "\nvoid func_d78d6b5392254c2c(undefined8 *param_1)\n\n{\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined2 uStack_28;\n  undefined8 uStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_18 = *param_1;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = param_1;\n  func_37d7f51c352b4068(&uStack_58,uStack_18);\n  func_d779c2d500014348(uStack_18);\n  func_8b304428b7e84d89(uStack_18);\n  return;\n}\n\n",
        "\n/* WARNING: Removing unreachable block (ram,0x00400c75) */\n\nvoid func_233af8ec43814cff(void)\n\n{\n  long lVar1;\n  int iStack_c;\n  \n  lVar1 = func_60cc73f736334aa2(0x28);\n  for (iStack_c = 0; iStack_c < 10; iStack_c = iStack_c + 1) {\n    *(undefined4 *)(lVar1 + (long)iStack_c * 4) = 0;\n  }\n  *(undefined4 *)(lVar1 + 0x28) = 1;\n  for (iStack_c = 0; iStack_c < 10; iStack_c = iStack_c + 1) {\n    func_27dcf62fe671445b(*(undefined4 *)(lVar1 + (long)iStack_c * 4));\n  }\n  func_1f40a9862b8d49e0(lVar1);\n  return;\n}\n\n",
        "\nvoid func_6e029b7bfe4d4ea0(void)\n\n{\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  long lStack_18;\n  long lStack_10;\n  \n  if (staticTrue != 0) {\n    uStack_48 = 0x6100000062;\n    uStack_40 = 0x5800000064;\n    uStack_38 = 0x5800000058;\n    uStack_30 = 0x5800000058;\n    uStack_28 = 0x58;\n    lStack_10 = func_abe4bad53b6e4ea3(&uStack_48);\n    if (lStack_10 != 0) {\n      lStack_18 = func_1c149980c59f4150(lStack_10,&UNK_00401294);\n      if (lStack_18 != 0) {\n        func_043a159b2b1a474a(&UNK_0040129c,1,0xe,lStack_18);\n        func_9180f00a87414b15(lStack_18);\n      }\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_0249467f2ce94e52(undefined8 param_1)\n\n{\n  func_f6663cdbbc58460f(param_1);\n  return;\n}\n\n",
        "\nvoid func_939a559fb2254894(void)\n\n{\n  long lVar1;\n  \n  lVar1 = func_099ddc6cf06846c8(400);\n  func_b1ef73a55e1c4db9(lVar1,0x41,99);\n  *(undefined4 *)(lVar1 + 0x18c) = 0;\n  func_2e356da766ca4ecc(lVar1 + -0x20);\n  return;\n}\n\n",
        "\nvoid func_dd82d68465e7487f(void)\n\n{\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  puStack_10 = &uStack_78;\n  puStack_10 = (undefined8 *)\n               func_cf89d4b605fa4a3d\n                         (puStack_10);\n  func_9750d10b94ba4cbe(puStack_10,puStack_10);\n  return;\n}\n\n",
        "\nvoid func_8e2e6139d66c4c84(long param_1)\n\n{\n  int iVar1;\n  int iStack_1c;\n  undefined8 uStack_18;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_18 = *(undefined8 *)(param_1 + 0x10);\n  iVar1 = func_e638eaa15f4c496e(uStack_18,&UNK_00401734,&iStack_1c);\n  if ((iVar1 == 1) && (iStack_1c < 10000)) {\n    iStack_10 = 0;\n    for (iStack_c = 0; iStack_c < iStack_1c; iStack_c = iStack_c + 1) {\n      iStack_10 = iStack_10 + 1;\n    }\n    func_71d7e08732b846d4(iStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_2813a10d3fa24e28(undefined8 param_1)\n\n{\n  func_bbe4b1a3be9042e5(param_1);\n  return;\n}\n\n",
        "\nvoid func_ea5c66b60fee44b7(void)\n\n{\n  undefined auStack_1c8 [24];\n  undefined *puStack_1b0;\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined *puStack_10;\n  \n  puStack_1b0 = &UNK_00400bf6;\n  func_130c49f67b1447c0(auStack_1a8,0x41,99);\n  uStack_1c = 0;\n  puStack_10 = auStack_1c8;\n  puStack_1b0 = &UNK_00400c18;\n  func_2331522b2c034e18(&puStack_10);\n  return;\n}\n\n",
        "\nvoid func_8b55479555924771(void)\n\n{\n  undefined auStack_1b0 [408];\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_18 = auStack_1b0;\n  puStack_10 = puStack_18;\n  func_542d2989a6f54432(puStack_18,0x41,99);\n  *(undefined4 *)(puStack_18 + 0x18c) = 0;\n  func_8640ac3997f24c5a(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_4a00270aa1344c10(undefined8 param_1)\n\n{\n  func_b493cd3291904349(param_1);\n  return;\n}\n\n",
        "\nvoid func_370230746d6d4b3f(void)\n\n{\n  func_043374d8cd19445a();\n  func_c4dfd7c6952344d7();\n  return;\n}\n\n",
        "\nvoid func_29e6da67c07a4025(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_40 [8];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  short sStack_1c;\n  short sStack_1a;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  short sStack_a;\n  \n  sStack_a = 0;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_cddabdf381714b0e(2,1,6);\n  if (iStack_10 != -1) {\n    func_09cfdb6f429443dc(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = func_3ddf8bf001544a72(&UNK_004015a4);\n    uStack_36 = func_77e92377912e49b7(0x6987);\n    iVar1 = func_d368488362b546fe(iStack_10,&uStack_38,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_7b2b595a5f5940b5(iStack_10,auStack_40,7,0), iStack_14 != -1))\n       && (iStack_14 != 0)) {\n      auStack_40[iStack_14] = 0;\n      iStack_18 = func_7d1d233bd2f948ac(auStack_40);\n      if ((iStack_18 < 0x8000) && (-0x8001 < iStack_18)) {\n        sStack_a = (short)iStack_18;\n      }\n      else {\n        sStack_a = -1;\n      }\n    }\n  }\n  if (iStack_10 != -1) {\n    func_46ba6ab719c0414b(iStack_10);\n  }\n  sStack_1c = sStack_a;\n  sStack_1a = sStack_a;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_09cfdb6f429443dc(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (sStack_1a < 100) {\n    func_a7a8954b08b845ba(&uStack_a8,auStack_118,(long)sStack_1a);\n    *(undefined *)((long)&uStack_a8 + (long)(int)sStack_1a) = 0;\n  }\n  func_aa2dbbb9de064d5e(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_77f2d5d32a7d43f0(void)\n\n{\n  int iVar1;\n  undefined2 uStack_a8;\n  undefined2 uStack_a6;\n  undefined4 uStack_a4;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined4 uStack_38;\n  undefined *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  puStack_10 = &uStack_98;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_7e050096c6004d40(puStack_10);\n  iStack_14 = func_e74ca74bcfde45a9(2,1,6);\n  if (iStack_14 != -1) {\n    func_c2a7a4c1d77e4e28(&uStack_a8,0,0x10);\n    uStack_a8 = 2;\n    uStack_a4 = func_7e756363960f4467(&UNK_00401738);\n    uStack_a6 = func_9085f09b197346a4(0x6987);\n    iVar1 = func_318e212f66af4c4a(iStack_14,&uStack_a8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_5e768485e0b74ce9(iStack_14,(long)puStack_10 + lStack_20,99 - lStack_20,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      *(undefined *)((long)puStack_10 + iStack_24 + lStack_20) = 0;\n      puStack_30 = (undefined *)func_6628742fc183421e(puStack_10,0xd);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined *)func_6628742fc183421e(puStack_10,10);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_6762bdaf14034d37(iStack_14);\n  }\n  func_efb0cc0adecb465b(puStack_10,puStack_10);\n  return;\n}\n\n",
        "\nvoid func_e289381c0b9545cb(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_55b018eedacf419e(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lVar1 = func_5c5202fcb43a4b7a((long)puStack_10 + lStack_18,100 - (int)lStack_18,stdin);\n    if (lVar1 == 0) {\n      func_4948b1e1353046ba(&UNK_00401324);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    else {\n      lStack_18 = func_55b018eedacf419e(puStack_10);\n      if ((lStack_18 != 0) && (*(char *)((long)puStack_10 + lStack_18 + -1) == '\\n')) {\n        *(undefined *)((long)puStack_10 + lStack_18 + -1) = 0;\n      }\n    }\n  }\n  func_6a2b189f5c79424c(&UNK_0040133a,&UNK_0040133a,&UNK_00401337,&UNK_00401333,puStack_10,0);\n  return;\n}\n\n",
        "\nvoid func_553312f1b8f94c7b(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined4 uStack_20;\n  undefined8 uStack_10;\n  \n  uStack_48 = 0x4100000041;\n  uStack_40 = 0x4100000041;\n  uStack_38 = 0x4100000041;\n  uStack_30 = 0x4100000041;\n  uStack_28 = 0x4100000041;\n  uStack_20 = 0;\n  uStack_10 = param_1;\n  lVar1 = func_16d43204ecb546cd(&uStack_48);\n  func_bacc0548f22d4cae(uStack_10,&uStack_48,lVar1 + 1);\n  func_f6aba3a96e694b4e(uStack_10);\n  func_23cb243774af4dca(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_82cca19b07354ba0(undefined8 param_1)\n\n{\n  func_95934666b1694d22(param_1);\n  return;\n}\n\n",
        "\nvoid func_37627da203a04e41(void)\n\n{\n  undefined8 uVar1;\n  undefined auStack_c0 [104];\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  ushort uStack_28;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_18 = auStack_c0;\n  puStack_10 = puStack_18;\n  func_f06b951963274828(puStack_18,0x41,99);\n  puStack_18[99] = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uVar1 = func_de2a838e25114afe(puStack_18);\n  func_def5216c9286409d(&uStack_58,puStack_18,uVar1);\n  uStack_28 = uStack_28 & 0xff;\n  func_dab000f1e11c4390(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_76eca9b908854722(void)\n\n{\n  int iVar1;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  if (GLOBAL_CONST_FIVE == 5) {\n    iStack_18 = 0xffffffff;\n    iStack_10 = -1;\n    iStack_18 = func_ca662c58305e4734(2,1,6);\n    if (iStack_18 != -1) {\n      func_6b89d085e59d4854(&uStack_38,0,0x10);\n      uStack_38 = 2;\n      uStack_34 = 0;\n      uStack_36 = func_4c2238bd16c54ae6(0x6987);\n      iVar1 = func_4fe13e80992f487f(iStack_18,&uStack_38,0x10);\n      if ((iVar1 != -1) && (iVar1 = func_64e3ce79c4964f47(iStack_18,5), iVar1 != -1)) {\n        iStack_10 = func_55bded031c944587(iStack_18,0,0);\n        if (iStack_10 != -1) {\n          iStack_1c = func_68b158f905054917(iStack_10,auStack_46,0xd,0);\n          if ((iStack_1c != -1) && (iStack_1c != 0)) {\n            auStack_46[iStack_1c] = 0;\n            iStack_c = func_6c1f7e3c68e24b19(auStack_46);\n          }\n        }\n      }\n    }\n    if (iStack_18 != -1) {\n      func_d63605b54d9d4dcf(iStack_18);\n    }\n    if (iStack_10 != -1) {\n      func_d63605b54d9d4dcf(iStack_10);\n    }\n  }\n  if (GLOBAL_CONST_FIVE == 5) {\n    uStack_78 = 0;\n    uStack_70 = 0;\n    uStack_68 = 0;\n    uStack_60 = 0;\n    uStack_58 = 0;\n    if (iStack_c < 0) {\n      func_513e0d9db1384226(&UNK_00401558);\n    }\n    else {\n      *(undefined4 *)((long)&uStack_78 + (long)iStack_c * 4) = 1;\n      for (iStack_14 = 0; iStack_14 < 10; iStack_14 = iStack_14 + 1) {\n        func_2be7d36b7ad84c70(*(undefined4 *)((long)&uStack_78 + (long)iStack_14 * 4));\n      }\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_e3743de405fd4311(undefined8 param_1)\n\n{\n  func_44314fbdb24f4e85(param_1);\n  return;\n}\n\n",
        "\nvoid func_6b6d6b865a2547a9(void)\n\n{\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  puStack_10 = &uStack_78;\n  puStack_10 = (undefined8 *)\n               func_73ec60cedfc8404b(puStack_10);\n  func_dcc9d1ce82f24301(&UNK_004012fb,&UNK_004012fb,&UNK_004012f8,&UNK_004012f4,puStack_10,0);\n  return;\n}\n\n",
        "\nvoid func_2d48d50d067c4701\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n               undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 uStack_d0;\n  undefined4 uStack_cc;\n  undefined *puStack_c8;\n  undefined *puStack_c0;\n  undefined auStack_b8 [8];\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined4 uStack_88;\n  undefined4 uStack_78;\n  undefined4 uStack_68;\n  undefined4 uStack_58;\n  undefined4 uStack_48;\n  undefined4 uStack_38;\n  undefined4 uStack_28;\n  undefined4 uStack_18;\n  \n  if (in_AL != '\\0') {\n    uStack_88 = param_1;\n    uStack_78 = param_2;\n    uStack_68 = param_3;\n    uStack_58 = param_4;\n    uStack_48 = param_5;\n    uStack_38 = param_6;\n    uStack_28 = param_7;\n    uStack_18 = param_8;\n  }\n  uStack_d0 = 8;\n  uStack_cc = 0x30;\n  puStack_c8 = &stack0x00000008;\n  puStack_c0 = auStack_b8;\n  uStack_b0 = param_10;\n  uStack_a8 = param_11;\n  uStack_a0 = param_12;\n  uStack_98 = param_13;\n  uStack_90 = param_14;\n  func_d075f0db3dd64ee5(stdout,param_9,&uStack_d0);\n  return;\n}\n\n",
        "\nvoid func_440bce75172844a2(undefined8 param_1)\n\n{\n  func_d3d74c6603f74142(param_1);\n  return;\n}\n\n",
        "\nvoid func_f11a36a972104ffe(void)\n\n{\n  return;\n}\n\n",
        "\nvoid func_52e1e50f1ebc49d2(void)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = 0;\n  func_e055aa9a46574241(stdin,&UNK_004012f4,&sStack_a);\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_14729030fdba4c1a(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_27c12bb884564112(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_c051ceafc9f44865(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_6d9d9003eb3f4209(void)\n\n{\n  undefined4 auStack_d8 [50];\n  undefined4 *puStack_10;\n  \n  func_6d9d9003eb3f4209Data = auStack_d8;\n  auStack_d8[0] = 0;\n  puStack_10 = func_6d9d9003eb3f4209Data;\n  func_31b079a3c4a3427e();\n  return;\n}\n\n",
        "\nvoid func_bd51873d4b844e32\n               (undefined8 *param_1)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 auStack_328 [100];\n  \n  puVar2 = auStack_328;\n  for (lVar1 = 100; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  func_06be0f8e2dd54c0e(param_1,auStack_328,800);\n  func_6f1b78bebfc141e7(*param_1);\n  return;\n}\n\n",
        "\nvoid func_66e457d3b40b41cf(undefined4 param_1)\n\n{\n  func_fd8d6513ca8943b8(param_1);\n  return;\n}\n\n",
        "\nvoid func_e5c526ae1fbf40cc(ulong *param_1)\n\n{\n  undefined4 *puVar1;\n  \n  if (*param_1 < 6) {\n    func_ce69c14e8fd74e57(&UNK_004015e8);\n  }\n  else {\n    puVar1 = (undefined4 *)func_91c2b7934bd94466(*param_1);\n    *puVar1 = 0x6c6c6568;\n    *(undefined2 *)(puVar1 + 1) = 0x6f;\n    func_ce69c14e8fd74e57(puVar1);\n    func_8860464496f44f63(puVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_b4b0b75505044480(void)\n\n{\n  long lVar1;\n  \n  if (staticFive == 5) {\n    lVar1 = func_01ca87824bf749a8(0x20);\n    *(undefined **)(lVar1 + 0x10) = &UNK_00401234;\n    func_70fbbf3bf1244625(*(undefined8 *)(lVar1 + 0x10));\n    func_79942f5af2084627(lVar1,&UNK_00401234,0x20);\n    *(undefined *)(lVar1 + 0xf) = 0;\n    func_70fbbf3bf1244625(lVar1);\n    func_70fbbf3bf1244625(*(undefined8 *)(lVar1 + 0x10));\n    func_ab95fc1a178b4e1d(lVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_df76d309fbb54942(undefined8 param_1)\n\n{\n  func_47a1bafe58bd4e4b(param_1);\n  return;\n}\n\n",
        "\nvoid func_04045a5183d54027(undefined8 param_1)\n\n{\n  func_4862c4dd0ac04e0e(param_1);\n  return;\n}\n\n",
        "\nvoid func_ada9cb4540f74a88(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iVar1 = func_63649a91d96b4eda();\n  if (iVar1 != 0) {\n    iStack_14 = 0xffffffff;\n    iStack_10 = -1;\n    iStack_14 = func_eec8a756b1dd4d70(2,1,6);\n    if (iStack_14 != -1) {\n      func_0bac149c19104378(&uStack_28,0,0x10);\n      uStack_28 = 2;\n      uStack_24 = 0;\n      uStack_26 = func_f4793cc58fd3476d(0x6987);\n      iVar1 = func_903e10f415ec443d(iStack_14,&uStack_28,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_2e1ba315888648b9(iStack_14,5), iVar1 != -1)) &&\n          (iStack_10 = func_411cd30fa31d4350(iStack_14,0,0), iStack_10 != -1)) &&\n         ((iStack_18 = func_cacc2544679d49e0(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n          (iStack_18 != 0)))) {\n        auStack_36[iStack_18] = 0;\n        iStack_c = func_8a9bb75931694aeb(auStack_36);\n      }\n    }\n    if (iStack_14 != -1) {\n      func_571fea1d7c1040b8(iStack_14);\n    }\n    if (iStack_10 != -1) {\n      func_571fea1d7c1040b8(iStack_10);\n    }\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_0bac149c19104378(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_54c8f21ec0ac450d(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_9af23b7ad7ff4797(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_662594beefac4750(void)\n\n{\n  func_6fe6d6716daa440b();\n  func_4b1b6def993a4301();\n  func_3e1eefa9b9544cd1();\n  func_f6a46c32231446e6();\n  return;\n}\n\n",
        "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid func_d7ed8b8a7039485a(void)\n\n{\n  undefined8 *puStack_10;\n  \n  puStack_10 = (undefined8 *)0x0;\n  puStack_10 = (undefined8 *)func_68b5154dbe194336(8);\n  *puStack_10 = _UNK_004011e8;\n  func_cefa2b3281d6420a(&puStack_10);\n  return;\n}\n\n",
        "\nvoid func_b1de84933ff34a98(void)\n\n{\n  undefined auStack_60 [32];\n  undefined auStack_40 [24];\n  undefined *puStack_28;\n  undefined *puStack_20;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_28 = auStack_40;\n  puStack_18 = auStack_60;\n  auStack_40[0] = 0;\n  puStack_20 = puStack_28;\n  puStack_10 = puStack_28;\n  func_5bf1642cea214b9d(puStack_28,0x10,2);\n  return;\n}\n\n",
        "\nvoid func_3cb93634e8b24152(undefined4 param_1)\n\n{\n  func_b78cb91788bd462a(param_1);\n  return;\n}\n\n",
        "\nvoid func_904b4c49b8dc4c23(undefined8 param_1)\n\n{\n  func_4006951a3689460e(param_1);\n  return;\n}\n\n",
        "\nvoid func_d84821a9aba7484c(void)\n\n{\n  func_8c5fd71b4bc14582();\n  func_296644a367194706();\n  return;\n}\n\n",
        "\nvoid func_09b7cd0ba8a148c6(void)\n\n{\n  func_97d5a010a0dc476a();\n  func_99282da6ef164031();\n  return;\n}\n\n",
        "\nvoid func_5275f56bed914a8b(undefined8 param_1)\n\n{\n  func_10827b5aca724899(param_1);\n  return;\n}\n\n",
        "\nvoid func_0f6b45bd36ef432e(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_4ad33ae41ddf4a58(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lVar1 = func_640341a5d0954b33((long)puStack_10 + lStack_18,100 - (int)lStack_18,stdin);\n    if (lVar1 == 0) {\n      func_f4ea2a35367d4e5b(&UNK_004012c4);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    else {\n      lStack_18 = func_4ad33ae41ddf4a58(puStack_10);\n      if ((lStack_18 != 0) && (*(char *)((long)puStack_10 + lStack_18 + -1) == '\\n')) {\n        *(undefined *)((long)puStack_10 + lStack_18 + -1) = 0;\n      }\n    }\n  }\n  func_c22c818a352c4548(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_126d3d5b56014aa6\n               (undefined8 param_1)\n\n{\n  func_59a4f45889ed46c0(param_1);\n  return;\n}\n\n",
        "\nvoid func_b23a3d235eae4f7d(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_1b8;\n  undefined8 uStack_1b0;\n  undefined8 auStack_1a8 [49];\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_1b8 = 0;\n  uStack_1b0 = 0;\n  puVar2 = auStack_1a8;\n  for (lVar1 = 0x30; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  puStack_10 = &uStack_1b8;\n  if (GLOBAL_CONST_FIVE == 5) {\n    lStack_18 = func_36a9fd795dd4454a(puStack_10);\n    if (1 < 100U - lStack_18) {\n      lStack_20 = func_57bf8343a9414495(&UNK_004012f6,&UNK_004012f4);\n      if (lStack_20 != 0) {\n        lVar1 = func_a2ce8e550f0048cd(lStack_18 * 4 + (long)puStack_10,100 - (int)lStack_18,lStack_20);\n        if (lVar1 == 0) {\n          func_6862f3dce6b345ea(&UNK_00401304);\n          *(undefined4 *)((long)puStack_10 + lStack_18 * 4) = 0;\n        }\n        func_ba42b1b35184407d(lStack_20);\n      }\n    }\n  }\n  if (GLOBAL_CONST_FIVE == 5) {\n    func_8f31c302d3a64bbb(puStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_3bd0b4e5f7fd4eb7(void)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)func_e9bc8eeb04e244d6(100);\n  *puVar1 = 0x676e697274532041;\n  *(undefined *)(puVar1 + 1) = 0;\n  func_3f4f31a960e545bb(puVar1);\n  func_3bd0b4e5f7fd4eb7Data = puVar1;\n  func_9590e96914b24f6a();\n  return;\n}\n\n",
        "\nvoid func_7fedf047237047b8(void)\n\n{\n  func_0117d98f55214715();\n  func_00bddee34c3b432a();\n  return;\n}\n\n",
        "\nvoid func_fb18fc303afb450f(void)\n\n{\n  func_c7a91489ae114aaa();\n  return;\n}\n\n",
        "\nvoid func_2f8fac7dabc142cc(void)\n\n{\n  int iVar1;\n  int iStack_bc;\n  undefined2 uStack_b8;\n  undefined2 uStack_b6;\n  undefined4 uStack_b4;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined *puStack_40;\n  int iStack_34;\n  long lStack_30;\n  int iStack_24;\n  undefined8 *puStack_20;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_20 = &uStack_a8;\n  if (globalFive == 5) {\n    iStack_24 = 0xffffffff;\n    iStack_c = -1;\n    lStack_30 = func_8a56bf3c19364025(puStack_20);\n    iStack_24 = func_ed5d72ec0cff4af8(2,1,6);\n    if (iStack_24 != -1) {\n      func_c590009ba1e44f09(&uStack_b8,0,0x10);\n      uStack_b8 = 2;\n      uStack_b4 = 0;\n      uStack_b6 = func_c3c31cf198934bce(0x6987);\n      iVar1 = func_a833d949eca14c77(iStack_24,&uStack_b8,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_6b6cfb4191e9422b(iStack_24,5), iVar1 != -1)) &&\n          (iStack_c = func_dad2a99cab0a46a2(iStack_24,0,0), iStack_c != -1)) &&\n         ((iStack_34 = func_886c81ca5b8b49f8(iStack_c,(long)puStack_20 + lStack_30,99 - lStack_30,0),\n          iStack_34 != -1 && (iStack_34 != 0)))) {\n        *(undefined *)((long)puStack_20 + iStack_34 + lStack_30) = 0;\n        puStack_40 = (undefined *)func_fe00febbe6bf4628(puStack_20,0xd);\n        if (puStack_40 != (undefined *)0x0) {\n          *puStack_40 = 0;\n        }\n        puStack_40 = (undefined *)func_fe00febbe6bf4628(puStack_20,10);\n        if (puStack_40 != (undefined *)0x0) {\n          *puStack_40 = 0;\n        }\n      }\n    }\n    if (iStack_24 != -1) {\n      func_cfc77d60a48d4f61(iStack_24);\n    }\n    if (iStack_c != -1) {\n      func_cfc77d60a48d4f61(iStack_c);\n    }\n  }\n  if ((globalFive == 5) &&\n     (iVar1 = func_c4c2cd9987a14bdb(puStack_20,&UNK_00401664,&iStack_bc), iVar1 == 1)) {\n    iStack_14 = 0;\n    for (iStack_10 = 0; iStack_10 < iStack_bc; iStack_10 = iStack_10 + 1) {\n      iStack_14 = iStack_14 + 1;\n    }\n    func_0df875719afd424b(iStack_14);\n  }\n  return;\n}\n\n",
        "\nvoid func_66f02122b8914125(void)\n\n{\n  func_b4e3832018524b1f();\n  func_96b55e223d1441a9();\n  return;\n}\n\n",
        "\nvoid func_c8bd71411df743de(undefined8 param_1)\n\n{\n  func_433adea669fe4f2e(param_1);\n  return;\n}\n\n",
        "\nvoid func_be6a320bbb2d4037\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n               undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 uStack_d0;\n  undefined4 uStack_cc;\n  undefined *puStack_c8;\n  undefined *puStack_c0;\n  undefined auStack_b8 [8];\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined4 uStack_88;\n  undefined4 uStack_78;\n  undefined4 uStack_68;\n  undefined4 uStack_58;\n  undefined4 uStack_48;\n  undefined4 uStack_38;\n  undefined4 uStack_28;\n  undefined4 uStack_18;\n  \n  if (in_AL != '\\0') {\n    uStack_88 = param_1;\n    uStack_78 = param_2;\n    uStack_68 = param_3;\n    uStack_58 = param_4;\n    uStack_48 = param_5;\n    uStack_38 = param_6;\n    uStack_28 = param_7;\n    uStack_18 = param_8;\n  }\n  uStack_d0 = 8;\n  uStack_cc = 0x30;\n  puStack_c8 = &stack0x00000008;\n  puStack_c0 = auStack_b8;\n  uStack_b0 = param_10;\n  uStack_a8 = param_11;\n  uStack_a0 = param_12;\n  uStack_98 = param_13;\n  uStack_90 = param_14;\n  func_239b17bacb9a4591(stdout,param_9,&uStack_d0);\n  return;\n}\n\n",
        "\nvoid func_c430d51b0cb74d74(void)\n\n{\n  long lVar1;\n  \n  lVar1 = func_3c4bda2667f8466a(100);\n  func_383a601025754879(lVar1,0x41,99);\n  *(undefined *)(lVar1 + 99) = 0;\n  func_eecfefadf8b1476c(lVar1);\n  return;\n}\n\n",
        "\nvoid func_ef606b605984481d(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_9a90708ba8c8412a(2,1,6);\n  if (iStack_14 != -1) {\n    func_291ed26e96784128(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_1e3a5a1c9e144def(0x6987);\n    iVar1 = func_e43b8807cfda467b(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_817c219383214b3e(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_0fc2735f69bc485d(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_9e47e2f0609f4ba3(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      iStack_c = func_d52b531191414095(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_34822cb6532a48a3(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_34822cb6532a48a3(iStack_10);\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_291ed26e96784128(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_6040115723614245(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_c5ec8bd954714820(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_a7be65e2d66746b2(void)\n\n{\n  undefined4 auStack_338 [200];\n  ulong uStack_18;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  if (GLOBAL_CONST_FIVE == 5) {\n    uStack_10 = func_59243793059a4b85(400);\n  }\n  for (uStack_18 = 0; uStack_18 < 100; uStack_18 = uStack_18 + 1) {\n    auStack_338[uStack_18 * 2] = 0;\n    auStack_338[uStack_18 * 2 + 1] = 0;\n  }\n  func_433d4b3ac47c46b2(uStack_10,auStack_338,800);\n  func_38d2c145dcea406f(uStack_10);\n  func_4c8c08a9810e44b8(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_346bdd0314e142a8(void)\n\n{\n  int iVar1;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  undefined4 *puStack_28;\n  int iStack_20;\n  int iStack_1c;\n  ulong uStack_18;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_1c = 0xffffffff;\n  iStack_1c = func_db51db7aac7a4cfb(2,1,6);\n  if (iStack_1c != -1) {\n    func_4961490a5ba64ad4(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = func_ee71735f1b504934(&UNK_00401548);\n    uStack_36 = func_4e8918d94f0046ef(0x6987);\n    iVar1 = func_008ccf1baf4f4caa(iStack_1c,&uStack_38,0x10);\n    if (((iVar1 != -1) && (iStack_20 = func_855bda08ed604fb4(iStack_1c,auStack_46,0xd,0), iStack_20 != -1)\n        ) && (iStack_20 != 0)) {\n      auStack_46[iStack_20] = 0;\n      iStack_c = func_287845373add424f(auStack_46);\n    }\n  }\n  if (iStack_1c != -1) {\n    func_b8ea3bcdc80a45fb(iStack_1c);\n  }\n  puStack_28 = (undefined4 *)func_f4e7d9f9d7d64366((long)iStack_c << 2);\n  for (uStack_18 = 0; uStack_18 < (ulong)(long)iStack_c; uStack_18 = uStack_18 + 1) {\n    puStack_28[uStack_18] = 0;\n  }\n  func_d8dd84b091da4e28(*puStack_28);\n  func_dd863b0d0a7747c0(puStack_28);\n  return;\n}\n\n",
        "\nvoid func_0f7997d6828b4c08(void)\n\n{\n  func_32ecce26bd9b4598();\n  func_63219a0474684cd2();\n  func_a9ff5487a75a4ca9();\n  func_87faeefffa4849ab();\n  return;\n}\n\n",
        "\nvoid func_82cfc92a13874763(void)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = (undefined *)func_adc758db3bd24f59(0x32);\n  *puVar1 = 0;\n  func_956ff75c9f504b3e(puVar1);\n  return;\n}\n\n",
        "\nvoid func_26f9db6fe393476d(void)\n\n{\n  func_0d0e6f1c437e4ef1();\n  func_a588016f934d4226();\n  return;\n}\n\n",
        "\nvoid func_f8396ef875e94e26(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined4 uStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_14 = 0;\n  iStack_c = 0xffffffff;\n  iStack_c = func_5b5c48b7d78a4ee9(2,1,6);\n  if (iStack_c != -1) {\n    func_f0df8e60af2d40e6(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_8742b78c2cd2455b(&UNK_00401474);\n    uStack_26 = func_639dfe36d4334ca2(0x6987);\n    iVar1 = func_75249e5252934626(iStack_c,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_10 = func_f3c7982da9454028(iStack_c,auStack_36,0xd,0), iStack_10 != -1))\n       && (iStack_10 != 0)) {\n      auStack_36[iStack_10] = 0;\n      uStack_14 = func_66eb764df6c245b7(auStack_36);\n    }\n  }\n  if (iStack_c != -1) {\n    func_d3962ae93c9a4aca(iStack_c);\n  }\n  func_f37f6e60f0ff4c34(&uStack_14);\n  return;\n}\n\n",
        "\nvoid func_82b42f670e0a4c32(void)\n\n{\n  func_28bf2d9017034682();\n  return;\n}\n\n",
        "\nvoid func_219de571b4ad4548(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_b8a046f6de874bed(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lVar1 = func_1d543dc531364867((long)puStack_10 + lStack_18,100 - (int)lStack_18,stdin);\n    if (lVar1 == 0) {\n      func_179e50d6192048a9(&UNK_004013d4);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    else {\n      lStack_18 = func_b8a046f6de874bed(puStack_10);\n      if ((lStack_18 != 0) && (*(char *)((long)puStack_10 + lStack_18 + -1) == '\\n')) {\n        *(undefined *)((long)puStack_10 + lStack_18 + -1) = 0;\n      }\n    }\n  }\n  func_3b63fc8ac73e4f0e(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_bea869ee799b46e8(void)\n\n{\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  func_6f541e466ea54cbc(stdin,&UNK_004013a4,&uStack_10);\n  func_8e030ac204624f41(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_5bb6ebd763b54074(void)\n\n{\n  func_8110c8c511f84aca();\n  func_a6cfe8c4c0834218();\n  return;\n}\n\n",
        "\nvoid func_4da0f5e97aac4a0b(void)\n\n{\n  long lVar1;\n  \n  lVar1 = func_1ef7d8a33b9c494d(0x20);\n  *(undefined **)(lVar1 + 0x10) = &UNK_00401224;\n  func_db71698b420f4896(*(undefined8 *)(lVar1 + 0x10));\n  func_bcdd7029e3224aa8(lVar1,&UNK_00401224,0x20);\n  *(undefined *)(lVar1 + 0xf) = 0;\n  func_db71698b420f4896(lVar1);\n  func_db71698b420f4896(*(undefined8 *)(lVar1 + 0x10));\n  func_d45b3355dd9e4abf(lVar1);\n  return;\n}\n\n",
        "\nvoid func_e476bcb82eaf4561(void)\n\n{\n  undefined uStack_b;\n  undefined uStack_a;\n  char cStack_9;\n  \n  cStack_9 = 0x20;\n  uStack_b = func_79afcec7bf9f46e8(stdin);\n  uStack_a = 0;\n  cStack_9 = func_02f0d6679cfe4173(&uStack_b);\n  func_b61756e679cf4db8((int)cStack_9);\n  return;\n}\n\n",
        "\nvoid func_784cd30a97ee4f8d(void)\n\n{\n  undefined auStack_60 [32];\n  undefined auStack_40 [32];\n  undefined *puStack_20;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_20 = auStack_40;\n  puStack_18 = auStack_60;\n  auStack_40[0] = 0;\n  puStack_10 = puStack_20;\n  func_0f3ade1ca76a4598(puStack_20,0x10,2);\n  return;\n}\n\n",
        "\n/* WARNING: Removing unreachable block (ram,0x00400c8d) */\n\nvoid func_e6a61765b699431c(void)\n\n{\n  long lVar1;\n  int iStack_10;\n  \n  if (GLOBAL_CONST_TRUE != 0) {\n    lVar1 = func_fffddb7573be40a0(0x28);\n    for (iStack_10 = 0; iStack_10 < 10; iStack_10 = iStack_10 + 1) {\n      *(undefined4 *)(lVar1 + (long)iStack_10 * 4) = 0;\n    }\n    *(undefined4 *)(lVar1 + 0x28) = 1;\n    for (iStack_10 = 0; iStack_10 < 10; iStack_10 = iStack_10 + 1) {\n      func_a9a6d7245abf4a8d(*(undefined4 *)(lVar1 + (long)iStack_10 * 4));\n    }\n    func_e9166317bd184e49(lVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_285baf2c6a124386(void)\n\n{\n  undefined8 uVar1;\n  undefined auStack_88 [99];\n  undefined uStack_25;\n  long lStack_18;\n  long lStack_10;\n  \n  lStack_10 = 0;\n  lStack_18 = func_56e6533eef5a4fd2(100);\n  func_22cbcbba57c541ca(lStack_18,0x41,99);\n  *(undefined *)(lStack_18 + 99) = 0;\n  lStack_10 = lStack_18 + -8;\n  func_22cbcbba57c541ca(auStack_88,0x43,99);\n  uStack_25 = 0;\n  uVar1 = func_8bd2e13a58464c1c(auStack_88);\n  func_3a4d4c362afb4002(auStack_88,lStack_10,uVar1);\n  uStack_25 = 0;\n  func_64f7080065fd42ce(auStack_88);\n  return;\n}\n\n",
        "\nvoid func_5214bd30a6fe4f23(long param_1)\n\n{\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  undefined8 uStack_10;\n  \n  uStack_10 = *(undefined8 *)(param_1 + 0x10);\n  func_4ff6fb38f72e42e1(auStack_78,0x43,99);\n  uStack_15 = 0;\n  func_ff103759d12b4ada(uStack_10,auStack_78);\n  func_fb04921c0d044d09(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_ff40c9e8e1274d50(undefined8 param_1)\n\n{\n  func_65b5bfd5daa54731(param_1);\n  return;\n}\n\n",
        "\nvoid func_c5b3183d2c24455b(void)\n\n{\n  func_894f191f3d3344bb();\n  return;\n}\n\n",
        "\nundefined8 * CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_22_badSource(undefined8 *param_1)\n\n{\n  undefined8 *puStack_10;\n  \n  puStack_10 = param_1;\n  if (CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_22_badGlobal != 0) {\n    puStack_10 = (undefined8 *)func_ee0bd61de2a44934(8);\n    *puStack_10 = 0x7ffffffb;\n  }\n  return puStack_10;\n}\n\n",
        "\nvoid func_edd8163cb2b94394(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)func_d6a59be9786e41bc(8);\n  puVar1 = (undefined8 *)*puVar2;\n  func_5e225e0864b4463b(puVar2);\n  func_f3fad5858c8f40a4(*puVar1);\n  return;\n}\n\n",
        "\nvoid func_e4f46005563d49bf(void)\n\n{\n  int iVar1;\n  undefined2 uStack_b8;\n  undefined2 uStack_b6;\n  undefined4 uStack_b4;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_c;\n  \n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_18 = &uStack_a8;\n  iStack_1c = 0xffffffff;\n  iStack_c = -1;\n  lStack_28 = func_0caf9287b2aa4d0f(puStack_18);\n  iStack_1c = func_9b5ecf7a8de84081(2,1,6);\n  if (iStack_1c != -1) {\n    func_b2cab6b8e1b24970(&uStack_b8,0,0x10);\n    uStack_b8 = 2;\n    uStack_b4 = 0;\n    uStack_b6 = func_79093f8539ac47d2(0x6987);\n    iVar1 = func_f4568908decb4f30(iStack_1c,&uStack_b8,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_2e6ddd4b387e4dc5(iStack_1c,5), iVar1 != -1)) &&\n        (iStack_c = func_c7ffefc549ed4d5d(iStack_1c,0,0), iStack_c != -1)) &&\n       ((iStack_2c = func_cc71121f70c141d4(iStack_c,(long)puStack_18 + lStack_28,99 - lStack_28,0),\n        iStack_2c != -1 && (iStack_2c != 0)))) {\n      *(undefined *)((long)puStack_18 + iStack_2c + lStack_28) = 0;\n      puStack_38 = (undefined *)func_9ddfe6c366f546ad(puStack_18,0xd);\n      if (puStack_38 != (undefined *)0x0) {\n        *puStack_38 = 0;\n      }\n      puStack_38 = (undefined *)func_9ddfe6c366f546ad(puStack_18,10);\n      if (puStack_38 != (undefined *)0x0) {\n        *puStack_38 = 0;\n      }\n    }\n  }\n  if (iStack_1c != -1) {\n    func_c750fd03380e4064(iStack_1c);\n  }\n  if (iStack_c != -1) {\n    func_c750fd03380e4064(iStack_c);\n  }\n  func_b957459720cc4fb4(puStack_18,puStack_18);\n  return;\n}\n\n",
        "\nvoid func_c7b426ad12de4c3b(undefined8 param_1)\n\n{\n  func_4077a26cd95b426e(param_1,param_1);\n  return;\n}\n\n",
        "\nvoid func_4d024059a59143cb(int param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_676857dad8234e05(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (param_1 < 100) {\n    func_2c0923b8d4c143e1(&uStack_78,auStack_e8,(long)param_1);\n    *(undefined *)((long)&uStack_78 + (long)param_1) = 0;\n  }\n  func_73fb5e3e926b43df(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_40438180afc24c66(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined4 uStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_18 = 0xffffffff;\n  iStack_10 = 0xffffffff;\n  iStack_c = -1;\n  iStack_10 = func_02af9076920d4450(2,1,6);\n  if (iStack_10 != -1) {\n    func_50e69b09570a44ac(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_37231ea22bc342ca(0x6987);\n    iVar1 = func_51594752b3914af4(iStack_10,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_9800e9d272c747e9(iStack_10,5), iVar1 != -1)) &&\n        (iStack_c = func_bb09ae85dd034191(iStack_10,0,0), iStack_c != -1)) &&\n       ((iStack_14 = func_b2bf9584f5374f75(iStack_c,auStack_36,0xd,0), iStack_14 != -1 && (iStack_14 != 0)\n        ))) {\n      auStack_36[iStack_14] = 0;\n      uStack_18 = func_0fb55154a7464425(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_277e98fa74044a8d(iStack_10);\n  }\n  if (iStack_c != -1) {\n    func_277e98fa74044a8d(iStack_c);\n  }\n  func_f71a836b3d9646a3(&uStack_18);\n  return;\n}\n\n",
        "\nvoid func_10375eac9dec4ee4(void)\n\n{\n  undefined auStack_88 [112];\n  ulong uStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = (undefined *)0x0;\n  if (globalTrue != 0) {\n    puStack_10 = (undefined *)func_da56587c0c794e7b(0x32);\n    *puStack_10 = 0;\n  }\n  func_0f849eae38044819(auStack_88,0x43,99);\n  auStack_88[99] = 0;\n  for (uStack_18 = 0; uStack_18 < 100; uStack_18 = uStack_18 + 1) {\n    puStack_10[uStack_18] = auStack_88[uStack_18];\n  }\n  puStack_10[99] = 0;\n  func_fbd8fe17cf344f0a(puStack_10);\n  func_1731b76bcf50455a(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_0baacfff44a24e80(long param_1)\n\n{\n  func_6539477def0a46b7(&UNK_004016cb,&UNK_004016cb,&UNK_004016c8,&UNK_004016c4,\n                  *(undefined8 *)(param_1 + 0x10),0);\n  return;\n}\n\n",
        "\nvoid func_0cf6ecd6321e4841(char *param_1)\n\n{\n  char *pcStack_10;\n  \n  pcStack_10 = param_1;\n  do {\n    if (*pcStack_10 == '\\0') {\ncode_r0x00400d17:\n      func_f47ce6adc87d4906(pcStack_10);\n      return;\n    }\n    if (*pcStack_10 == 'S') {\n      func_3bf2b184f9c9418e(&UNK_00401384);\n      goto code_r0x00400d17;\n    }\n    pcStack_10 = pcStack_10 + 1;\n  } while( true );\n}\n\n",
        "\nvoid func_f1805e074d124358(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  if (CWE121_Stack_Based_Buffer_Overflow__CWE135_22_goodG2BGlobal != 0) {\n    lVar1 = func_777f6dc0189e4ad7(param_1);\n    uVar2 = func_17944f3eb7a8440d(lVar1 + 1,1);\n    func_a872cccc2d524232(uVar2,param_1,lVar1 + 1);\n    func_4769155bff174a37(uVar2);\n    func_3f7347d07de1417a(uVar2);\n  }\n  return;\n}\n\n",
        "\nvoid func_54ac5d3695cb474f(undefined8 param_1)\n\n{\n  func_cf9cef98bf1d49db(param_1);\n  return;\n}\n\n",
        "\nvoid func_1695f457371f4b1c(undefined8 *param_1)\n\n{\n  int iVar1;\n  int iStack_24;\n  undefined8 uStack_20;\n  undefined8 *puStack_18;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_20 = *param_1;\n  puStack_18 = param_1;\n  iVar1 = func_acdadba97c584e8a(uStack_20,&UNK_004015e4,&iStack_24);\n  if (iVar1 == 1) {\n    iStack_10 = 0;\n    for (iStack_c = 0; iStack_c < iStack_24; iStack_c = iStack_c + 1) {\n      iStack_10 = iStack_10 + 1;\n    }\n    func_beb2ced5e5644442(iStack_10);\n  }\n  return;\n}\n\n",
        "\nundefined4\nfunc_bdef37590a4a441f(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uStack_3c;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_10 = 0xffffffff;\n  iStack_c = -1;\n  iStack_10 = func_550ff7f2bc484a7d(2,1,6);\n  uStack_3c = param_1;\n  if (iStack_10 != -1) {\n    func_41cda48ea5054d42(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_aad1d3a86efc4d5c(0x6987);\n    iVar1 = func_492a3c1fe6804971(iStack_10,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_485045b2d47246c9(iStack_10,5), iVar1 != -1)) &&\n        (iStack_c = func_85fe5ae4e83147df(iStack_10,0,0), iStack_c != -1)) &&\n       ((iStack_14 = func_9c2efead35864892(iStack_c,auStack_36,0xd,0), iStack_14 != -1 && (iStack_14 != 0)\n        ))) {\n      auStack_36[iStack_14] = 0;\n      uStack_3c = func_5fa1b7362db64a94(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_179ee84bd83a4975(iStack_10);\n  }\n  if (iStack_c != -1) {\n    func_179ee84bd83a4975(iStack_c);\n  }\n  return uStack_3c;\n}\n\n",
        "\nvoid func_419170566db04d5f(void)\n\n{\n  undefined auStack_290 [416];\n  undefined auStack_f0 [208];\n  undefined *puStack_20;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_f0;\n  puStack_18 = auStack_290;\n  func_b4a94daf625e459f(puStack_10,0x41,0x31);\n  *(undefined4 *)(puStack_10 + 0xc4) = 0;\n  func_b4a94daf625e459f(puStack_18,0x41,99);\n  *(undefined4 *)(puStack_18 + 0x18c) = 0;\n  puStack_20 = puStack_10;\n  func_419170566db04d5fData = puStack_10;\n  func_259a6c8545bf4b15();\n  return;\n}\n\n",
        "\nvoid func_b2606a7311c64938(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  int iStack_1ec;\n  undefined2 uStack_1e8;\n  undefined2 uStack_1e6;\n  undefined4 uStack_1e4;\n  undefined8 uStack_1d8;\n  undefined8 uStack_1d0;\n  undefined8 auStack_1c8 [49];\n  undefined4 *puStack_40;\n  int iStack_34;\n  long lStack_30;\n  int iStack_24;\n  undefined8 *puStack_20;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_1d8 = 0;\n  uStack_1d0 = 0;\n  puVar3 = auStack_1c8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_20 = &uStack_1d8;\n  if (globalFive == 5) {\n    iStack_24 = 0xffffffff;\n    iStack_c = -1;\n    lStack_30 = func_9a3a11d26dbf4ff3(puStack_20);\n    iStack_24 = func_21432b30bc6d4d73(2,1,6);\n    if (iStack_24 != -1) {\n      func_196043fe23c54495(&uStack_1e8,0,0x10);\n      uStack_1e8 = 2;\n      uStack_1e4 = 0;\n      uStack_1e6 = func_ecb86cf6f22b479b(0x6987);\n      iVar1 = func_411253cc3a88498a(iStack_24,&uStack_1e8,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_8f4103f335d149ef(iStack_24,5), iVar1 != -1)) &&\n          (iStack_c = func_a07d5f7fb03e489d(iStack_24,0,0), iStack_c != -1)) &&\n         ((iStack_34 = func_e9cc78160cfa46e9(iStack_c,lStack_30 * 4 + (long)puStack_20,\n                                       (99 - lStack_30) * 4,0), iStack_34 != -1 && (iStack_34 != 0))\n         )) {\n        *(undefined4 *)((long)puStack_20 + (lStack_30 + ((ulong)(long)iStack_34 >> 2)) * 4) = 0;\n        puStack_40 = (undefined4 *)func_9d916cefc12b43a0(puStack_20,0xd);\n        if (puStack_40 != (undefined4 *)0x0) {\n          *puStack_40 = 0;\n        }\n        puStack_40 = (undefined4 *)func_9d916cefc12b43a0(puStack_20,10);\n        if (puStack_40 != (undefined4 *)0x0) {\n          *puStack_40 = 0;\n        }\n      }\n    }\n    if (iStack_24 != -1) {\n      func_9529e0046770482d(iStack_24);\n    }\n    if (iStack_c != -1) {\n      func_9529e0046770482d(iStack_c);\n    }\n  }\n  if ((globalFive == 5) &&\n     (iVar1 = func_05ce5672a69c4e1e(puStack_20,&UNK_00401654,&iStack_1ec), iVar1 == 1)) {\n    iStack_14 = 0;\n    for (iStack_10 = 0; iStack_10 < iStack_1ec; iStack_10 = iStack_10 + 1) {\n      iStack_14 = iStack_14 + 1;\n    }\n    func_6200dd9eb5b248fe(iStack_14);\n  }\n  return;\n}\n\n",
        "\nvoid func_985e635f08bd4123(long param_1)\n\n{\n  undefined auStack_198 [396];\n  undefined4 uStack_c;\n  \n  func_7bceff7009e748b1(auStack_198,0x43,99);\n  uStack_c = 0;\n  func_2902144586f14309(param_1,auStack_198,99);\n  *(undefined4 *)(param_1 + 0x18c) = 0;\n  func_0e8e4d5d5a8d4de3(param_1);\n  return;\n}\n\n",
        "\nvoid func_4a820e983dfa4d6f(ulong param_1)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  \n  if (CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_22_badGlobal != 0) {\n    uVar1 = func_714add2e2d764c5a(&UNK_00401698);\n    if (uVar1 < param_1) {\n      uVar2 = func_46baa75964ca4473(param_1 << 2);\n      func_cf8ef309e9a24c1b(uVar2,&UNK_00401698);\n      func_70bf8042671b4588(uVar2);\n      func_da06823cc6704609(uVar2);\n    }\n    else {\n      func_a07dfc4003234186(&UNK_004016b0);\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_03a4baa4634c421d(undefined8 param_1)\n\n{\n  func_965154e87cd74ac4(param_1);\n  return;\n}\n\n",
        "\nvoid func_02f5c9ceaa2a46bf(void)\n\n{\n  int iVar1;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  if (GLOBAL_CONST_FIVE == 5) {\n    iStack_10 = 0xffffffff;\n    iStack_10 = func_fd58f63921914eeb(2,1,6);\n    if (iStack_10 != -1) {\n      func_1bc43623be654775(&uStack_28,0,0x10);\n      uStack_28 = 2;\n      uStack_24 = func_f93736bade7b43ce(&UNK_00401498);\n      uStack_26 = func_22d31df0240c4afb(0x6987);\n      iVar1 = func_e9491739dbf54644(iStack_10,&uStack_28,0x10);\n      if (iVar1 != -1) {\n        iStack_14 = func_60f9a0594aee4f5e(iStack_10,auStack_36,0xd,0);\n        if ((iStack_14 != -1) && (iStack_14 != 0)) {\n          auStack_36[iStack_14] = 0;\n          iStack_c = func_3af0cf5f46bf4b45(auStack_36);\n        }\n      }\n    }\n    if (iStack_10 != -1) {\n      func_7692fb2418fc4878(iStack_10);\n    }\n  }\n  if (GLOBAL_CONST_FIVE == 5) {\n    uStack_68 = 0;\n    uStack_60 = 0;\n    uStack_58 = 0;\n    uStack_50 = 0;\n    uStack_48 = 0;\n    if (iStack_c < 0) {\n      func_4f7830968e31444a(&UNK_004014a8);\n    }\n    else {\n      func_cf90ffe2781a48bd(*(undefined4 *)((long)&uStack_68 + (long)iStack_c * 4));\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_61a0385a67814491(void)\n\n{\n  undefined4 *puVar1;\n  \n  if (staticTrue != 0) {\n    puVar1 = (undefined4 *)func_26f0af8f085f4725(8);\n    *puVar1 = 5;\n    func_cc334ac2a2da4137(*puVar1);\n    func_691bd2b4c071455e(puVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_68384024588545e3(void)\n\n{\n  func_b6f73fedaa04489b();\n  return;\n}\n\n",
        "\nvoid func_8ed2f531cf27458e(void)\n\n{\n  int iVar1;\n  long lVar2;\n  int iStack_8c;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_20;\n  undefined8 *puStack_18;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_18 = &uStack_88;\n  lStack_20 = func_e2fa748667f54030(puStack_18);\n  if (1 < 100U - lStack_20) {\n    lVar2 = func_f3d68c8326084278((long)puStack_18 + lStack_20,100 - (int)lStack_20,stdin);\n    if (lVar2 == 0) {\n      func_438958d50e384526(&UNK_00401328);\n      *(undefined *)(lStack_20 + (long)puStack_18) = 0;\n    }\n    else {\n      lStack_20 = func_e2fa748667f54030(puStack_18);\n      if ((lStack_20 != 0) && (*(char *)((long)puStack_18 + lStack_20 + -1) == '\\n')) {\n        *(undefined *)((long)puStack_18 + lStack_20 + -1) = 0;\n      }\n    }\n  }\n  iVar1 = func_dcee672f57bd463f(puStack_18,&UNK_00401337,&iStack_8c);\n  if (iVar1 == 1) {\n    iStack_10 = 0;\n    for (iStack_c = 0; iStack_c < iStack_8c; iStack_c = iStack_c + 1) {\n      iStack_10 = iStack_10 + 1;\n    }\n    func_b8e291b3ee9247f7(iStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_33d6654bb4ef496c(void)\n\n{\n  long lVar1;\n  undefined8 uStack_36;\n  undefined4 uStack_2e;\n  undefined2 uStack_2a;\n  undefined auStack_28 [8];\n  undefined4 uStack_20;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  uStack_36 = 0;\n  uStack_2e = 0;\n  uStack_2a = 0;\n  lVar1 = func_85739d5262784796(&uStack_36,0xe,stdin);\n  if (lVar1 == 0) {\n    func_bc1fd2068f1442ea(&UNK_00401264);\n  }\n  else {\n    uStack_c = func_005dff88fa3143e8(&uStack_36);\n  }\n  uStack_20 = uStack_c;\n  func_847773b171044b39(auStack_28);\n  return;\n}\n\n",
        "\nvoid func_d240b76efbac4405(void)\n\n{\n  func_b0c94e2bd89d464d();\n  return;\n}\n\n",
        "\nvoid func_00557f68e84d44ad(void)\n\n{\n  int iVar1;\n  undefined2 uStack_48;\n  undefined2 uStack_46;\n  undefined4 uStack_44;\n  undefined8 ****ppppuStack_38;\n  undefined8 ****ppppuStack_30;\n  undefined8 ****ppppuStack_28;\n  undefined8 ****ppppuStack_20;\n  undefined4 uStack_10;\n  int iStack_c;\n  \n  ppppuStack_28 = &ppppuStack_38;\n  ppppuStack_20 = &ppppuStack_38;\n  ppppuStack_38 = &ppppuStack_28;\n  ppppuStack_30 = &ppppuStack_28;\n  iStack_c = 0xffffffff;\n  iStack_c = func_0b553258cc764541(2,1,6);\n  if (iStack_c != -1) {\n    func_6d81cef01b054b82(&uStack_48,0,0x10);\n    uStack_48 = 2;\n    uStack_44 = func_29cca9b0b05b4cc1(&UNK_0040143c);\n    uStack_46 = func_c2ed7476febe4c6e(0x6987);\n    iVar1 = func_c779b027e7fc4b94(iStack_c,&uStack_48,0x10);\n    if (iVar1 != -1) {\n      uStack_10 = func_9419860231454cec(iStack_c,&ppppuStack_28,0x10,0);\n    }\n  }\n  if (iStack_c != -1) {\n    func_09b9f4704e3b4350(iStack_c);\n  }\n  linkedListPrev = ppppuStack_20;\n  linkedListNext = ppppuStack_28;\n  *ppppuStack_20 = ppppuStack_28;\n  linkedListNext[1] = linkedListPrev;\n  return;\n}\n\n",
        "\nvoid func_e16f4daf4d1f42ca(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = func_d89bd8e1f2b94063(400);\n  func_57d78ff6a50f420a(uVar1);\n  return;\n}\n\n",
        "\nvoid func_fe215ea26d8b4196(void)\n\n{\n  int iVar1;\n  undefined2 uStack_b8;\n  undefined2 uStack_b6;\n  undefined4 uStack_b4;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_c;\n  \n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_18 = &uStack_a8;\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    iStack_1c = 0xffffffff;\n    lStack_28 = func_e1b5792aeec7429c(puStack_18);\n    iStack_1c = func_0a91bbbc17944af8(2,1,6);\n    if (iStack_1c != -1) {\n      func_15a7750620fe4978(&uStack_b8,0,0x10);\n      uStack_b8 = 2;\n      uStack_b4 = func_9ef54596679a43a1(&UNK_00401604);\n      uStack_b6 = func_61a55df7ff854bb3(0x6987);\n      iVar1 = func_1c000f72abc042c3(iStack_1c,&uStack_b8,0x10);\n      if (((iVar1 != -1) &&\n          (iStack_2c = func_a6e429be0cb74b2e(iStack_1c,(long)puStack_18 + lStack_28,99 - lStack_28,0),\n          iStack_2c != -1)) && (iStack_2c != 0)) {\n        *(undefined *)((long)puStack_18 + iStack_2c + lStack_28) = 0;\n        puStack_38 = (undefined *)func_aec1c2d4a9854157(puStack_18,0xd);\n        if (puStack_38 != (undefined *)0x0) {\n          *puStack_38 = 0;\n        }\n        puStack_38 = (undefined *)func_aec1c2d4a9854157(puStack_18,10);\n        if (puStack_38 != (undefined *)0x0) {\n          *puStack_38 = 0;\n        }\n      }\n    }\n    if (iStack_1c != -1) {\n      func_5f3833535a244a3c(iStack_1c);\n    }\n  }\n  func_5eb519816d4a4f72(&UNK_00401615,&UNK_00401615,&UNK_00401612,&UNK_0040160e,puStack_18,0);\n  return;\n}\n\n",
        "\nvoid func_5de9c332eecb4748(void)\n\n{\n  int iVar1;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_18 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_18 = func_6d568e8e56854e96(2,1,6);\n  if (iStack_18 != -1) {\n    func_27a397dee6414100(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_6baf7ad4a6324e6b(0x6987);\n    iVar1 = func_48f5a06151804248(iStack_18,&uStack_38,0x10);\n    if ((iVar1 != -1) && (iVar1 = func_eb109b47f4ec4e4b(iStack_18,5), iVar1 != -1)) {\n      iStack_10 = func_2928c3d263d94979(iStack_18,0,0);\n      if (iStack_10 != -1) {\n        iStack_1c = func_536665ad87574a1c(iStack_10,auStack_46,0xd,0);\n        if ((iStack_1c != -1) && (iStack_1c != 0)) {\n          auStack_46[iStack_1c] = 0;\n          iStack_c = func_f72a9b3335284a5d(auStack_46);\n        }\n      }\n    }\n  }\n  if (iStack_18 != -1) {\n    func_961e5b5cb22a418d(iStack_18);\n  }\n  if (iStack_10 != -1) {\n    func_961e5b5cb22a418d(iStack_10);\n  }\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  if (iStack_c < 10) {\n    *(undefined4 *)((long)&uStack_78 + (long)iStack_c * 4) = 1;\n    for (iStack_14 = 0; iStack_14 < 10; iStack_14 = iStack_14 + 1) {\n      func_60b80df1e5c2480a(*(undefined4 *)((long)&uStack_78 + (long)iStack_14 * 4));\n    }\n  }\n  else {\n    func_a034508945b44689(&UNK_00401538);\n  }\n  return;\n}\n\n",
        "\nvoid func_d67218ef5c9f46df(void)\n\n{\n  func_1a5e4e58969e4e24();\n  func_f6c55254cd2e4aeb();\n  return;\n}\n\n",
        "\nvoid func_b6a6913c4c5a49ee(void)\n\n{\n  func_bcf5551a7cbe4e2f();\n  func_ffe6f9ab536a4128();\n  return;\n}\n\n",
        "\nvoid func_32fa0f3f58ac4aa6(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iVar1 = func_3d551d01b55346c6();\n  if (iVar1 != 0) {\n    iStack_10 = 0xffffffff;\n    iStack_10 = func_ff47d7b2f0944a88(2,1,6);\n    if (iStack_10 != -1) {\n      func_c8d3f6fa902b4eff(&uStack_28,0,0x10);\n      uStack_28 = 2;\n      uStack_24 = func_3cbe16bf8ef2427b(&UNK_00401584);\n      uStack_26 = func_873b8a953e0a4035(0x6987);\n      iVar1 = func_972b357d949a4444(iStack_10,&uStack_28,0x10);\n      if (((iVar1 != -1) &&\n          (iStack_14 = func_eec3fcbcf2d049ec(iStack_10,auStack_36,0xd,0), iStack_14 != -1)) &&\n         (iStack_14 != 0)) {\n        auStack_36[iStack_14] = 0;\n        iStack_c = func_d81f625c8dde4e49(auStack_36);\n      }\n    }\n    if (iStack_10 != -1) {\n      func_7c3c480ca2114138(iStack_10);\n    }\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_c8d3f6fa902b4eff(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_b9fbdff06dd640c4(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_bba9910c45a34c15(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_1a87e290452c4455(undefined4 param_1)\n\n{\n  func_94d3e04735774348(param_1);\n  return;\n}\n\n",
        "\nvoid func_893870d5dc114206(void)\n\n{\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)0x0;\n  puStack_10 = (undefined4 *)func_8f61b40432da43ee(200);\n  *puStack_10 = 0;\n  func_22a54c79c8584032(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_bf940c8c4a254004(puStack_10,auStack_1a8,99);\n  puStack_10[99] = 0;\n  func_496a8a33b7424df5(puStack_10);\n  func_3be8b80214f0493f(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_f2e60f569f534726(void)\n\n{\n  int iVar1;\n  undefined auStack_58 [32];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  undefined8 uStack_20;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_20 = 0;\n  iStack_10 = 0xffffffff;\n  iStack_c = -1;\n  iStack_10 = func_6df0a4c2a6c041ed(2,1,6);\n  if (iStack_10 != -1) {\n    func_b60ddb2f2c644252(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_b2ed8641885c4801(0x6987);\n    iVar1 = func_7db7d5db8bd14031(iStack_10,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_178ff4c6acf64b8b(iStack_10,5), iVar1 != -1)) &&\n        (iStack_c = func_d588ca71862d42a4(iStack_10,0,0), iStack_c != -1)) &&\n       ((iStack_14 = func_cc27914d2d24466c(iStack_c,auStack_58,0x19,0), iStack_14 != -1 &&\n        (iStack_14 != 0)))) {\n      auStack_58[iStack_14] = 0;\n      uStack_20 = func_3792564531ae4284(auStack_58,0,0);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_e8aeee4695cc440f(iStack_10);\n  }\n  if (iStack_c != -1) {\n    func_e8aeee4695cc440f(iStack_c);\n  }\n  func_fe7b0a3bf57a4b89(&uStack_20);\n  return;\n}\n\n",
        "\nvoid func_c0f39e3e15f14eac(void)\n\n{\n  undefined1 *puStack_10;\n  \n  puStack_10 = (undefined1 *)0x0;\n  func_d648c409bd9f40f7(dataBuffer_3779,0x41,99);\n  dataBuffer_3779[99] = 0;\n  puStack_10 = dataBuffer_3779;\n  func_22efbfe0c18842a9(&puStack_10);\n  return;\n}\n\n",
        "\nvoid func_127b64a6edf7447a(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  byte bVar4;\n  undefined8 auStack_7e8 [100];\n  undefined8 auStack_4c8 [100];\n  undefined8 auStack_1a8 [51];\n  undefined8 *puStack_10;\n  \n  bVar4 = 0;\n  iVar1 = func_0cac1cf48fcf453c();\n  if (iVar1 == 0) {\n    puStack_10 = auStack_4c8;\n  }\n  else {\n    puStack_10 = auStack_1a8;\n  }\n  puVar3 = auStack_7e8;\n  for (lVar2 = 100; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n  }\n  func_b6e8fdc7723c4162(puStack_10,auStack_7e8,800);\n  func_42909cff0e7546dd(*puStack_10);\n  return;\n}\n\n",
        "\nvoid func_8d154bccca304d51(void)\n\n{\n  long lVar1;\n  undefined8 uStack_1b;\n  undefined2 uStack_13;\n  undefined uStack_11;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  uStack_10 = func_4ffaf8649e80431c(10);\n  uStack_1b = 0x4141414141414141;\n  uStack_13 = 0x4141;\n  uStack_11 = 0;\n  lVar1 = func_795d748016c3411f(&uStack_1b);\n  func_529d880fa5904c45(uStack_10,&uStack_1b,lVar1 + 1);\n  func_135cd044cd0546de(uStack_10);\n  func_a1f2dab027e14b43(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_626725ad4c904970(void)\n\n{\n  undefined4 *puVar1;\n  ulong uStack_18;\n  int iStack_c;\n  \n  iStack_c = -1;\n  if (staticTrue != 0) {\n    iStack_c = 0x40000001;\n  }\n  puVar1 = (undefined4 *)func_41a811b5b5524304((long)iStack_c << 2);\n  for (uStack_18 = 0; uStack_18 < (ulong)(long)iStack_c; uStack_18 = uStack_18 + 1) {\n    puVar1[uStack_18] = 0;\n  }\n  func_e412059e2f5343f6(*puVar1);\n  func_fbe4bf7774af4a2a(puVar1);\n  return;\n}\n\n",
        "\nvoid func_4e2579f4d93543d6(undefined8 param_1)\n\n{\n  func_cd8464320c6f45ef(param_1);\n  return;\n}\n\n",
        "\nvoid func_3344d05e5c364c6c(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_1e0d40e510074322(2,1,6);\n  if (iStack_14 != -1) {\n    func_7aee44f101444d7f(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_600a20412ebf414d(0x6987);\n    iVar1 = func_b3b8b5a26ba44d9f(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_09de73e9a8ae4ddd(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_e72d852430574ab5(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_8a825a5aecef4889(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      uStack_c = func_92152ebb13ed48aa(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_db6d054d0ef64d8b(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_db6d054d0ef64d8b(iStack_10);\n  }\n  func_3344d05e5c364c6cGlobal = 1;\n  func_4391d6bdcbd24209(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_42ac92a87234408b(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_30 [32];\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_30;\n  func_ba56d54990914edb(&puStack_10,param_2,1);\n  return;\n}\n\n",
        "\nvoid func_4ae05a1154fa4ad7(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_077e83b77ab34b51(2,1,6);\n  if (iStack_14 != -1) {\n    func_c22164573fa74655(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_e5a11e8796a34c33(0x6987);\n    iVar1 = func_761e09d28f2d4fd7(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_44fa2a50650b45d2(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_383e6ae9b71d47a1(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_e10565c4e93548eb(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      uStack_c = func_41fbbfc957864d74(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_b3d8bdcc97164f48(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_b3d8bdcc97164f48(iStack_10);\n  }\n  func_9ad9d6e9748744cd(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_b945282f1ada4b22(int param_1)\n\n{\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined8 uStack_18;\n  int iStack_c;\n  \n  if (CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22_badGlobal != 0) {\n    uStack_38 = 0;\n    uStack_30 = 0;\n    uStack_28 = 0;\n    uStack_20 = 0;\n    uStack_18 = 0;\n    if (param_1 < 0) {\n      func_a35d22818f974443(&UNK_00401568);\n    }\n    else {\n      *(undefined4 *)((long)&uStack_38 + (long)param_1 * 4) = 1;\n      for (iStack_c = 0; iStack_c < 10; iStack_c = iStack_c + 1) {\n        func_e0f4aaa9b7a84370(*(undefined4 *)((long)&uStack_38 + (long)iStack_c * 4));\n      }\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_613af99547874106(undefined8 param_1)\n\n{\n  func_f17ecef4b46544a6(param_1);\n  return;\n}\n\n",
        "\nvoid func_1c993bc3945d4c9d(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_1b8;\n  undefined8 uStack_1b0;\n  undefined8 auStack_1a8 [48];\n  undefined8 *puStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_1b8 = 0;\n  uStack_1b0 = 0;\n  puVar2 = auStack_1a8;\n  for (lVar1 = 0x30; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  puStack_10 = &uStack_1b8;\n  lStack_18 = func_d1258efa133b4f07(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lStack_20 = func_9337a0cf0a2e4a8b(&UNK_00401346,&UNK_00401344);\n    if (lStack_20 != 0) {\n      lVar1 = func_d20b57ad7d144045(lStack_18 * 4 + (long)puStack_10,100 - (int)lStack_18,lStack_20);\n      if (lVar1 == 0) {\n        func_a2b4c8742d004291(&UNK_00401354);\n        *(undefined4 *)((long)puStack_10 + lStack_18 * 4) = 0;\n      }\n      func_3f392486b1524583(lStack_20);\n    }\n  }\n  puStack_28 = puStack_10;\n  func_722224775e7d463d(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_273003daa14146e0(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined2 uStack_1d8;\n  undefined2 uStack_1d6;\n  undefined4 uStack_1d4;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [49];\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_10 = &uStack_1c8;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_0e7bf8ef754e47a1(puStack_10);\n  iStack_14 = func_67e526142e874a50(2,1,6);\n  if (iStack_14 != -1) {\n    func_3c87dc9c7fd84a65(&uStack_1d8,0,0x10);\n    uStack_1d8 = 2;\n    uStack_1d4 = func_5ccf3a8ae0f44dc0(&UNK_00401624);\n    uStack_1d6 = func_16fb6682d4ef4f5e(0x6987);\n    iVar1 = func_39da5a15de9845c3(iStack_14,&uStack_1d8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_66eddac0a06a4263(iStack_14,lStack_20 * 4 + (long)puStack_10,(99 - lStack_20) * 4\n                                     ,0), iStack_24 != -1)) && (iStack_24 != 0)) {\n      *(undefined4 *)((long)puStack_10 + (lStack_20 + ((ulong)(long)iStack_24 >> 2)) * 4) = 0;\n      puStack_30 = (undefined4 *)func_74a7bbfd33f94aac(puStack_10,0xd);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined4 *)func_74a7bbfd33f94aac(puStack_10,10);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_629f721b310944ea(iStack_14);\n  }\n  func_98f9cf5d3cc74521(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_6d45680b9bcb4fad(void)\n\n{\n  int iVar1;\n  undefined2 uStack_d8;\n  undefined2 uStack_d6;\n  undefined4 uStack_d4;\n  undefined8 uStack_c8;\n  undefined8 uStack_c0;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined4 uStack_68;\n  undefined auStack_58 [16];\n  undefined8 *puStack_48;\n  undefined *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_c8 = 0;\n  uStack_c0 = 0;\n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  puStack_10 = &uStack_c8;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_2163975923464875(puStack_10);\n  iStack_14 = func_5a4de808b00f49d0(2,1,6);\n  if (iStack_14 != -1) {\n    func_5c7740a8359e43e2(&uStack_d8,0,0x10);\n    uStack_d8 = 2;\n    uStack_d4 = func_d86c1a6a6e9042f7(&UNK_004016b4);\n    uStack_d6 = func_0ddb3fff9ac84d10(0x6987);\n    iVar1 = func_8f37a5e8a7a14311(iStack_14,&uStack_d8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_00d7072e7a024099(iStack_14,(long)puStack_10 + lStack_20,99 - lStack_20,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      *(undefined *)((long)puStack_10 + iStack_24 + lStack_20) = 0;\n      puStack_30 = (undefined *)func_b1a7e125b9a34844(puStack_10,0xd);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined *)func_b1a7e125b9a34844(puStack_10,10);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_6151d2e81f8547c9(iStack_14);\n  }\n  puStack_48 = puStack_10;\n  func_8756d099b28e4bb8(auStack_58);\n  return;\n}\n\n",
        "\nvoid func_19662f35e472475f(undefined8 param_1)\n\n{\n  func_a18b3e0bbf24465e(param_1);\n  return;\n}\n\n",
        "\nvoid func_3f978e01028f4952(void)\n\n{\n  undefined auStack_118 [112];\n  undefined auStack_a8 [149];\n  undefined uStack_13;\n  int iStack_c;\n  \n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    func_4fd580ccfa9a46a0(auStack_a8,0x41,0x95);\n    uStack_13 = 0;\n    func_c73bf8153fbb42e3(auStack_118,auStack_a8,99);\n    func_217b79ce58cf4480(auStack_118);\n  }\n  return;\n}\n\n",
        "\nvoid func_11dfb30a56fd4f3c(undefined8 param_1)\n\n{\n  func_68a1c386bcb343a1(param_1);\n  func_cc17c9bd93464bb2(param_1);\n  return;\n}\n\n",
        "\nvoid func_89bc8add20ea42aa(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined2 uStack_148;\n  undefined2 uStack_146;\n  undefined4 uStack_144;\n  undefined8 uStack_138;\n  undefined8 uStack_130;\n  undefined8 auStack_128 [30];\n  undefined *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_138 = 0x3d48544150;\n  uStack_130 = 0;\n  puVar3 = auStack_128;\n  for (lVar2 = 0x1d; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  *(undefined2 *)puVar3 = 0;\n  puStack_18 = &uStack_138;\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    iStack_1c = 0xffffffff;\n    iStack_10 = -1;\n    lStack_28 = func_855600e2a77d4868(puStack_18);\n    iStack_1c = func_4df911888ebb46e2(2,1,6);\n    if (iStack_1c != -1) {\n      func_56606b5a620e4c33(&uStack_148,0,0x10);\n      uStack_148 = 2;\n      uStack_144 = 0;\n      uStack_146 = func_3c2b681aa710433f(0x6987);\n      iVar1 = func_c333dc0f839f4a31(iStack_1c,&uStack_148,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_91b3348f08ec46f9(iStack_1c,5), iVar1 != -1)) &&\n          (iStack_10 = func_fc6f61a712b64b5a(iStack_1c,0,0), iStack_10 != -1)) &&\n         ((iStack_2c = func_146df6ca79b747e0(iStack_10,(long)puStack_18 + lStack_28,0xf9 - lStack_28,0),\n          iStack_2c != -1 && (iStack_2c != 0)))) {\n        *(undefined *)((long)puStack_18 + iStack_2c + lStack_28) = 0;\n        puStack_38 = (undefined *)func_3301c4d0b72241cc(puStack_18,0xd);\n        if (puStack_38 != (undefined *)0x0) {\n          *puStack_38 = 0;\n        }\n        puStack_38 = (undefined *)func_3301c4d0b72241cc(puStack_18,10);\n        if (puStack_38 != (undefined *)0x0) {\n          *puStack_38 = 0;\n        }\n      }\n    }\n    if (iStack_1c != -1) {\n      func_f1998a66174f4a8a(iStack_1c);\n    }\n    if (iStack_10 != -1) {\n      func_f1998a66174f4a8a(iStack_10);\n    }\n  }\n  func_30bdffd04d22478f(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_10e9e9323fdd4dab(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined2 uStack_1d8;\n  undefined2 uStack_1d6;\n  undefined4 uStack_1d4;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [49];\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_10 = &uStack_1c8;\n  if (staticFive == 5) {\n    iStack_14 = 0xffffffff;\n    lStack_20 = func_ba1854032f254387(puStack_10);\n    iStack_14 = func_c2c5da24d8304f44(2,1,6);\n    if (iStack_14 != -1) {\n      func_e57012939d0244b7(&uStack_1d8,0,0x10);\n      uStack_1d8 = 2;\n      uStack_1d4 = func_7b971e2c9abd4aa7(&UNK_004015e4);\n      uStack_1d6 = func_0ddb34e224c14142(0x6987);\n      iVar1 = func_1097359599594794(iStack_14,&uStack_1d8,0x10);\n      if (((iVar1 != -1) &&\n          (iStack_24 = func_de9544e34d024884(iStack_14,lStack_20 * 4 + (long)puStack_10,\n                                       (99 - lStack_20) * 4,0), iStack_24 != -1)) &&\n         (iStack_24 != 0)) {\n        *(undefined4 *)((long)puStack_10 + (lStack_20 + ((ulong)(long)iStack_24 >> 2)) * 4) = 0;\n        puStack_30 = (undefined4 *)func_80092e9a08b34b4d(puStack_10,0xd);\n        if (puStack_30 != (undefined4 *)0x0) {\n          *puStack_30 = 0;\n        }\n        puStack_30 = (undefined4 *)func_80092e9a08b34b4d(puStack_10,10);\n        if (puStack_30 != (undefined4 *)0x0) {\n          *puStack_30 = 0;\n        }\n      }\n    }\n    if (iStack_14 != -1) {\n      func_ec1195cb03d44ff2(iStack_14);\n    }\n  }\n  func_a3b7a2e56e0d4b66(&UNK_0040160c,&UNK_0040160c,&UNK_00401600,&UNK_004015f0,puStack_10,0);\n  return;\n}\n\n",
        "\nvoid func_f44efed7191a47f5(int param_1)\n\n{\n  if (param_1 < 0) {\n    func_2d5869168b904528(param_1 * 2);\n  }\n  return;\n}\n\n",
        "\nvoid func_590573b73b9a4281(void)\n\n{\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined4 uStack_20;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  uStack_10 = func_a1c8753e174d4b49(0x28);\n  uStack_48 = 0x4100000041;\n  uStack_40 = 0x4100000041;\n  uStack_38 = 0x4100000041;\n  uStack_30 = 0x4100000041;\n  uStack_28 = 0x4100000041;\n  uStack_20 = 0;\n  func_420b270b49bd4009(uStack_10,&uStack_48);\n  func_cd11f36a1a8a4c21(uStack_10);\n  func_99855347cf1749cd(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_005b8d16ec8144cc(void)\n\n{\n  long lVar1;\n  undefined auStack_f8 [99];\n  undefined uStack_95;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  undefined8 uStack_16;\n  short sStack_e;\n  short sStack_c;\n  short sStack_a;\n  \n  sStack_a = 0;\n  uStack_16 = 0;\n  lVar1 = func_4c25a09a74db4b05(&uStack_16,8,stdin);\n  if (lVar1 == 0) {\n    func_e32e18de0a904e25(&UNK_00401394);\n  }\n  else {\n    sStack_a = func_0d37d15843cb4a75(&uStack_16);\n  }\n  sStack_c = sStack_a;\n  sStack_e = sStack_a;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  func_5def6227ea3a4478(auStack_f8,0x41,99);\n  uStack_95 = 0;\n  if (sStack_e < 100) {\n    func_d40f7b5c30ae4cd3(&uStack_88,auStack_f8,(long)sStack_e);\n    *(undefined *)((long)&uStack_88 + (long)(int)sStack_e) = 0;\n  }\n  func_e32e18de0a904e25(&uStack_88);\n  return;\n}\n\n",
        "\nvoid func_127d56e8a7c14b3d(void)\n\n{\n  ulong uVar1;\n  ulong *puVar2;\n  undefined4 uStack_14;\n  \n  puVar2 = (ulong *)func_a48467e40e754225(8);\n  uVar1 = *puVar2;\n  func_a134be26b37a43b1(puVar2);\n  func_203d5a9ac6014f11(uVar1 & 0xffffffff);\n  uStack_14 = (undefined4)(uVar1 >> 0x20);\n  func_203d5a9ac6014f11(uStack_14);\n  return;\n}\n\n",
        "\nvoid func_0f2b8447966c474d(void)\n\n{\n  undefined auVar1 [16];\n  undefined8 ***pppuStack_28;\n  undefined8 ***pppuStack_20;\n  undefined8 ***pppuStack_18;\n  undefined8 ***pppuStack_10;\n  \n  pppuStack_18 = &pppuStack_28;\n  pppuStack_10 = &pppuStack_28;\n  pppuStack_28 = &pppuStack_18;\n  pppuStack_20 = &pppuStack_18;\n  auVar1 = func_57d5a9698b7d40df(pppuStack_18,pppuStack_10);\n  linkedListPrev = auVar1._8_8_;\n  linkedListNext = auVar1._0_8_;\n  *linkedListPrev = linkedListNext;\n  *(long **)(linkedListNext + 8) = linkedListPrev;\n  return;\n}\n\n",
        "\nvoid func_2691dca863bd471d(void)\n\n{\n  func_362e01c671904a2f();\n  return;\n}\n\n",
        "\nvoid func_3f188627466e40d2(void)\n\n{\n  int iVar1;\n  undefined2 uStack_48;\n  undefined2 uStack_46;\n  undefined4 uStack_44;\n  undefined8 ****ppppuStack_38;\n  undefined8 ****ppppuStack_30;\n  undefined8 ****ppppuStack_28;\n  undefined8 ****ppppuStack_20;\n  undefined4 uStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  ppppuStack_28 = &ppppuStack_38;\n  ppppuStack_20 = &ppppuStack_38;\n  ppppuStack_38 = &ppppuStack_28;\n  ppppuStack_30 = &ppppuStack_28;\n  iVar1 = func_e7fcbba07ff541ba();\n  if (iVar1 != 0) {\n    iStack_10 = 0xffffffff;\n    iStack_c = -1;\n    iStack_10 = func_1fda13582d274bfe(2,1,6);\n    if (iStack_10 != -1) {\n      func_a98082176dcc4e7b(&uStack_48,0,0x10);\n      uStack_48 = 2;\n      uStack_44 = 0;\n      uStack_46 = func_90709971c23c4f53(0x6987);\n      iVar1 = func_df62cce44281416b(iStack_10,&uStack_48,0x10);\n      if (((iVar1 != -1) && (iVar1 = func_441222177c4b4c28(iStack_10,5), iVar1 != -1)) &&\n         (iStack_c = func_350cb5b6bc7d4f2a(iStack_10,0,0), iStack_c != -1)) {\n        uStack_14 = func_ab1b59cd5b114783(iStack_c,&ppppuStack_28,0x10,0);\n      }\n    }\n    if (iStack_10 != -1) {\n      func_3062cbd711df48a1(iStack_10);\n    }\n    if (iStack_c != -1) {\n      func_3062cbd711df48a1(iStack_c);\n    }\n  }\n  linkedListPrev = ppppuStack_20;\n  linkedListNext = ppppuStack_28;\n  *ppppuStack_20 = ppppuStack_28;\n  linkedListNext[1] = linkedListPrev;\n  return;\n}\n\n",
        "\nvoid func_2e41aa683255495e(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined2 uStack_1d8;\n  undefined2 uStack_1d6;\n  undefined4 uStack_1d4;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [48];\n  undefined4 *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  code *pcStack_10;\n  \n  pcStack_10 = badVaSink;\n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_18 = &uStack_1c8;\n  iStack_1c = 0xffffffff;\n  lStack_28 = func_915db697cb1e423c(puStack_18);\n  iStack_1c = func_0490c256612d4d52(2,1,6);\n  if (iStack_1c != -1) {\n    func_a94ff7a005ad492f(&uStack_1d8,0,0x10);\n    uStack_1d8 = 2;\n    uStack_1d4 = func_6bf612126a1b4a88(&UNK_004016b4);\n    uStack_1d6 = func_37b5fd5039b6410f(0x6987);\n    iVar1 = func_025cf6000ca946ae(iStack_1c,&uStack_1d8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_2c = func_0b218188555a430e(iStack_1c,lStack_28 * 4 + (long)puStack_18,(99 - lStack_28) * 4\n                                     ,0), iStack_2c != -1)) && (iStack_2c != 0)) {\n      *(undefined4 *)((long)puStack_18 + (lStack_28 + ((ulong)(long)iStack_2c >> 2)) * 4) = 0;\n      puStack_38 = (undefined4 *)func_f11551a9a5984fee(puStack_18,0xd);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n      puStack_38 = (undefined4 *)func_f11551a9a5984fee(puStack_18,10);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n    }\n  }\n  if (iStack_1c != -1) {\n    func_a533d913579046a5(iStack_1c);\n  }\n  (*pcStack_10)(puStack_18,puStack_18);\n  return;\n}\n\n",
        "\nvoid func_23935262edce46ef(void)\n\n{\n  func_dd64e3a45be948b8();\n  func_d4fa4b70a0204cca();\n  func_1bd83c0ddb314674();\n  func_8c130ed41f5b4e6b();\n  return;\n}\n\n",
        "\nvoid func_0b9ea22950974065(void)\n\n{\n  undefined auStack_130 [112];\n  undefined auStack_c0 [56];\n  undefined auStack_88 [99];\n  undefined uStack_25;\n  undefined *puStack_20;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_18 = auStack_c0;\n  puStack_20 = auStack_130;\n  if (staticFive == 5) {\n    auStack_c0[0] = 0;\n    puStack_10 = puStack_18;\n  }\n  func_4e8026d922fe4b72(auStack_88,0x43,99);\n  uStack_25 = 0;\n  func_e41c1c6b8a0a4543(puStack_10,auStack_88,99);\n  puStack_10[99] = 0;\n  func_36da24ce1f1344d2(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_78adbfe45257445a(void)\n\n{\n  int iVar1;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  undefined8 uStack_24;\n  undefined4 uStack_1c;\n  ulong uStack_18;\n  long lStack_10;\n  \n  iVar1 = func_a5f9b96e953f4915();\n  if (iVar1 != 0) {\n    uStack_24 = 0x7271706f2f636261;\n    uStack_1c = 0x757473;\n    uStack_30 = 0x7271706f2f636261;\n    uStack_28 = 0x757473;\n    lStack_10 = func_e853490651ae4336(&uStack_24,0x2f);\n    if (lStack_10 == 0) {\n      func_b4657fd6b1414f33(1);\n    }\n    uStack_18 = lStack_10 - (long)&uStack_30;\n    func_3315f9b6475e4106(uStack_18 & 0xffffffff);\n  }\n  return;\n}\n\n",
        "\nvoid func_c8b6e41954354a82(void)\n\n{\n  undefined auStack_1b8 [396];\n  undefined4 uStack_2c;\n  undefined4 *puStack_20;\n  undefined4 *puStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)0x0;\n  puStack_20 = (undefined4 *)func_864fdd82dd1c4465(200);\n  *puStack_20 = 0;\n  puStack_18 = puStack_20;\n  puStack_10 = puStack_20;\n  func_c7e796c5754d4949(auStack_1b8,0x43,99);\n  uStack_2c = 0;\n  func_e39d70b6f98e4aa9(puStack_18,auStack_1b8,400);\n  puStack_18[99] = 0;\n  func_e84d424d9adb432f(puStack_18);\n  func_0c04a6e8712c42b6(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_3e674af42f4b45f5(undefined8 param_1)\n\n{\n  undefined auStack_198 [396];\n  undefined4 uStack_c;\n  \n  func_e1302602c8a445cd(auStack_198,0x43,99);\n  uStack_c = 0;\n  func_fb7f735f88274cfa(auStack_198,param_1,400);\n  uStack_c = 0;\n  func_eed70b0768344fd0(auStack_198);\n  return;\n}\n\n",
        "\nvoid func_4bc5c8c1f0124f40(void)\n\n{\n  int iVar1;\n  undefined4 *puStack_10;\n  \n  func_131db4567e4a44e5();\n  iVar1 = func_131db4567e4a44e5();\n  if (iVar1 != 0) {\n    func_3b79a30ae2524080(*puStack_10);\n    func_3b79a30ae2524080(puStack_10[1]);\n  }\n  return;\n}\n\n",
        "\nvoid func_98f125e958bf4f7d(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = 0;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_5d0f3e721bfa42af(2,1,6);\n  if (iStack_10 != -1) {\n    func_05a0fb06c7a64a10(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_5e46ab54f1a34711(&UNK_00401444);\n    uStack_26 = func_8960217fc9fe4ed9(0x6987);\n    iVar1 = func_2d40843331d64da3(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_e2adde2422de410b(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      iStack_c = func_16b6e267edc145e1(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_507c273be435462e(iStack_10);\n  }\n  iStack_18 = iStack_c + 1;\n  func_c0e4e8b343494d97(iStack_18);\n  return;\n}\n\n",
        "\nvoid func_567a366a9df947b0(undefined8 param_1)\n\n{\n  func_102d53c3f7344303(param_1);\n  return;\n}\n\n",
        "\nvoid func_2f9b635e35d240ec(void)\n\n{\n  long lVar1;\n  long lVar2;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_8c07379fc09b4008(100);\n  *pcStack_10 = '\\0';\n  lVar1 = func_19f0b29ece7a4a48(pcStack_10);\n  if (1 < 100U - lVar1) {\n    lVar2 = func_af7bdf1d36d94569(pcStack_10 + lVar1,100 - (int)lVar1,stdin);\n    if (lVar2 == 0) {\n      func_83471abcab6e4504(&UNK_00401374);\n      pcStack_10[lVar1] = '\\0';\n    }\n    else {\n      lVar1 = func_19f0b29ece7a4a48(pcStack_10);\n      if ((lVar1 != 0) && (pcStack_10[lVar1 + -1] == '\\n')) {\n        pcStack_10[lVar1 + -1] = '\\0';\n      }\n    }\n  }\n  if (GLOBAL_CONST_TRUE != 0) {\n    for (; *pcStack_10 != '\\0'; pcStack_10 = pcStack_10 + 1) {\n      if (*pcStack_10 == 'S') {\n        func_83471abcab6e4504(&UNK_00401383);\n        break;\n      }\n    }\n    func_e1fe3bff35b44571(pcStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_e0a4f6f4057c41ca(void)\n\n{\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined8 uStack_18;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)0x0;\n  if (globalFive == 5) {\n    puStack_10 = (undefined4 *)func_007e878f978d42a1(10);\n  }\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_ba79c946fd974ff6(puStack_10,&uStack_38,0x28);\n  func_ff240ca13144461a(*puStack_10);\n  func_6ee6ff7cd3564df6(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_9048f545b8ab429b(void)\n\n{\n  int iVar1;\n  undefined2 uStack_48;\n  undefined2 uStack_46;\n  undefined4 uStack_44;\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)func_75e6b2284d874210(400);\n  *puStack_10 = 0;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_e9f4842487c44fb8(puStack_10);\n  iStack_14 = func_bfe667125c4e4884(2,1,6);\n  if (iStack_14 != -1) {\n    func_05daaf4a17854b7b(&uStack_48,0,0x10);\n    uStack_48 = 2;\n    uStack_44 = func_1158ebdf1b1e4f8a(&UNK_00401624);\n    uStack_46 = func_08de9eedbbd443e2(0x6987);\n    iVar1 = func_991edbe6679642ff(iStack_14,&uStack_48,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_39994fdbacd743d6(iStack_14,puStack_10 + lStack_20,(99 - lStack_20) * 4,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      puStack_10[lStack_20 + ((ulong)(long)iStack_24 >> 2)] = 0;\n      puStack_30 = (undefined4 *)func_42b97925bc844c5f(puStack_10,0xd);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined4 *)func_42b97925bc844c5f(puStack_10,10);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_46064101b6c44180(iStack_14);\n  }\n  func_9048f545b8ab429bGlobal = 1;\n  func_9048f545b8ab429bSink(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_ec3466284477458d(void)\n\n{\n  func_286de024c4b24fb6();\n  func_9ce2c252376047e6();\n  func_451bfa4f783c441e();\n  func_5a992a311e5941a0();\n  return;\n}\n\n",
        "\nvoid func_54cf484c12aa477b(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined2 uStack_1d8;\n  undefined2 uStack_1d6;\n  undefined4 uStack_1d4;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [49];\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_10 = &uStack_1c8;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_b05fd177d9ac447d(puStack_10);\n  iStack_14 = func_dde87692a6924978(2,1,6);\n  if (iStack_14 != -1) {\n    func_095af63427c8404b(&uStack_1d8,0,0x10);\n    uStack_1d8 = 2;\n    uStack_1d4 = func_e9da912fb6c241ec(&UNK_004015b4);\n    uStack_1d6 = func_ce2f85675ec8409d(0x6987);\n    iVar1 = func_ae544765c5754fa4(iStack_14,&uStack_1d8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_b6daf032b7a4464a(iStack_14,lStack_20 * 4 + (long)puStack_10,(99 - lStack_20) * 4\n                                     ,0), iStack_24 != -1)) && (iStack_24 != 0)) {\n      *(undefined4 *)((long)puStack_10 + (lStack_20 + ((ulong)(long)iStack_24 >> 2)) * 4) = 0;\n      puStack_30 = (undefined4 *)func_9cfaf1ceb9f747ae(puStack_10,0xd);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined4 *)func_9cfaf1ceb9f747ae(puStack_10,10);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_e6a529ee63dc4854(iStack_14);\n  }\n  func_21c4231f0e75482a(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_5b1a43211d8c4645(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_7e5bdc2ae1804c7a(2,1,6);\n  if (iStack_10 != -1) {\n    func_7f190f3fd69d4a8c(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_019a82257acf4e24(&UNK_00401468);\n    uStack_26 = func_801e215af2314f46(0x6987);\n    iVar1 = func_af61b0bc15fc4c38(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_ddfbe3240a79446a(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      iStack_c = func_1b54224b007945af(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_64990d81f1b844ff(iStack_10);\n  }\n  func_7c53a7e043e04de4(100 % (long)iStack_c & 0xffffffff);\n  return;\n}\n\n",
        "\nlong func_3c9bbcc2760e4c34(long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = func_8c231c952f654cf3(param_1);\n  if (1 < 100U - lVar1) {\n    lVar2 = func_b9f5fe6f222a43e2(lVar1 * 4 + param_1,100 - (int)lVar1,stdin);\n    if (lVar2 == 0) {\n      func_6c0d6995af9a49a4(&UNK_004013a4);\n      *(undefined4 *)(param_1 + lVar1 * 4) = 0;\n    }\n    else {\n      lVar1 = func_8c231c952f654cf3(param_1);\n      if ((lVar1 != 0) && (*(int *)(param_1 + lVar1 * 4 + -4) == 10)) {\n        *(undefined4 *)(param_1 + lVar1 * 4 + -4) = 0;\n      }\n    }\n  }\n  return param_1;\n}\n\n",
        "\nvoid func_4d226e2375cb4861(void)\n\n{\n  func_b7dfabdf21e34472(0xffffffff);\n  return;\n}\n\n",
        "\nvoid func_1661100c691245af(undefined8 param_1)\n\n{\n  func_f52d8af86c804cff(param_1);\n  return;\n}\n\n",
        "\nvoid func_e5e9b55b8fd24129(void)\n\n{\n  func_0e9c55ca322842ad();\n  func_0837ac1cf9564571();\n  return;\n}\n\n",
        "\nvoid func_a99772c49bd34a4d(long param_1)\n\n{\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined2 uStack_18;\n  undefined8 uStack_10;\n  \n  uStack_10 = *(undefined8 *)(param_1 + 0x10);\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_845759263b5547da(&uStack_48,uStack_10);\n  func_8beaddc72eed4c27(uStack_10);\n  func_e0eaaa7303df4e12(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_9b38e5fd37754320(void)\n\n{\n  undefined auStack_88 [99];\n  undefined uStack_25;\n  long lStack_18;\n  long lStack_10;\n  \n  lStack_10 = 0;\n  lStack_18 = func_866ec46decb24327(100);\n  func_b57da70259de4133(lStack_18,0x41,99);\n  *(undefined *)(lStack_18 + 99) = 0;\n  lStack_10 = lStack_18 + -8;\n  func_b57da70259de4133(auStack_88,0x43,99);\n  uStack_25 = 0;\n  func_3ca97860f0394140(lStack_10,auStack_88);\n  func_560547734f164fb7(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_38d992b4b659407b(void)\n\n{\n  func_875867bf0ce54f3d();\n  return;\n}\n\n",
        "\nvoid func_75a329174d724f21(void)\n\n{\n  undefined auStack_298 [396];\n  undefined4 uStack_10c;\n  undefined auStack_108 [196];\n  undefined4 uStack_44;\n  undefined auStack_38 [16];\n  undefined *puStack_28;\n  undefined *puStack_10;\n  \n  func_04a2c3d7a23b4fc3(auStack_108,0x41,0x31);\n  uStack_44 = 0;\n  func_04a2c3d7a23b4fc3(auStack_298,0x41,99);\n  uStack_10c = 0;\n  puStack_28 = auStack_108;\n  puStack_10 = puStack_28;\n  func_1b89fef233194d4c(auStack_38);\n  return;\n}\n\n",
        "\nvoid func_a689d11f2d9f4cf5(void)\n\n{\n  int iVar1;\n  undefined2 uStack_b8;\n  undefined2 uStack_b6;\n  undefined4 uStack_b4;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_c;\n  \n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_18 = &uStack_a8;\n  iStack_1c = 0xffffffff;\n  iStack_c = -1;\n  lStack_28 = func_d0ef8abdfdad404e(puStack_18);\n  iStack_1c = func_0cf57a53388340fb(2,1,6);\n  if (iStack_1c != -1) {\n    func_93225bb9c29d403b(&uStack_b8,0,0x10);\n    uStack_b8 = 2;\n    uStack_b4 = 0;\n    uStack_b6 = func_82c609389670446d(0x6987);\n    iVar1 = func_cfdf01c4e3664b86(iStack_1c,&uStack_b8,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_d826cdcac70c445e(iStack_1c,5), iVar1 != -1)) &&\n        (iStack_c = func_1b909a70796743de(iStack_1c,0,0), iStack_c != -1)) &&\n       ((iStack_2c = func_b3b3dcfbbbd24e71(iStack_c,(long)puStack_18 + lStack_28,99 - lStack_28,0),\n        iStack_2c != -1 && (iStack_2c != 0)))) {\n      *(undefined *)((long)puStack_18 + iStack_2c + lStack_28) = 0;\n      puStack_38 = (undefined *)func_89e95f015710466b(puStack_18,0xd);\n      if (puStack_38 != (undefined *)0x0) {\n        *puStack_38 = 0;\n      }\n      puStack_38 = (undefined *)func_89e95f015710466b(puStack_18,10);\n      if (puStack_38 != (undefined *)0x0) {\n        *puStack_38 = 0;\n      }\n    }\n  }\n  if (iStack_1c != -1) {\n    func_0b071037756c4c8c(iStack_1c);\n  }\n  if (iStack_c != -1) {\n    func_0b071037756c4c8c(iStack_c);\n  }\n  func_5039aab5b0b84281(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_3bf94f747df8494d(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  iVar1 = func_ec4a9d8ce86742aa();\n  if (iVar1 != 0) {\n    lStack_18 = func_8d2a9233ef104a9e(puStack_10);\n    if (1 < 100U - lStack_18) {\n      lStack_20 = func_02c3a14db4da445f(&UNK_004013c6,&UNK_004013c4);\n      if (lStack_20 != 0) {\n        lVar2 = func_a8bb639a24c9438b((long)puStack_10 + lStack_18,100 - (int)lStack_18,lStack_20);\n        if (lVar2 == 0) {\n          func_f9d5c0608f024843(&UNK_004013d4);\n          *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n        }\n        func_21c25357796c47e7(lStack_20);\n      }\n    }\n  }\n  func_5ffc16395ff2432b(&UNK_004013ea,&UNK_004013ea,&UNK_004013e7,&UNK_004013e3,puStack_10,0);\n  return;\n}\n\n",
        "\nvoid func_a5808e8497824b01(void)\n\n{\n  func_8f698664581c41bd();\n  func_419438eab0484c0a();\n  func_37cd2ec8356840e7();\n  func_7e8ff93dcb384d6d();\n  return;\n}\n\n",
        "\nvoid func_2d5f2c33d97843b6(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_40 [8];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  short sStack_a;\n  \n  sStack_a = 0;\n  iVar1 = func_6d4973c121a84ccb();\n  if (iVar1 == 0) {\n    sStack_a = 99;\n  }\n  else {\n    iStack_14 = 0xffffffff;\n    iStack_10 = -1;\n    iStack_14 = func_23ef72282f7247f1(2,1,6);\n    if (iStack_14 != -1) {\n      func_bbd1acc72b1c45bf(&uStack_38,0,0x10);\n      uStack_38 = 2;\n      uStack_34 = 0;\n      uStack_36 = func_e01488f8f57c40bd(0x6987);\n      iVar1 = func_65a277505a844bbe(iStack_14,&uStack_38,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_180969e4922a424e(iStack_14,5), iVar1 != -1)) &&\n          (iStack_10 = func_027a8bb52df74767(iStack_14,0,0), iStack_10 != -1)) &&\n         ((iStack_18 = func_7fd02d86f6ad492f(iStack_10,auStack_40,7,0), iStack_18 != -1 &&\n          (iStack_18 != 0)))) {\n        auStack_40[iStack_18] = 0;\n        iStack_1c = func_34b11f6a0f644bda(auStack_40);\n        if ((iStack_1c < 0x8000) && (-0x8001 < iStack_1c)) {\n          sStack_a = (short)iStack_1c;\n        }\n        else {\n          sStack_a = -1;\n        }\n      }\n    }\n    if (iStack_14 != -1) {\n      func_f786ea4a50b14ad9(iStack_14);\n    }\n    if (iStack_10 != -1) {\n      func_f786ea4a50b14ad9(iStack_10);\n    }\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_bbd1acc72b1c45bf(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (sStack_a < 100) {\n    func_b2613059885a43b6(&uStack_a8,auStack_118,(long)sStack_a);\n    *(undefined *)((long)&uStack_a8 + (long)(int)sStack_a) = 0;\n  }\n  func_ea899e8ff5a54b93(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_61ee3c65353a4e2b(void)\n\n{\n  func_553be2cf3c534e43();\n  func_5f94dce19c9c4af6();\n  return;\n}\n\n",
        "\nvoid func_e57de47529414e48(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_0033bd8493c04baf(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lStack_20 = func_c318efa64c7243bb(&UNK_00401416,&UNK_00401414);\n    if (lStack_20 != 0) {\n      lVar1 = func_70b80388b9fc4c30((long)puStack_10 + lStack_18,100 - (int)lStack_18,lStack_20);\n      if (lVar1 == 0) {\n        func_ce4a70610d664a67(&UNK_00401424);\n        *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n      }\n      func_f489095f48fc498f(lStack_20);\n    }\n  }\n  func_28a23f4eea5c4f2c(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_42a724caf93444c8(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_c6c7b8228ea04461(puStack_10);\n  if ((1 < 100U - lStack_18) &&\n     (lStack_20 = func_66b26bab9caf4624(&UNK_0040144a,&UNK_00401448), lStack_20 != 0)) {\n    lVar1 = func_4303cb8461ed4f1b((long)puStack_10 + lStack_18,100 - (int)lStack_18,lStack_20);\n    if (lVar1 == 0) {\n      func_8d35e77122d04325(&UNK_00401458);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    func_a3d48acad3f34459(lStack_20);\n  }\n  func_666bbea24be74eb3(puStack_10,puStack_10);\n  return;\n}\n\n",
        "\nvoid func_9a9f8d262ee1402d(void)\n\n{\n  undefined auStack_1e0 [408];\n  undefined auStack_48 [16];\n  undefined *puStack_38;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = (undefined *)0x0;\n  puStack_18 = auStack_1e0;\n  func_43e6c56897324627(puStack_18,0x41,99);\n  *(undefined4 *)(puStack_18 + 0x18c) = 0;\n  puStack_10 = puStack_18;\n  puStack_38 = puStack_18;\n  func_82272f5ffab142c5(auStack_48);\n  return;\n}\n\n",
        "\nvoid func_fe548709ce38446a\n               (undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_118;\n  undefined8 uStack_110;\n  undefined8 auStack_108 [31];\n  undefined8 *puStack_10;\n  \n  uStack_118 = 0x3d48544150;\n  uStack_110 = 0;\n  puVar2 = auStack_108;\n  for (lVar1 = 0x1d; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  *(undefined2 *)puVar2 = 0;\n  puStack_10 = &uStack_118;\n  badStatic = 1;\n  puStack_10 = (undefined8 *)func_49173c3dd0c64e31(puStack_10,param_2,(undefined2 *)((long)puVar2 + 2));\n  func_f9926fa942b84a32(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_cde7032d4eba4c93(short *param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = *param_1;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_da463fa68d804a4d(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_6bb5abe357b446a4(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_0452dcdf7c30433c(&uStack_78);\n  return;\n}\n\n",
        "\nundefined8 *\nCWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_22_goodG2B2Source(undefined8 *param_1)\n\n{\n  undefined8 *puStack_10;\n  \n  puStack_10 = param_1;\n  if (CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_22_goodG2B2Global != 0) {\n    puStack_10 = (undefined8 *)func_b0cfe48a12f249d2(8);\n    *puStack_10 = 0x7ffffffb;\n  }\n  return puStack_10;\n}\n\n",
        "\nvoid func_f34f13e181614f9b(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_57a11450354f4ee0(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lVar1 = func_ef0ce431b4234afb((long)puStack_10 + lStack_18,100 - (int)lStack_18,stdin);\n    if (lVar1 == 0) {\n      func_b8861e53d5904ccf(&UNK_00401324);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    else {\n      lStack_18 = func_57a11450354f4ee0(puStack_10);\n      if ((lStack_18 != 0) && (*(char *)((long)puStack_10 + lStack_18 + -1) == '\\n')) {\n        *(undefined *)((long)puStack_10 + lStack_18 + -1) = 0;\n      }\n    }\n  }\n  func_b3cf843eaf09461e(&UNK_0040133a,&UNK_0040133a,&UNK_00401337,&UNK_00401333,puStack_10,0);\n  return;\n}\n\n",
        "\nlong func_e362c9e3eb3242f8(long param_1)\n\n{\n  func_ebc7a6cca490412a(param_1,0x41,0x31);\n  *(undefined4 *)(param_1 + 0xc4) = 0;\n  return param_1;\n}\n\n",
        "\nvoid func_2cf035095a924197(void)\n\n{\n  long lVar1;\n  undefined8 uStack_1a;\n  undefined4 uStack_12;\n  undefined2 uStack_e;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  uStack_1a = 0;\n  uStack_12 = 0;\n  uStack_e = 0;\n  lVar1 = func_e53e03ffde984986(&uStack_1a,0xe,stdin);\n  if (lVar1 == 0) {\n    func_29d1664f75b64396(&UNK_00401214);\n  }\n  else {\n    uStack_c = func_34ce2fa523304064(&uStack_1a);\n  }\n  func_39146357da824050(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_cd43d652319b41ca(undefined8 param_1)\n\n{\n  int iVar1;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iVar1 = func_2c950733d18d4f46(param_1,&UNK_00401754,&iStack_14);\n  if (iVar1 == 1) {\n    iStack_10 = 0;\n    for (iStack_c = 0; iStack_c < iStack_14; iStack_c = iStack_c + 1) {\n      iStack_10 = iStack_10 + 1;\n    }\n    func_e1960b784883458d(iStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_9c0fb73c7f584fe7(void)\n\n{\n  func_61ac88cb7b024bb3();\n  func_597307e3444c425c();\n  func_41b153992f164100();\n  func_f1c7871c2f3d413e();\n  return;\n}\n\n",
        "\nvoid func_f3aa163ef24f4881(void)\n\n{\n  func_dd132fbf577040ef(0);\n  return;\n}\n\n",
        "\nvoid func_b229523174ac4ae8(void)\n\n{\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  uStack_10 = func_cadfcd10cc164b93(400);\n  func_3faf35c06c9047e2(&uStack_10);\n  return;\n}\n\n",
        "\nvoid func_3421539328694a09(void)\n\n{\n  long lVar1;\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  undefined8 uStack_12;\n  short sStack_a;\n  \n  sStack_a = 0;\n  uStack_12 = 0;\n  lVar1 = func_67938637554e4137(&uStack_12,8,stdin);\n  if (lVar1 == 0) {\n    func_0bd3b3d4035c4d5f(&UNK_00401384);\n  }\n  else {\n    sStack_a = func_7bf3b744ed02400f(&uStack_12);\n  }\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_86e7be8ce544452f(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_2f3fc9f1e28c49b2(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_0bd3b3d4035c4d5f(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_d387c9f5ea454357(void)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)func_bd720873a7314d41(100);\n  *puVar1 = 0x676e697274532041;\n  *(undefined *)(puVar1 + 1) = 0;\n  func_49ae94d86eed491e(puVar1);\n  puVar1 = (undefined8 *)func_833b2adb5c4a48bc(puVar1,130000);\n  if (puVar1 != (undefined8 *)0x0) {\n    *puVar1 = 0x697274532077654e;\n    *(undefined2 *)(puVar1 + 1) = 0x676e;\n    *(undefined *)((long)puVar1 + 10) = 0;\n    func_49ae94d86eed491e(puVar1);\n    func_bf4499902cdf4dfb(puVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_57fbf13ab08844e9(void)\n\n{\n  func_239e5260c4ee4a06();\n  func_47554eed47094c4c();\n  return;\n}\n\n",
        "\nvoid func_8505c65c5a5349d3(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  if (GLOBAL_CONST_TRUE != 0) {\n    iStack_14 = 0xffffffff;\n    iStack_10 = -1;\n    iStack_14 = func_fa429149f98f4221(2,1,6);\n    if (iStack_14 != -1) {\n      func_fab5a31cd65b4611(&uStack_28,0,0x10);\n      uStack_28 = 2;\n      uStack_24 = 0;\n      uStack_26 = func_310064e620964a2b(0x6987);\n      iVar1 = func_e3586328b61f4af7(iStack_14,&uStack_28,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_e232357240604887(iStack_14,5), iVar1 != -1)) &&\n          (iStack_10 = func_5985bc5ccae94b7e(iStack_14,0,0), iStack_10 != -1)) &&\n         ((iStack_18 = func_28f051a1b667431b(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n          (iStack_18 != 0)))) {\n        auStack_36[iStack_18] = 0;\n        iStack_c = func_2786dcb5346a4136(auStack_36);\n      }\n    }\n    if (iStack_14 != -1) {\n      func_d51ffcb6214e4e7d(iStack_14);\n    }\n    if (iStack_10 != -1) {\n      func_d51ffcb6214e4e7d(iStack_10);\n    }\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_fab5a31cd65b4611(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_b6b3c47489844db5(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_7409f4bf82c74aec(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_dd28a00b07184e14(void)\n\n{\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined2 uStack_28;\n  long lStack_20;\n  long lStack_18;\n  long lStack_10;\n  \n  lStack_10 = func_db807468e6264d71(100);\n  func_bf073c129437405b(lStack_10,0x41,99);\n  *(undefined *)(lStack_10 + 99) = 0;\n  lStack_18 = lStack_10;\n  lStack_20 = lStack_10;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  func_691084bd681240e0(&uStack_58,lStack_10);\n  func_16b127af6dbc4e55(lStack_20);\n  func_ff7dea36daf64dcd(lStack_20);\n  return;\n}\n\n",
        "\nvoid func_bb61444fa3834397(void)\n\n{\n  undefined auStack_28 [8];\n  undefined4 uStack_20;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  func_f917f040ddd2434c(stdin,&UNK_00401304,&uStack_c);\n  uStack_20 = uStack_c;\n  func_ba413d25fedb4e19(auStack_28);\n  return;\n}\n\n",
        "\nvoid func_478d49998fff42d3(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  byte bVar4;\n  undefined8 uStack_348;\n  undefined8 uStack_340;\n  undefined8 auStack_338 [48];\n  undefined8 uStack_1b8;\n  undefined8 uStack_1b0;\n  undefined8 auStack_1a8 [49];\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  bVar4 = 0;\n  uStack_1b8 = 0;\n  uStack_1b0 = 0;\n  puVar3 = auStack_1a8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_10 = &uStack_1b8;\n  iVar1 = func_b69aa8462c754c1d();\n  if (iVar1 != 0) {\n    lStack_18 = func_f27dccc7a6014f52(puStack_10);\n    lStack_20 = func_b92a84d232594a6f(&UNK_00401304);\n    if (lStack_20 != 0) {\n      func_975cdc23220b4142(lStack_18 * 4 + (long)puStack_10,lStack_20,99 - lStack_18);\n    }\n  }\n  iVar1 = func_b69aa8462c754c1d();\n  if (iVar1 != 0) {\n    uStack_348 = 0;\n    uStack_340 = 0;\n    puVar3 = auStack_338;\n    for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n      *puVar3 = 0;\n      puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n    }\n    func_76192a804a8d44fd(&uStack_348,99,puStack_10);\n    func_7d1d25261be54ae5(&uStack_348);\n  }\n  return;\n}\n\n",
        "\nvoid func_20a06d51bc4f410c(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_22;\n  undefined4 uStack_1a;\n  undefined2 uStack_16;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iVar1 = func_6a0fa49b09bc4091();\n  if (iVar1 == 0) {\n    iStack_c = 7;\n  }\n  else {\n    uStack_22 = 0;\n    uStack_1a = 0;\n    uStack_16 = 0;\n    lVar2 = func_b15ff8349a6b4d5a(&uStack_22,0xe,stdin);\n    if (lVar2 == 0) {\n      func_80df321269e64991(&UNK_004012f8);\n    }\n    else {\n      iStack_c = func_7e790c6f409549ad(&uStack_22);\n    }\n  }\n  iVar1 = func_6a0fa49b09bc4091();\n  if (iVar1 == 0) {\n    uStack_58 = 0;\n    uStack_50 = 0;\n    uStack_48 = 0;\n    uStack_40 = 0;\n    uStack_38 = 0;\n    if ((iStack_c < 0) || (9 < iStack_c)) {\n      func_80df321269e64991(&UNK_00401328);\n    }\n    else {\n      *(undefined4 *)((long)&uStack_58 + (long)iStack_c * 4) = 1;\n      for (iStack_14 = 0; iStack_14 < 10; iStack_14 = iStack_14 + 1) {\n        func_ea7e9b5c49554166(*(undefined4 *)((long)&uStack_58 + (long)iStack_14 * 4));\n      }\n    }\n  }\n  else {\n    uStack_58 = 0;\n    uStack_50 = 0;\n    uStack_48 = 0;\n    uStack_40 = 0;\n    uStack_38 = 0;\n    if (iStack_c < 0) {\n      func_80df321269e64991(&UNK_00401308);\n    }\n    else {\n      *(undefined4 *)((long)&uStack_58 + (long)iStack_c * 4) = 1;\n      for (iStack_10 = 0; iStack_10 < 10; iStack_10 = iStack_10 + 1) {\n        func_ea7e9b5c49554166(*(undefined4 *)((long)&uStack_58 + (long)iStack_10 * 4));\n      }\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_a3daa3839c534d92(void)\n\n{\n  int iVar1;\n  long lVar2;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  lVar2 = func_1c17db9cb9714ec5(0x50);\n  iVar1 = func_211cb6665b464a78();\n  if (iVar1 == 0) {\n    for (iStack_10 = 0; iStack_10 < 10; iStack_10 = iStack_10 + 1) {\n      *(double *)(lVar2 + (long)iStack_10 * 8) = (double)iStack_10;\n    }\n  }\n  else {\n    for (iStack_c = 0; iStack_c < 5; iStack_c = iStack_c + 1) {\n      *(double *)(lVar2 + (long)iStack_c * 8) = (double)iStack_c;\n    }\n  }\n  iVar1 = func_211cb6665b464a78();\n  if (iVar1 == 0) {\n    for (iStack_18 = 0; iStack_18 < 10; iStack_18 = iStack_18 + 1) {\n      *(double *)(lVar2 + (long)iStack_18 * 8) = (double)iStack_18;\n    }\n    for (iStack_1c = 0; iStack_1c < 10; iStack_1c = iStack_1c + 1) {\n      func_18e25ccad1fd4246(*(undefined8 *)(lVar2 + (long)iStack_1c * 8));\n    }\n  }\n  else {\n    for (iStack_14 = 0; iStack_14 < 10; iStack_14 = iStack_14 + 1) {\n      func_18e25ccad1fd4246(*(undefined8 *)(lVar2 + (long)iStack_14 * 8));\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_64c927e25e9b41bf(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_57f5a76c49254a03(2,1,6);\n  if (iStack_10 != -1) {\n    func_bd46882159814ff8(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_a1306419be2949b7(&UNK_00401454);\n    uStack_26 = func_f0a8c4c7c95340aa(0x6987);\n    iVar1 = func_5c4cba0e323741cc(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_367108ea8ef84790(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      uStack_c = func_761e90f197894785(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_b770ce8195c54f7a(iStack_10);\n  }\n  func_ed9e7ca95b8c497b(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_ffed5316ef3a4aa1(void)\n\n{\n  func_6b1937aca97b4f95();\n  func_0983d47aecc34154();\n  return;\n}\n\n",
        "\nvoid func_846b4bd0954d43ea(void)\n\n{\n  long lVar1;\n  long lVar2;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_3df11699eb184f09(100);\n  *pcStack_10 = '\\0';\n  lVar1 = func_b7c21aa298a74990(pcStack_10);\n  lVar2 = func_065be605ef8a463b(&UNK_00401314);\n  if (lVar2 != 0) {\n    func_60c53931cf4f4b40(pcStack_10 + lVar1,lVar2,99 - lVar1);\n  }\n  if (globalTrue != 0) {\n    for (; *pcStack_10 != '\\0'; pcStack_10 = pcStack_10 + 1) {\n      if (*pcStack_10 == 'S') {\n        func_a5606d04a70f473e(&UNK_00401318);\n        break;\n      }\n    }\n    func_385c40136095400f(pcStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_b5c726708e5e4520(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = func_39019085e49e49ff(0,400);\n  func_df1932bfecc1463d(uVar1,&UNK_004011b8);\n  func_5e2128143b714b69(uVar1);\n  func_b5c726708e5e4520Global = 1;\n  func_b5c726708e5e4520Sink(uVar1);\n  return;\n}\n\n",
        "\nvoid func_f1306e1995494580(void)\n\n{\n  int iVar1;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_20;\n  int iStack_1c;\n  code *pcStack_18;\n  undefined4 uStack_c;\n  \n  pcStack_18 = CWE191_Integer_Underflow__int_connect_socket_multiply_65b_badSink;\n  uStack_c = 0;\n  iStack_1c = 0xffffffff;\n  iStack_1c = func_e8b720e3e54b4170(2,1,6);\n  if (iStack_1c != -1) {\n    func_bfb9d27ec897407c(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = func_34262804e27e4d38(&UNK_00401464);\n    uStack_36 = func_19ee5073244d4481(0x6987);\n    iVar1 = func_7ac1c9fdab844214(iStack_1c,&uStack_38,0x10);\n    if (((iVar1 != -1) && (iStack_20 = func_b3cfa7adf7aa451c(iStack_1c,auStack_46,0xd,0), iStack_20 != -1)\n        ) && (iStack_20 != 0)) {\n      auStack_46[iStack_20] = 0;\n      uStack_c = func_0df2d1c1edb24b5e(auStack_46);\n    }\n  }\n  if (iStack_1c != -1) {\n    func_338a75c5aa5d40d1(iStack_1c);\n  }\n  (*pcStack_18)(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_4ee8ff7a3c994b9e(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_408;\n  undefined8 uStack_400;\n  undefined8 uStack_3f8;\n  undefined8 uStack_3f0;\n  undefined8 auStack_3e8 [122];\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_408 = 0x4100000050;\n  uStack_400 = 0x4800000054;\n  uStack_3f8 = 0x3d;\n  uStack_3f0 = 0;\n  puVar2 = auStack_3e8;\n  for (lVar1 = 0x79; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  puStack_10 = &uStack_408;\n  lStack_18 = func_af78627f0c584f5d(puStack_10);\n  if (1 < 0xfaU - lStack_18) {\n    lVar1 = func_3baef83919ef4479(lStack_18 * 4 + (long)puStack_10,0xfa - (int)lStack_18,stdin);\n    if (lVar1 == 0) {\n      func_e4e34841e215482a(&UNK_00401314);\n      *(undefined4 *)((long)puStack_10 + lStack_18 * 4) = 0;\n    }\n    else {\n      lStack_18 = func_af78627f0c584f5d(puStack_10);\n      if ((lStack_18 != 0) && (*(int *)((long)puStack_10 + lStack_18 * 4 + -4) == 10)) {\n        *(undefined4 *)((long)puStack_10 + lStack_18 * 4 + -4) = 0;\n      }\n    }\n  }\n  func_1734ca3913e34044(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_e3145d2e5ea5432b(int *param_1)\n\n{\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined8 uStack_18;\n  int iStack_c;\n  \n  iStack_c = *param_1;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  if (iStack_c < 0) {\n    func_2888c38e109b4b8a(&UNK_00401538);\n  }\n  else {\n    func_8aa78d1a17c34330(*(undefined4 *)((long)&uStack_38 + (long)iStack_c * 4));\n  }\n  return;\n}\n\n",
        "\nvoid func_08fe7beb4f214c6e(void)\n\n{\n  func_bd57ed22a2de4243();\n  func_7f2b2945657f4752();\n  return;\n}\n\n",
        "\nvoid func_3be7392b5e5e44f8(void)\n\n{\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  long lStack_10;\n  \n  lStack_10 = CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_68_goodG2BData;\n  func_8285b24430fb4d15(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_0fcf03757b8447d2(lStack_10,auStack_1a8,400);\n  *(undefined4 *)(lStack_10 + 0x18c) = 0;\n  func_2f09422629734c3b(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_4216754ee54b4fe6(void)\n\n{\n  long lVar1;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined2 uStack_20;\n  undefined8 uStack_18;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  lVar1 = func_6d0611e773d5421b(&uStack_38,0x1a,stdin);\n  if (lVar1 == 0) {\n    func_cc9d9eff636f4ae2(&UNK_004013e4);\n  }\n  else {\n    uStack_10 = func_89607d9fd67346e0(&uStack_38,0,0);\n  }\n  uStack_18 = uStack_10;\n  func_2677dfd408a742b2(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_45bb1c832c3d4959(void)\n\n{\n  func_add3bcbafe5a489a();\n  func_e4af0c034cbe4b23();\n  return;\n}\n\n",
        "\nvoid func_a9d68600f9814a2a(void)\n\n{\n  long lVar1;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined4 uStack_28;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  puStack_10 = &uStack_88;\n  lStack_18 = func_eaaf63d037c141a9(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lVar1 = func_4258b71b4eb941fe((long)puStack_10 + lStack_18,100 - (int)lStack_18,stdin);\n    if (lVar1 == 0) {\n      func_8ea32eed7f014e35(&UNK_00401324);\n      *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n    }\n    else {\n      lStack_18 = func_eaaf63d037c141a9(puStack_10);\n      if ((lStack_18 != 0) && (*(char *)((long)puStack_10 + lStack_18 + -1) == '\\n')) {\n        *(undefined *)((long)puStack_10 + lStack_18 + -1) = 0;\n      }\n    }\n  }\n  func_ac2fa164e94a4cb4(&UNK_0040133a,&UNK_0040133a,&UNK_00401337,&UNK_00401333,puStack_10,0);\n  return;\n}\n\n",
        "\nvoid func_a15c8ba6df27499d(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  undefined8 uStack_10;\n  \n  uStack_10 = param_1;\n  func_23a0d1b34d604c33(auStack_78,0x43,99);\n  uStack_15 = 0;\n  uVar1 = func_1ee9b9ec2ad44511(auStack_78);\n  func_b63a8e9782dc4e62(auStack_78,uStack_10,uVar1);\n  uStack_15 = 0;\n  func_e6c41f5788264f65(auStack_78);\n  return;\n}\n\n",
        "\nvoid func_cad34536f45b4a9f(int param_1)\n\n{\n  if (param_1 == -0x80000000) {\n    func_46d6a9c28d8d46fd(&UNK_004015c8);\n  }\n  else {\n    func_27600d54113040fd(param_1 + -1);\n  }\n  return;\n}\n\n",
        "\nvoid func_70025753e6b8415a(void)\n\n{\n  func_8850759da43d4754();\n  return;\n}\n\n",
        "\nvoid func_2b0c23ded2f146e7(short param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_89ad158568164056(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (param_1 < 100) {\n    func_43e04a64ee3842e3(&uStack_78,auStack_e8,(long)param_1);\n    *(undefined *)((long)&uStack_78 + (long)(int)param_1) = 0;\n  }\n  func_e1a09cd63cdf4f07(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_c7befeca1bf6419d(void)\n\n{\n  long lVar1;\n  \n  lVar1 = func_1c233601dff644a1(0x32);\n  func_c7d15099372c42a8(lVar1,0x41,0x31);\n  *(undefined *)(lVar1 + 0x31) = 0;\n  func_a270b6c3ddac4f00(lVar1);\n  return;\n}\n\n",
        "\nvoid func_336bbd55d3ce45a4(void)\n\n{\n  func_06f6436644b146cb();\n  func_ae726962d3664054();\n  return;\n}\n\n",
        "\nvoid func_dbbcd13926ee4ae9(undefined8 param_1)\n\n{\n  func_70ea185634944f10(param_1);\n  return;\n}\n\n",
        "\nvoid func_598708a1325e4965(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_1a;\n  undefined4 uStack_12;\n  undefined2 uStack_e;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iVar1 = func_b00347be4cbf4c45();\n  if (iVar1 == 0) {\n    iStack_c = 7;\n  }\n  else {\n    uStack_1a = 0;\n    uStack_12 = 0;\n    uStack_e = 0;\n    lVar2 = func_273a55f5277b422a(&uStack_1a,0xe,stdin);\n    if (lVar2 == 0) {\n      func_d233c0d53b55466e(&UNK_004012b8);\n    }\n    else {\n      iStack_c = func_6645ce10a8db4924(&uStack_1a);\n    }\n  }\n  iVar1 = func_b00347be4cbf4c45();\n  if (iVar1 == 0) {\n    uStack_48 = 0;\n    uStack_40 = 0;\n    uStack_38 = 0;\n    uStack_30 = 0;\n    uStack_28 = 0;\n    if ((iStack_c < 0) || (9 < iStack_c)) {\n      func_d233c0d53b55466e(&UNK_004012e8);\n    }\n    else {\n      func_de5745ffa0f84f7c(*(undefined4 *)((long)&uStack_48 + (long)iStack_c * 4));\n    }\n  }\n  else {\n    uStack_48 = 0;\n    uStack_40 = 0;\n    uStack_38 = 0;\n    uStack_30 = 0;\n    uStack_28 = 0;\n    if (iStack_c < 10) {\n      func_de5745ffa0f84f7c(*(undefined4 *)((long)&uStack_48 + (long)iStack_c * 4));\n    }\n    else {\n      func_d233c0d53b55466e(&UNK_004012c8);\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_fd3f265bb91d44c6(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  undefined4 uStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_a5752e8989ac4f45(2,1,6);\n  if (iStack_10 != -1) {\n    func_ceffab581218466e(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_8ff1712422974e1a(&UNK_00401464);\n    uStack_26 = func_8b52e8dbe66b4faf(0x6987);\n    iVar1 = func_9815ad7d910c49ba(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_b55e860bfffa4ec8(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      uStack_c = func_676c05f53c754f6b(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_df480eab45ad4733(iStack_10);\n  }\n  uStack_18 = uStack_c;\n  func_21ef48fc548c46e3(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_14b7fda5ed1e4319(void)\n\n{\n  func_69e4da4442d742a7();\n  func_c97dc6a3e8c64626();\n  func_47aa47bd70a74a9b();\n  func_927b32b208ae4782();\n  return;\n}\n\n",
        "\nvoid func_0918ef6062014584(void)\n\n{\n  int iVar1;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  iVar1 = func_302f1891263f41b3();\n  if (iVar1 != 0) {\n    uStack_38 = 0x790000006d;\n    uStack_30 = 0x7400000053;\n    uStack_28 = 0x6900000072;\n    uStack_20 = 0x670000006e;\n    uStack_18 = 0;\n    uStack_10 = func_e58103a016e448f8(&uStack_38);\n    func_3e128a4c77924393(uStack_10);\n  }\n  func_302f1891263f41b3();\n  return;\n}\n\n",
        "\nvoid func_2d7730f2b5114be7(undefined4 param_1)\n\n{\n  func_5f4e61ece9ef4cb7(param_1);\n  return;\n}\n\n",
        "\nvoid func_7284a5e9031b429b(void)\n\n{\n  func_27736fad39b64700();\n  func_22490d06da244871();\n  return;\n}\n\n",
        "\nvoid func_7289d15fc2aa4e61(void)\n\n{\n  int iVar1;\n  undefined2 uStack_b8;\n  undefined2 uStack_b6;\n  undefined4 uStack_b4;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  long lStack_40;\n  undefined *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_c;\n  \n  uStack_a8 = 0x2068732f6e69622f;\n  uStack_a0 = 0x20616c2d20736c;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_18 = &uStack_a8;\n  if (globalTrue != 0) {\n    iStack_1c = 0xffffffff;\n    iStack_c = -1;\n    lStack_28 = func_8165c373703c4794(puStack_18);\n    iStack_1c = func_bf0a6ae2f1344366(2,1,6);\n    if (iStack_1c != -1) {\n      func_860ce970a8a641f3(&uStack_b8,0,0x10);\n      uStack_b8 = 2;\n      uStack_b4 = 0;\n      uStack_b6 = func_bc74b7799d954bc3(0x6987);\n      iVar1 = func_3c06bb1d71704567(iStack_1c,&uStack_b8,0x10);\n      if ((((iVar1 != -1) && (iVar1 = func_4ce01e5961284bd0(iStack_1c,5), iVar1 != -1)) &&\n          (iStack_c = func_7bfab287b35e4e3e(iStack_1c,0,0), iStack_c != -1)) &&\n         ((iStack_2c = func_e8119065aad24463(iStack_c,(long)puStack_18 + lStack_28,99 - lStack_28,0),\n          iStack_2c != -1 && (iStack_2c != 0)))) {\n        *(undefined *)((long)puStack_18 + iStack_2c + lStack_28) = 0;\n        puStack_38 = (undefined *)func_95355ea9604e4a99(puStack_18,0xd);\n        if (puStack_38 != (undefined *)0x0) {\n          *puStack_38 = 0;\n        }\n        puStack_38 = (undefined *)func_95355ea9604e4a99(puStack_18,10);\n        if (puStack_38 != (undefined *)0x0) {\n          *puStack_38 = 0;\n        }\n      }\n    }\n    if (iStack_1c != -1) {\n      func_5661a300205c490a(iStack_1c);\n    }\n    if (iStack_c != -1) {\n      func_5661a300205c490a(iStack_c);\n    }\n  }\n  lStack_40 = func_388549cb614a4ad1(puStack_18,&UNK_004016e4);\n  if (lStack_40 != 0) {\n    func_ef4382ba75274b1a(lStack_40);\n  }\n  return;\n}\n\n",
        "\nvoid func_1754855652624542(void)\n\n{\n  func_57205709649749a5();\n  func_1f03118289984a2c();\n  func_49f5320bb83c4e53();\n  func_b30f10e57cb545e0();\n  return;\n}\n\n",
        "\nvoid func_8bcc0bf0c14d4988(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_c317853e11284c6f(2,1,6);\n  if (iStack_14 != -1) {\n    func_e8b596ece6ec4ca8(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_146e41df736045e2(0x6987);\n    iVar1 = func_80d16e8c8db8438d(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_07d976d525be4ec1(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_6749f06480064780(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_ed3e336e89464dfc(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      iStack_c = func_22bedb9f871a4e27(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_69b9507f2cea4129(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_69b9507f2cea4129(iStack_10);\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_e8b596ece6ec4ca8(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (iStack_c < 100) {\n    func_9a4238f197d6406c(&uStack_a8,auStack_118,(long)iStack_c);\n    *(undefined *)((long)&uStack_a8 + (long)iStack_c) = 0;\n  }\n  func_6c824923f3e44a83(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_4273f580c34f47a2(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined2 uStack_438;\n  undefined2 uStack_436;\n  undefined4 uStack_434;\n  undefined8 uStack_428;\n  undefined8 uStack_420;\n  undefined8 uStack_418;\n  undefined8 uStack_410;\n  undefined8 auStack_408 [122];\n  undefined4 *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_c;\n  \n  uStack_428 = 0x4100000050;\n  uStack_420 = 0x4800000054;\n  uStack_418 = 0x3d;\n  uStack_410 = 0;\n  puVar3 = auStack_408;\n  for (lVar2 = 0x79; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_18 = &uStack_428;\n  iStack_1c = 0xffffffff;\n  iStack_c = -1;\n  lStack_28 = func_8453099dfcd645fe(puStack_18);\n  iStack_1c = func_809391f1130a4fbc(2,1,6);\n  if (iStack_1c != -1) {\n    func_cbeb9c2dd50f4835(&uStack_438,0,0x10);\n    uStack_438 = 2;\n    uStack_434 = 0;\n    uStack_436 = func_19f24290cb324498(0x6987);\n    iVar1 = func_7e8fcb70f2fb45b5(iStack_1c,&uStack_438,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_a428d3e7bdbb47c3(iStack_1c,5), iVar1 != -1)) &&\n        (iStack_c = func_890497eac9024197(iStack_1c,0,0), iStack_c != -1)) &&\n       ((iStack_2c = func_030b7962fb58470f(iStack_c,lStack_28 * 4 + (long)puStack_18,\n                                     (0xf9 - lStack_28) * 4,0), iStack_2c != -1 && (iStack_2c != 0))\n       )) {\n      *(undefined4 *)((long)puStack_18 + (lStack_28 + ((ulong)(long)iStack_2c >> 2)) * 4) = 0;\n      puStack_38 = (undefined4 *)func_f621c0e95c774d5c(puStack_18,0xd);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n      puStack_38 = (undefined4 *)func_f621c0e95c774d5c(puStack_18,10);\n      if (puStack_38 != (undefined4 *)0x0) {\n        *puStack_38 = 0;\n      }\n    }\n  }\n  if (iStack_1c != -1) {\n    func_fa124fe75b484f69(iStack_1c);\n  }\n  if (iStack_c != -1) {\n    func_fa124fe75b484f69(iStack_c);\n  }\n  func_4273f580c34f47a2Data = puStack_18;\n  func_66286dd454a84e90();\n  return;\n}\n\n",
        "\nvoid func_e6b12b1be23049ab(void)\n\n{\n  int iVar1;\n  undefined2 uStack_48;\n  undefined2 uStack_46;\n  undefined4 uStack_44;\n  undefined8 ****ppppuStack_38;\n  undefined8 ****ppppuStack_30;\n  undefined8 ****ppppuStack_28;\n  undefined8 ****ppppuStack_20;\n  undefined4 uStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  ppppuStack_28 = &ppppuStack_38;\n  ppppuStack_20 = &ppppuStack_38;\n  ppppuStack_38 = &ppppuStack_28;\n  ppppuStack_30 = &ppppuStack_28;\n  iStack_10 = 0xffffffff;\n  iStack_c = -1;\n  iStack_10 = func_b583ac13316a48d5(2,1,6);\n  if (iStack_10 != -1) {\n    func_52a07a2c12b94495(&uStack_48,0,0x10);\n    uStack_48 = 2;\n    uStack_44 = 0;\n    uStack_46 = func_fd236b7bad014590(0x6987);\n    iVar1 = func_8d9f19e5b328483e(iStack_10,&uStack_48,0x10);\n    if (((iVar1 != -1) && (iVar1 = func_da2efa8eb199426e(iStack_10,5), iVar1 != -1)) &&\n       (iStack_c = func_a816b6eb325344f5(iStack_10,0,0), iStack_c != -1)) {\n      uStack_14 = func_d5cf675a9ab04f4a(iStack_c,&ppppuStack_28,0x10,0);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_784d05e7521148a3(iStack_10);\n  }\n  if (iStack_c != -1) {\n    func_784d05e7521148a3(iStack_c);\n  }\n  func_551508d0f090442f(&ppppuStack_28);\n  return;\n}\n\n",
        "\nvoid func_d31d3bbfb13849dd(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = func_fa6b69ac9f4c4003(200);\n  func_608b3d1856e24d96(uVar1);\n  return;\n}\n\n",
        "\nlong func_ffdb40024a5e4aa9(void)\n\n{\n  long lVar1;\n  \n  lVar1 = func_0c367d73d9e84d3c(400);\n  func_c3010b734ef944c3(lVar1,0x41,99);\n  *(undefined4 *)(lVar1 + 0x18c) = 0;\n  return lVar1 + -0x20;\n}\n\n",
        "\nvoid func_c60ca8aa2bcc4421(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined2 uStack_18;\n  long lStack_10;\n  \n  lStack_10 = func_c839375afc714b47(100);\n  func_9847fec1a5704708(lStack_10,0x41,99);\n  *(undefined *)(lStack_10 + 99) = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  uVar1 = func_b6cd2bf56ae04e8a(lStack_10);\n  func_070601a7a3bc4a85(&uStack_48,uVar1,&UNK_00401324,lStack_10);\n  func_58222c35e33a4093(lStack_10);\n  func_16e191f740f646f0(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_8dc6cc58cd754278(long param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = *(short *)(param_1 + 4);\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_c3624c21fad643b3(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_ce6ef96716c14149(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_6e2f0de360b1494d(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_6be240f5380d4882(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_f204974dfcd24ba8(2,1,6);\n  if (iStack_14 != -1) {\n    func_d0cc12fcb4c2446a(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = 0;\n    uStack_26 = func_57214b7167294f16(0x6987);\n    iVar1 = func_6ea6f5687348415e(iStack_14,&uStack_28,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_08135dff5d084a5f(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_84951810b45e4046(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_9e1e4517513b4602(iStack_10,auStack_36,0xd,0), iStack_18 != -1 &&\n        (iStack_18 != 0)))) {\n      auStack_36[iStack_18] = 0;\n      uStack_c = func_c173dcd435aa48a5(auStack_36);\n    }\n  }\n  if (iStack_14 != -1) {\n    func_1da1f51de92a4d23(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_1da1f51de92a4d23(iStack_10);\n  }\n  func_ae1074ab4f09417f(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_c3a15bce014d4e5c(short param_1)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  \n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_afbd9bc908244468(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (param_1 < 100) {\n    func_ecd2e067e7e64ffd(&uStack_78,auStack_e8,(long)param_1);\n    *(undefined *)((long)&uStack_78 + (long)(int)param_1) = 0;\n  }\n  func_d96d204b5fb1479e(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_6e8511b25cbc4259(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_1b8;\n  undefined8 uStack_1b0;\n  undefined8 auStack_1a8 [49];\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_1b8 = 0;\n  uStack_1b0 = 0;\n  puVar2 = auStack_1a8;\n  for (lVar1 = 0x30; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  puStack_10 = &uStack_1b8;\n  lStack_18 = func_1b57a314294c4071(puStack_10);\n  lStack_20 = func_c7d3465e76b04f91(&UNK_00401344);\n  if (lStack_20 != 0) {\n    func_3c53e2764dc84b3d(lStack_18 * 4 + (long)puStack_10,lStack_20,99 - lStack_18);\n  }\n  func_d5d16206d69942a2(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_0e8e8f443d374300(void)\n\n{\n  int iVar1;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_20;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  int iStack_c;\n  \n  iStack_14 = -1;\n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    iStack_1c = 0xffffffff;\n    iStack_1c = func_06ce093b87c54692(2,1,6);\n    if (iStack_1c != -1) {\n      func_78b79dcf834f4a79(&uStack_38,0,0x10);\n      uStack_38 = 2;\n      uStack_34 = func_47f2b08d4c9d4433(&UNK_004014c8);\n      uStack_36 = func_904673bd19bc48bf(0x6987);\n      iVar1 = func_6caac26508674206(iStack_1c,&uStack_38,0x10);\n      if (iVar1 != -1) {\n        iStack_20 = func_70a3779057fe4997(iStack_1c,auStack_46,0xd,0);\n        if ((iStack_20 != -1) && (iStack_20 != 0)) {\n          auStack_46[iStack_20] = 0;\n          iStack_14 = func_ecf4345b25c643ae(auStack_46);\n        }\n      }\n    }\n    if (iStack_1c != -1) {\n      func_fc163104f6504372(iStack_1c);\n    }\n  }\n  for (iStack_10 = 0; iStack_10 < 1; iStack_10 = iStack_10 + 1) {\n    uStack_78 = 0;\n    uStack_70 = 0;\n    uStack_68 = 0;\n    uStack_60 = 0;\n    uStack_58 = 0;\n    if (iStack_14 < 0) {\n      func_74fd601c76bc4af3(&UNK_004014d8);\n    }\n    else {\n      *(undefined4 *)((long)&uStack_78 + (long)iStack_14 * 4) = 1;\n      for (iStack_18 = 0; iStack_18 < 10; iStack_18 = iStack_18 + 1) {\n        func_ac659a9791ac401a(*(undefined4 *)((long)&uStack_78 + (long)iStack_18 * 4));\n      }\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_1baef04fefb2465a(void)\n\n{\n  func_04b4f8143ff6476b();\n  return;\n}\n\n",
        "\nvoid func_9ba351ac1e324c00(void)\n\n{\n  int iVar1;\n  undefined2 uStack_48;\n  undefined2 uStack_46;\n  undefined4 uStack_44;\n  undefined *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  char *pcStack_10;\n  \n  pcStack_10 = (char *)func_7437ca87679e4186(100);\n  *pcStack_10 = '\\0';\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_3d24555ce65c4486(pcStack_10);\n  iStack_14 = func_54c5cc062de94c91(2,1,6);\n  if (iStack_14 != -1) {\n    func_d621de4b89fd441d(&uStack_48,0,0x10);\n    uStack_48 = 2;\n    uStack_44 = func_2247bc9b0dca412e(&UNK_004015d4);\n    uStack_46 = func_60475388ab004aef(0x6987);\n    iVar1 = func_caac746200ec4876(iStack_14,&uStack_48,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_160d3cfb2531448a(iStack_14,pcStack_10 + lStack_20,99 - lStack_20,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      pcStack_10[iStack_24 + lStack_20] = '\\0';\n      puStack_30 = (undefined *)func_20f0c7de98094e15(pcStack_10,0xd);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined *)func_20f0c7de98094e15(pcStack_10,10);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_dee57d32e75841c3(iStack_14);\n  }\n  do {\n    if (*pcStack_10 == '\\0') {\ncode_r0x0040103f:\n      func_25f823d61e754907(pcStack_10);\n      return;\n    }\n    if (*pcStack_10 == 'S') {\n      func_d2859af664fd4f30(&UNK_004015de);\n      goto code_r0x0040103f;\n    }\n    pcStack_10 = pcStack_10 + 1;\n  } while( true );\n}\n\n",
        "\nvoid func_4f3a00dcd9424492(short param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 < 100) {\n    lVar1 = func_026c55184d384b50((long)param_1);\n    func_2554db30debf4a5b(lVar1,0x41,(long)(param_1 + -1));\n    *(undefined *)(lVar1 + (long)param_1 + -1) = 0;\n    func_77cdfb29115b467d(lVar1);\n    func_171e034931374e96(lVar1);\n  }\n  return;\n}\n\n",
        "\nlong func_b6aeaea48be845a7(long param_1)\n\n{\n  long lStack_10;\n  \n  lStack_10 = param_1;\n  if (CWE126_Buffer_Overread__malloc_wchar_t_loop_22_badGlobal != 0) {\n    lStack_10 = func_0df8a781934b42f0(200);\n    func_dceb609b7ea74697(lStack_10,0x41,0x31);\n    *(undefined4 *)(lStack_10 + 0xc4) = 0;\n  }\n  return lStack_10;\n}\n\n",
        "\nvoid func_cd4ad2c15b804c5a(void)\n\n{\n  undefined *puStack_90;\n  undefined auStack_88 [99];\n  undefined uStack_25;\n  undefined **ppuStack_18;\n  code *pcStack_10;\n  \n  pcStack_10 = CWE127_Buffer_Underread__char_declare_memmove_65b_badSink;\n  puStack_90 = &UNK_00400bf8;\n  func_7f853deb6e41457e(auStack_88,0x41,99);\n  uStack_25 = 0;\n  ppuStack_18 = &puStack_90;\n  puStack_90 = &UNK_00400c15;\n  (*pcStack_10)(ppuStack_18);\n  return;\n}\n\n",
        "\nvoid func_ff68984ff7c0416d(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = func_58c3c08d55104fd7(0);\n  func_4d9480ff8aaf4667(uVar1,&UNK_00401218);\n  func_1cd2e907088b4519(uVar1);\n  func_bb26dd61532a4059(uVar1);\n  return;\n}\n\n",
        "\nvoid func_39a0991e07f6499b(void)\n\n{\n  func_1a4dc5fba5954d5e();\n  return;\n}\n\n",
        "\nvoid func_e24dea2c2b3949b3(undefined8 *param_1)\n\n{\n  param_1 = (undefined8 *)*param_1;\n  *param_1 = 0x696c616974696e49;\n  *(undefined2 *)(param_1 + 1) = 0x657a;\n  *(undefined *)((long)param_1 + 10) = 0;\n  func_2e53edb5549c463e(param_1);\n  func_50559a5c53db45be(param_1);\n  return;\n}\n\n",
        "\nvoid func_6e34d75f1e7f49b2(void)\n\n{\n  long lVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  lVar1 = func_4198642dec594931(200);\n  func_c4f6fcfe3d834768(lVar1,0x41,0x31);\n  *(undefined4 *)(lVar1 + 0xc4) = 0;\n  lVar2 = func_3c6b7fa3c134447d(lVar1);\n  uVar3 = func_d36f2e50d24346d0(lVar2 + 1,1);\n  func_e3a892d2d1b64233(uVar3,lVar1,lVar2 + 1);\n  func_512ecd402c9f4140(uVar3);\n  func_2c53671ea76240cb(uVar3);\n  return;\n}\n\n",
        "\nvoid func_fe3c37c6ea5f4361\n               (undefined8 param_1)\n\n{\n  func_ef0d73f1dc26413c(param_1,param_1);\n  return;\n}\n\n",
        "\nvoid func_91500f851c254f06(void)\n\n{\n  func_bdfd1b609ec54cc2();\n  func_5fb904236bc3489e();\n  return;\n}\n\n",
        "\nvoid func_a2c7392ce28b45d2(undefined4 param_1)\n\n{\n  func_36c93de4da424b0e(param_1);\n  return;\n}\n\n",
        "\nvoid func_a948c1b2c77a4977(void)\n\n{\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined4 uStack_38;\n  long lStack_28;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_98 = 0x2068732f6e69622f;\n  uStack_90 = 0x20616c2d20736c;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  puStack_10 = &uStack_98;\n  lStack_18 = func_d26acb6b1f0545cc(puStack_10);\n  lStack_20 = func_5c99101986984aec(&UNK_0040138c);\n  if (lStack_20 != 0) {\n    func_a0c3b1a813c943d2((long)puStack_10 + lStack_18,lStack_20,99 - lStack_18);\n  }\n  lStack_28 = func_e1928bf51d704d36(puStack_10,&UNK_00401390);\n  if (lStack_28 != 0) {\n    func_eb16bc40d9dd4e2b(lStack_28);\n  }\n  return;\n}\n\n",
        "\nvoid func_abc91e1ee8fc4f0c(void)\n\n{\n  int iVar1;\n  undefined2 uStack_68;\n  undefined2 uStack_66;\n  undefined4 uStack_64;\n  undefined auStack_58 [16];\n  undefined4 *puStack_48;\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)func_a6da9dabee044b5e(400);\n  *puStack_10 = 0;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_34981cc085404afe(puStack_10);\n  iStack_14 = func_5f2f25d84c454976(2,1,6);\n  if (iStack_14 != -1) {\n    func_8056f15049c24746(&uStack_68,0,0x10);\n    uStack_68 = 2;\n    uStack_64 = func_1371d8d83af94a06(&UNK_00401624);\n    uStack_66 = func_cefb7e8319e64a48(0x6987);\n    iVar1 = func_a607e5ab796e4d58(iStack_14,&uStack_68,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_3c32cb111c294667(iStack_14,puStack_10 + lStack_20,(99 - lStack_20) * 4,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      puStack_10[lStack_20 + ((ulong)(long)iStack_24 >> 2)] = 0;\n      puStack_30 = (undefined4 *)func_3db406024abf4800(puStack_10,0xd);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined4 *)func_3db406024abf4800(puStack_10,10);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_2858dc53c30e4750(iStack_14);\n  }\n  puStack_48 = puStack_10;\n  func_d22443c6e02d466a(auStack_58);\n  return;\n}\n\n",
        "\nvoid func_8b64d0b7a3d44dc5(void)\n\n{\n  int iVar1;\n  undefined2 uStack_a8;\n  undefined2 uStack_a6;\n  undefined4 uStack_a4;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined4 uStack_38;\n  undefined *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined8 *puStack_10;\n  \n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  puStack_10 = &uStack_98;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_0a00c35912f54be0(puStack_10);\n  iStack_14 = func_d171d7f89d024d37(2,1,6);\n  if (iStack_14 != -1) {\n    func_530b64fa88244d93(&uStack_a8,0,0x10);\n    uStack_a8 = 2;\n    uStack_a4 = func_67411d49cfa94cca(&UNK_004016d4);\n    uStack_a6 = func_55496935e5014414(0x6987);\n    iVar1 = func_e1c0c3b50fe2412b(iStack_14,&uStack_a8,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_8614812adcec43d7(iStack_14,(long)puStack_10 + lStack_20,99 - lStack_20,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      *(undefined *)((long)puStack_10 + iStack_24 + lStack_20) = 0;\n      puStack_30 = (undefined *)func_138e43c767414faa(puStack_10,0xd);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined *)func_138e43c767414faa(puStack_10,10);\n      if (puStack_30 != (undefined *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_9a83c54240cd436d(iStack_14);\n  }\n  func_cc95cacc920c4348(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_f3f6306f57f94bea(void)\n\n{\n  int iVar1;\n  undefined auStack_36 [14];\n  undefined2 uStack_28;\n  undefined2 uStack_26;\n  undefined4 uStack_24;\n  int iStack_14;\n  int iStack_10;\n  undefined4 uStack_c;\n  \n  uStack_c = 0xffffffff;\n  iStack_10 = 0xffffffff;\n  iStack_10 = func_fd876489e465469f(2,1,6);\n  if (iStack_10 != -1) {\n    func_ec3ebade89ce44d8(&uStack_28,0,0x10);\n    uStack_28 = 2;\n    uStack_24 = func_acbff60b87284063(&UNK_00401594);\n    uStack_26 = func_18a145f1f3cf48cb(0x6987);\n    iVar1 = func_cfe8c1fb667a4eaf(iStack_10,&uStack_28,0x10);\n    if (((iVar1 != -1) && (iStack_14 = func_def1cd6467fe44b9(iStack_10,auStack_36,0xd,0), iStack_14 != -1)\n        ) && (iStack_14 != 0)) {\n      auStack_36[iStack_14] = 0;\n      uStack_c = func_87c6e55dbabc4c86(auStack_36);\n    }\n  }\n  if (iStack_10 != -1) {\n    func_c0b0232ffdeb4856(iStack_10);\n  }\n  func_8c38b273dc454846(uStack_c);\n  return;\n}\n\n",
        "\nvoid func_d92e7cd383e941ab(void)\n\n{\n  func_67da2a3a18c246f1();\n  return;\n}\n\n",
        "\nvoid func_24f75f55af5348ce(void)\n\n{\n  long lVar1;\n  undefined8 uStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined4 uStack_58;\n  undefined auStack_48 [16];\n  undefined8 *puStack_38;\n  long lStack_20;\n  long lStack_18;\n  undefined8 *puStack_10;\n  \n  uStack_b8 = 0;\n  uStack_b0 = 0;\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  puStack_10 = &uStack_b8;\n  lStack_18 = func_aec06ff41c364999(puStack_10);\n  if (1 < 100U - lStack_18) {\n    lStack_20 = func_b2b1d74af6c44863(&UNK_00401346,&UNK_00401344);\n    if (lStack_20 != 0) {\n      lVar1 = func_5ebcaf1431254c83((long)puStack_10 + lStack_18,100 - (int)lStack_18,lStack_20);\n      if (lVar1 == 0) {\n        func_68a4fc5c24f2498a(&UNK_00401354);\n        *(undefined *)(lStack_18 + (long)puStack_10) = 0;\n      }\n      func_6e4f054b4b3540c1(lStack_20);\n    }\n  }\n  puStack_38 = puStack_10;\n  func_5bc44c59ba9345e3(auStack_48);\n  return;\n}\n\n",
        "\nvoid func_361e77863d754999(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 uStack_1a8;\n  undefined8 uStack_1a0;\n  undefined8 auStack_198 [49];\n  undefined8 *puStack_10;\n  \n  uStack_1a8 = 0;\n  uStack_1a0 = 0;\n  puVar2 = auStack_198;\n  for (lVar1 = 0x30; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  puStack_10 = &uStack_1a8;\n  func_361e77863d754999Global = 1;\n  puStack_10 = (undefined8 *)\n               func_361e77863d754999Source(puStack_10);\n  func_024b2767b6ac4f95(&UNK_004013e0,&UNK_004013e0,&UNK_004013d4,&UNK_004013c4,puStack_10,0);\n  return;\n}\n\n",
        "\nvoid func_f83dd74e79d64a95(void)\n\n{\n  ulong uVar1;\n  ulong uStack_18;\n  undefined8 uStack_10;\n  \n  uStack_18 = 0;\n  if (globalTrue != 0) {\n    func_dcc0f3688ba34b22(stdin,&UNK_00401358,&uStack_18);\n  }\n  if (globalTrue != 0) {\n    uVar1 = func_89426be6b76a49ac(&UNK_0040135c);\n    if (uVar1 < uStack_18) {\n      uStack_10 = func_4a253f40825c401c(uStack_18 << 2);\n      func_98361f5576e74e58(uStack_10,&UNK_0040135c);\n      func_707f9b17da1c4b3b(uStack_10);\n      func_f3eaaaefec0a4baa(uStack_10);\n    }\n    else {\n      func_080a49989f694a03(&UNK_00401378);\n    }\n  }\n  return;\n}\n\n",
        "\nvoid func_96dd3100001344e7(void)\n\n{\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  long lStack_18;\n  long lStack_10;\n  \n  lStack_10 = 0;\n  lStack_18 = func_15cf121d726c4ca5(400);\n  func_60b4322e6bbe4b38(lStack_18,0x41,99);\n  *(undefined4 *)(lStack_18 + 0x18c) = 0;\n  lStack_10 = lStack_18 + -0x20;\n  func_60b4322e6bbe4b38(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_9702bb44d7304e1f(lStack_10,auStack_1a8);\n  func_b79c1633af2844a4(lStack_10);\n  return;\n}\n\n",
        "\nvoid func_2a12a5df4e09441d(void)\n\n{\n  int iVar1;\n  undefined auStack_46 [14];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_20;\n  int iStack_1c;\n  ulong uStack_18;\n  int iStack_c;\n  \n  iStack_c = -1;\n  iStack_1c = 0xffffffff;\n  iStack_1c = func_95f9153789bb4da4(2,1,6);\n  if (iStack_1c != -1) {\n    func_55621173dad24788(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = func_6277e8d552784304(&UNK_00401464);\n    uStack_36 = func_2d7165a34d8d4e8a(0x6987);\n    iVar1 = func_f324c538f5c34bbe(iStack_1c,&uStack_38,0x10);\n    if (((iVar1 != -1) && (iStack_20 = func_4ded5f802fa14ebd(iStack_1c,auStack_46,0xd,0), iStack_20 != -1)\n        ) && (iStack_20 != 0)) {\n      auStack_46[iStack_20] = 0;\n      iStack_c = func_5902a6ec421345c2(auStack_46);\n    }\n  }\n  if (iStack_1c != -1) {\n    func_96e26690065f4001(iStack_1c);\n  }\n  for (uStack_18 = 0; uStack_18 < (ulong)(long)iStack_c; uStack_18 = uStack_18 + 1) {\n    func_4641fef2d39d4d05(&UNK_0040146e);\n  }\n  return;\n}\n\n",
        "\nvoid func_02cb73956a0e49fd(undefined8 param_1)\n\n{\n  func_5314377effc94aec(param_1,param_1);\n  return;\n}\n\n",
        "\nvoid func_315bd8e49073472a(undefined8 param_1)\n\n{\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  undefined8 uStack_10;\n  \n  uStack_10 = param_1;\n  func_1bac3683ae09453a(auStack_78,0x43,99);\n  uStack_15 = 0;\n  func_d5508d48abe642bc(uStack_10,auStack_78);\n  func_cf3e0e78e3ef4018(uStack_10);\n  func_aac2fc9dbdca46ff(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_d7bfcae503884eb7(void)\n\n{\n  func_86306ad88ab74376();\n  func_0dbdd8065e9d4d16();\n  return;\n}\n\n",
        "\nvoid func_d0435430955948e5(void)\n\n{\n  int iVar1;\n  undefined2 uStack_48;\n  undefined2 uStack_46;\n  undefined4 uStack_44;\n  undefined4 *puStack_30;\n  int iStack_24;\n  long lStack_20;\n  int iStack_14;\n  undefined4 *puStack_10;\n  \n  puStack_10 = (undefined4 *)func_d49f677c99e04fea(400);\n  *puStack_10 = 0;\n  iStack_14 = 0xffffffff;\n  lStack_20 = func_a4c8ef398fb04e64(puStack_10);\n  iStack_14 = func_6f2b954b7abd450d(2,1,6);\n  if (iStack_14 != -1) {\n    func_13e4d6492b3045c3(&uStack_48,0,0x10);\n    uStack_48 = 2;\n    uStack_44 = func_aab2e5725e824acc(&UNK_00401635);\n    uStack_46 = func_22259c715e224931(0x6987);\n    iVar1 = func_df7c634cc2284f24(iStack_14,&uStack_48,0x10);\n    if (((iVar1 != -1) &&\n        (iStack_24 = func_c6bf9cf8d9aa409d(iStack_14,puStack_10 + lStack_20,(99 - lStack_20) * 4,0),\n        iStack_24 != -1)) && (iStack_24 != 0)) {\n      puStack_10[lStack_20 + ((ulong)(long)iStack_24 >> 2)] = 0;\n      puStack_30 = (undefined4 *)func_2eb42be44a86454d(puStack_10,0xd);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n      puStack_30 = (undefined4 *)func_2eb42be44a86454d(puStack_10,10);\n      if (puStack_30 != (undefined4 *)0x0) {\n        *puStack_30 = 0;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_42b8cd3b891b489f(iStack_14);\n  }\n  func_d0435430955948e5Data = puStack_10;\n  func_cb4c46371a714096();\n  return;\n}\n\n",
        "\nvoid func_86f6a7729d8e4305(void)\n\n{\n  func_c128e1ef46c54e6f();\n  func_a76f7668a011469d();\n  func_bd6f1cbeea9846bc();\n  func_641806e98a5b46f8();\n  return;\n}\n\n",
        "\nvoid func_0eb2ef4420b74d1d(void)\n\n{\n  undefined auStack_80 [104];\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_18 = auStack_80;\n  puStack_10 = puStack_18;\n  func_697a05a15cd44298(puStack_18,0x41,99);\n  puStack_18[99] = 0;\n  func_98f4d203feda4c6a(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_d325f465d2564dae(void)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = 0;\n  func_d325f465d2564daeGlobal = 1;\n  sStack_a = func_2649cbd64f514094(0);\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_d0a2eea5807846be(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_7b4ec69aaeb64aec(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_edba438ce7c440b8(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_604f10cd92f84c9f(void)\n\n{\n  func_247c9f4017fe426d();\n  return;\n}\n\n",
        "\nvoid func_0fa170acdc0d446d(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  int iStack_1cc;\n  undefined8 uStack_1c8;\n  undefined8 uStack_1c0;\n  undefined8 auStack_1b8 [48];\n  undefined8 *puStack_38;\n  undefined8 *puStack_30;\n  long lStack_28;\n  long lStack_20;\n  undefined8 *puStack_18;\n  int iStack_10;\n  int iStack_c;\n  \n  uStack_1c8 = 0;\n  uStack_1c0 = 0;\n  puVar3 = auStack_1b8;\n  for (lVar2 = 0x30; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  puStack_18 = &uStack_1c8;\n  lStack_20 = func_c8bebc899aae4a5a(puStack_18);\n  if (1 < 100U - lStack_20) {\n    lStack_28 = func_0a4480191da246c6(&UNK_00401326,&UNK_00401324);\n    if (lStack_28 != 0) {\n      lVar2 = func_8f5cae8732fd4171(lStack_20 * 4 + (long)puStack_18,100 - (int)lStack_20,lStack_28);\n      if (lVar2 == 0) {\n        func_fe4c3a3593264f79(&UNK_00401334);\n        *(undefined4 *)((long)puStack_18 + lStack_20 * 4) = 0;\n      }\n      func_7c76c3a33fac4726(lStack_28);\n    }\n  }\n  puStack_38 = puStack_18;\n  puStack_30 = puStack_18;\n  iVar1 = func_446f3eb4d3ba4fb5(puStack_18,&UNK_00401344,&iStack_1cc);\n  if (iVar1 == 1) {\n    iStack_10 = 0;\n    for (iStack_c = 0; iStack_c < iStack_1cc; iStack_c = iStack_c + 1) {\n      iStack_10 = iStack_10 + 1;\n    }\n    func_4dccf3ec80c64224(iStack_10);\n  }\n  return;\n}\n\n",
        "\nvoid func_5e57379301b247c0(void)\n\n{\n  undefined auStack_1b0 [408];\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_1b0;\n  func_e50f003420cf45f7(puStack_10,0x41,99);\n  *(undefined4 *)(puStack_10 + 0x18c) = 0;\n  func_5e57379301b247c0Data = puStack_10 + -0x20;\n  puStack_18 = func_5e57379301b247c0Data;\n  func_8918d2d286934931();\n  return;\n}\n\n",
        "\nchar * CWE427_Uncontrolled_Search_Path_Element__char_console_61b_goodG2BSource(char *param_1)\n\n{\n  char cVar1;\n  ulong uVar2;\n  char *pcVar3;\n  \n  uVar2 = 0xffffffffffffffff;\n  pcVar3 = param_1;\n  do {\n    if (uVar2 == 0) break;\n    uVar2 = uVar2 - 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar3 + 1;\n  } while (cVar1 != '\\0');\n  *(undefined4 *)(param_1 + (~uVar2 - 1)) = 0x6e69622f;\n  *(undefined *)((long)(param_1 + (~uVar2 - 1)) + 4) = 0;\n  return param_1;\n}\n\n",
        "\nvoid func_cdc6c3c1998a4739(undefined8 *param_1)\n\n{\n  undefined8 uVar1;\n  undefined auStack_78 [99];\n  undefined uStack_15;\n  undefined8 uStack_10;\n  \n  uStack_10 = *param_1;\n  func_f1773fba7d924825(auStack_78,0x43,99);\n  uStack_15 = 0;\n  uVar1 = func_eda8318fa56340a6(auStack_78);\n  func_e2f0d919f4644dcc(auStack_78,uStack_10,uVar1);\n  uStack_15 = 0;\n  func_e9951c78c55f4c0c(auStack_78);\n  func_ecbbb87517364be2(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_8c4f9bb9cb9146bd(void)\n\n{\n  undefined4 uStack_14;\n  code *pcStack_10;\n  \n  pcStack_10 = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink;\n  uStack_14 = 0xffffffff;\n  func_bef1d1d80b3f4c47(stdin,&UNK_00401314,&uStack_14);\n  (*pcStack_10)(uStack_14);\n  return;\n}\n\n",
        "\nvoid func_beaee4b2371342b4(void)\n\n{\n  func_c703989d8ebf44e5();\n  func_16e2519f2080488e();\n  return;\n}\n\n",
        "\nvoid func_07fc06971eeb4f16(void)\n\n{\n  long lVar1;\n  \n  lVar1 = func_b7be19df7a3d4776(100);\n  func_a1c6a44ed71d4027(lVar1,0x41,99);\n  *(undefined *)(lVar1 + 99) = 0;\n  func_b57d40f13c80483c(lVar1 + -8);\n  return;\n}\n\n",
        "\nvoid func_ae058508a2f24e0e(void)\n\n{\n  int iVar1;\n  undefined auStack_118 [99];\n  undefined uStack_b5;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined auStack_40 [8];\n  undefined2 uStack_38;\n  undefined2 uStack_36;\n  undefined4 uStack_34;\n  int iStack_1c;\n  int iStack_18;\n  int iStack_14;\n  int iStack_10;\n  short sStack_a;\n  \n  sStack_a = 0;\n  iStack_14 = 0xffffffff;\n  iStack_10 = -1;\n  iStack_14 = func_74137f632cd64227(2,1,6);\n  if (iStack_14 != -1) {\n    func_f5a1aeffa9494e91(&uStack_38,0,0x10);\n    uStack_38 = 2;\n    uStack_34 = 0;\n    uStack_36 = func_27a99ffb131f4027(0x6987);\n    iVar1 = func_1f1b410d67114653(iStack_14,&uStack_38,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_2bae04988f8d4d8a(iStack_14,5), iVar1 != -1)) &&\n        (iStack_10 = func_1b984da929cb4a52(iStack_14,0,0), iStack_10 != -1)) &&\n       ((iStack_18 = func_c61959d141b84676(iStack_10,auStack_40,7,0), iStack_18 != -1 && (iStack_18 != 0))\n       )) {\n      auStack_40[iStack_18] = 0;\n      iStack_1c = func_fd6d740f67504775(auStack_40);\n      if ((iStack_1c < 0x8000) && (-0x8001 < iStack_1c)) {\n        sStack_a = (short)iStack_1c;\n      }\n      else {\n        sStack_a = -1;\n      }\n    }\n  }\n  if (iStack_14 != -1) {\n    func_19e94e49ed1a4e54(iStack_14);\n  }\n  if (iStack_10 != -1) {\n    func_19e94e49ed1a4e54(iStack_10);\n  }\n  uStack_a8 = 0;\n  uStack_a0 = 0;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  func_f5a1aeffa9494e91(auStack_118,0x41,99);\n  uStack_b5 = 0;\n  if (sStack_a < 100) {\n    func_a1b0cf6c51364465(&uStack_a8,auStack_118,(long)sStack_a);\n    *(undefined *)((long)&uStack_a8 + (long)(int)sStack_a) = 0;\n  }\n  func_ed98011323a2466d(&uStack_a8);\n  return;\n}\n\n",
        "\nvoid func_26a49d6101b24508(undefined8 *param_1)\n\n{\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  uint uStack_28;\n  undefined8 *puStack_20;\n  \n  puStack_20 = param_1;\n  func_b45a49467ad64b7b(&uStack_88,0x43,99);\n  uStack_28 = uStack_28 & 0xffffff;\n  *puStack_20 = uStack_88;\n  puStack_20[1] = uStack_80;\n  puStack_20[2] = uStack_78;\n  puStack_20[3] = uStack_70;\n  puStack_20[4] = uStack_68;\n  puStack_20[5] = uStack_60;\n  puStack_20[6] = uStack_58;\n  puStack_20[7] = uStack_50;\n  puStack_20[8] = uStack_48;\n  puStack_20[9] = uStack_40;\n  puStack_20[10] = uStack_38;\n  puStack_20[0xb] = uStack_30;\n  *(uint *)(puStack_20 + 0xc) = uStack_28;\n  *(undefined *)((long)puStack_20 + 99) = 0;\n  func_daa31a5f0f564c47(puStack_20);\n  func_19fb4957ac044222(puStack_20);\n  return;\n}\n\n",
        "\nvoid func_f40638096cb64712(void)\n\n{\n  undefined auStack_340 [408];\n  undefined auStack_1a8 [396];\n  undefined4 uStack_1c;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_18 = auStack_340;\n  func_2596f0a446174f59(puStack_18,0x41,99);\n  *(undefined4 *)(puStack_18 + 0x18c) = 0;\n  if (GLOBAL_CONST_FIVE == 5) {\n    puStack_10 = puStack_18 + -0x20;\n  }\n  func_2596f0a446174f59(auStack_1a8,0x43,99);\n  uStack_1c = 0;\n  func_c14e138de6904bc9(puStack_10,auStack_1a8,400);\n  *(undefined4 *)(puStack_10 + 0x18c) = 0;\n  func_cf44ee5cd5e04daa(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_4dc7b19476674830(void)\n\n{\n  return;\n}\n\n",
        "\nvoid func_5658546ab0a64628(void)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)func_e734bc5dd0ab46d3(100);\n  *(undefined *)puVar1 = 0;\n  *puVar1 = 0x7453206465786946;\n  *(undefined4 *)(puVar1 + 1) = 0x676e6972;\n  *(undefined *)((long)puVar1 + 0xc) = 0;\n  func_01340200d3814f65(puVar1);\n  return;\n}\n\n",
        "\nvoid func_ff067622732645bc(void)\n\n{\n  undefined auStack_b0 [104];\n  undefined auStack_48 [16];\n  undefined *puStack_38;\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_b0;\n  func_f38f4728f7a043ab(puStack_10,0x41,99);\n  puStack_10[99] = 0;\n  puStack_38 = puStack_10 + -8;\n  puStack_18 = puStack_38;\n  func_1e38753310364947(auStack_48);\n  return;\n}\n\n",
        "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid func_2028eb49725044e9(void)\n\n{\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  ulong uStack_30;\n  undefined *puStack_28;\n  undefined8 uStack_20;\n  \n  if (GLOBAL_CONST_TRUE != 0) {\n    puStack_28 = &UNK_00401178;\n    func_08f4bfece6b74657(&UNK_00401178);\n    uStack_68 = _UNK_00401178;\n    uStack_60 = _UNK_00401180;\n    uStack_58 = _UNK_00401188;\n    uStack_50 = _UNK_00401190;\n    uStack_48 = _UNK_00401198;\n    uStack_40 = _UNK_004011a0;\n    uStack_38 = _UNK_004011a8;\n    puStack_28 = (undefined *)_UNK_004011b8;\n    uStack_20 = _UNK_004011c0;\n    uStack_30 = _UNK_004011b0 & 0xffffffff;\n    func_08f4bfece6b74657(&uStack_68);\n    func_08f4bfece6b74657(puStack_28);\n  }\n  return;\n}\n\n",
        "\nvoid func_a2ee4b62977d4662(undefined8 *param_1)\n\n{\n  param_1 = (undefined8 *)*param_1;\n  func_30cf59593f684f62(*param_1);\n  func_ad725d06b6674ad8(param_1);\n  return;\n}\n\n",
        "\nvoid func_1b0219234129493a(void)\n\n{\n  func_9227d89f80344065();\n  return;\n}\n\n",
        "\nvoid func_46486fc9c9324666(undefined8 param_1)\n\n{\n  func_6bfbb1a6558e4cd3(param_1);\n  return;\n}\n\n",
        "\nvoid func_7dc58680e0a94dc9(void)\n\n{\n  undefined8 uVar1;\n  int iStack_c;\n  \n  for (iStack_c = 0; iStack_c < 1; iStack_c = iStack_c + 1) {\n    uVar1 = func_64da85044b9b40e5(&UNK_00401324);\n    func_74dd0ab03aca486e(uVar1);\n  }\n  return;\n}\n\n",
        "\nvoid func_fb048e233cd0434a(void)\n\n{\n  func_f0aafaea275845a9();\n  func_b54d60b33414496f();\n  return;\n}\n\n",
        "\nvoid func_82ca24dfdc934700(void)\n\n{\n  undefined8 auStack_338 [100];\n  ulong uStack_18;\n  undefined8 *puStack_10;\n  \n  puStack_10 = (undefined8 *)0x0;\n  if (staticFive == 5) {\n    for (uStack_18 = 0; uStack_18 < 100; uStack_18 = uStack_18 + 1) {\n      auStack_338[uStack_18] = 5;\n    }\n    puStack_10 = auStack_338;\n  }\n  func_748bf7d1f1fc4102(*puStack_10);\n  func_f023e9af78014d3a(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_98103cbe9bf1492b(void)\n\n{\n  undefined auStack_e8 [99];\n  undefined uStack_85;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined8 uStack_20;\n  undefined4 uStack_18;\n  short sStack_a;\n  \n  sStack_a = 0;\n  badStatic = 1;\n  sStack_a = func_b3ec155563f64101(0);\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  uStack_40 = 0;\n  uStack_38 = 0;\n  uStack_30 = 0;\n  uStack_28 = 0;\n  uStack_20 = 0;\n  uStack_18 = 0;\n  func_66bc297b3e924753(auStack_e8,0x41,99);\n  uStack_85 = 0;\n  if (sStack_a < 100) {\n    func_64544bdac37e48b1(&uStack_78,auStack_e8,(long)sStack_a);\n    *(undefined *)((long)&uStack_78 + (long)(int)sStack_a) = 0;\n  }\n  func_3226e6a26de7412e(&uStack_78);\n  return;\n}\n\n",
        "\nvoid func_00d2c01c82ef43dc(undefined8 param_1)\n\n{\n  func_22e2b98e689a49d1(param_1);\n  return;\n}\n\n",
        "\nvoid func_326f40253ff34303(void)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uStack_48;\n  undefined8 uStack_40;\n  undefined8 uStack_38;\n  undefined8 uStack_30;\n  undefined8 uStack_28;\n  undefined4 uStack_20;\n  undefined8 uStack_10;\n  \n  uStack_10 = 0;\n  iVar1 = func_108d6233f44049df();\n  if (iVar1 != 0) {\n    uStack_10 = func_9e58b749984047e0(0x28);\n  }\n  uStack_48 = 0x4100000041;\n  uStack_40 = 0x4100000041;\n  uStack_38 = 0x4100000041;\n  uStack_30 = 0x4100000041;\n  uStack_28 = 0x4100000041;\n  uStack_20 = 0;\n  lVar2 = func_39f3e2fad74640a7(&uStack_48);\n  func_9d7a369561dd469a(uStack_10,&uStack_48,(lVar2 + 1) * 4);\n  func_91774ed1258d4144(uStack_10);\n  func_9051de0808104377(uStack_10);\n  return;\n}\n\n",
        "\nvoid func_cde4f366415a4fa7(undefined8 param_1)\n\n{\n  func_46ba1a80ae8143c4(param_1);\n  return;\n}\n\n",
        "\nvoid func_d5859b35e8244052(void)\n\n{\n  int iVar1;\n  undefined2 uStack_b8;\n  undefined2 uStack_b6;\n  undefined4 uStack_b4;\n  undefined8 uStack_a8;\n  undefined8 uStack_a0;\n  undefined8 uStack_98;\n  undefined8 uStack_90;\n  undefined8 uStack_88;\n  undefined8 uStack_80;\n  undefined8 uStack_78;\n  undefined8 uStack_70;\n  undefined8 uStack_68;\n  undefined8 uStack_60;\n  undefined8 uStack_58;\n  undefined8 uStack_50;\n  undefined4 uStack_48;\n  undefined *puStack_38;\n  int iStack_2c;\n  long lStack_28;\n  int iStack_1c;\n  undefined8 *puStack_18;\n  int iStack_c;\n  \n  uStack_a8 = 0x2068732f6e69622f;\n  uStack_a0 = 0x20616c2d20736c;\n  uStack_98 = 0;\n  uStack_90 = 0;\n  uStack_88 = 0;\n  uStack_80 = 0;\n  uStack_78 = 0;\n  uStack_70 = 0;\n  uStack_68 = 0;\n  uStack_60 = 0;\n  uStack_58 = 0;\n  uStack_50 = 0;\n  uStack_48 = 0;\n  puStack_18 = &uStack_a8;\n  iStack_1c = 0xffffffff;\n  iStack_c = -1;\n  lStack_28 = func_6eed5fc2f3cc4eba(puStack_18);\n  iStack_1c = func_65c3cc20f598483d(2,1,6);\n  if (iStack_1c != -1) {\n    func_d0e50bc56c244cf8(&uStack_b8,0,0x10);\n    uStack_b8 = 2;\n    uStack_b4 = 0;\n    uStack_b6 = func_025d3bdb1c7646f8(0x6987);\n    iVar1 = func_a183958ec1de450a(iStack_1c,&uStack_b8,0x10);\n    if ((((iVar1 != -1) && (iVar1 = func_ee6361179c2c46f1(iStack_1c,5), iVar1 != -1)) &&\n        (iStack_c = func_2f98687e774c4bb4(iStack_1c,0,0), iStack_c != -1)) &&\n       ((iStack_2c = func_cb9982de541c46bc(iStack_c,(long)puStack_18 + lStack_28,99 - lStack_28,0),\n        iStack_2c != -1 && (iStack_2c != 0)))) {\n      *(undefined *)((long)puStack_18 + iStack_2c + lStack_28) = 0;\n      puStack_38 = (undefined *)func_78f13caf0a534eb9(puStack_18,0xd);\n      if (puStack_38 != (undefined *)0x0) {\n        *puStack_38 = 0;\n      }\n      puStack_38 = (undefined *)func_78f13caf0a534eb9(puStack_18,10);\n      if (puStack_38 != (undefined *)0x0) {\n        *puStack_38 = 0;\n      }\n    }\n  }\n  if (iStack_1c != -1) {\n    func_2bd57e1303974a56(iStack_1c);\n  }\n  if (iStack_c != -1) {\n    func_2bd57e1303974a56(iStack_c);\n  }\n  func_6528dbe8bc384ccd(puStack_18);\n  return;\n}\n\n",
        "\nvoid func_6028bb40125e4237(void)\n\n{\n  undefined auStack_88 [112];\n  undefined *puStack_18;\n  undefined *puStack_10;\n  \n  puStack_10 = auStack_88;\n  func_a1753ff68fdb4a48(puStack_10,0x41,99);\n  puStack_10[99] = 0;\n  puStack_18 = puStack_10;\n  func_f30311efd7e44211(puStack_10);\n  return;\n}\n\n",
        "\nvoid func_8f34d6123a654c56(void)\n\n{\n  ulong uStack_10;\n  \n  for (uStack_10 = 0; uStack_10 < 100; uStack_10 = uStack_10 + 1) {\n    *(undefined4 *)(dataBuffer_3778 + uStack_10 * 8) = 1;\n    *(undefined4 *)(dataBuffer_3778 + uStack_10 * 8 + 4) = 1;\n  }\n  func_3f95eadc8ef147a8(dataBuffer_3778);\n  func_65b74536ab704133(dataBuffer_3778);\n  return;\n}\n\n"
    ],
    "pred": [
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data length to a small buffer */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* POTENTIAL FLAW: Allocate memory on the heap */\", '/* Initialize and make use of data */', '/* POTENTIAL FLAW: Use of data that may have been freed */', '/* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* initialize data */\", '/* FLAW: Use a value input from the console using fscanf() */', '/* Assume we want to allocate a relatively small buffer */', '/* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\\r\\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */', '/* Do something with dataBuffer */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 0x41's */\", '/* null terminate */', '/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n     * buffer in various memory copying functions using a \"large\" source buffer. */', '/* put data in array */']",
        "[\"/* POTENTIAL FLAW: Read data using a connect socket */\", '/* connection successful */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[\"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "[\"/* POTENTIAL FLAW: Read data using a socket */\", '/* Connection failed */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[\"/* POTENTIAL FLAW: Set data to a random value */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'S's */\", 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', '",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* POTENTIAL FLAW: if (data*data) > INT_MAX, this will overflow */\"]",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memmove with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* ensure we won't have an overflow */\", '/* POTENTIAL FLAW: if (data * 2) < INT_MIN, this will underflow */']",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\"]",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* POTENTIAL FLAW: data may not have enough space to hold source */\", '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 'A's */\", '/* null terminate */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "[\"/* POTENTIAL FLAW: Don't initialize data */\", '/* empty statement needed for some flow variants */', '/* POTENTIAL FLAW: Use data without initializing it */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "[]",
        "[]",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[\"/* fill with 'S's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if (data) > 0xffffffff, this will cause a buffer overflow */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */\"]",
        "[\"/* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\\r\\n         * for the strcpy() function to not cause a buffer overflow */\", '/* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */', '/* Copy a small string into myString */']",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */']",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */']",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[\"/* fill with 'S's */\", 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', '",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Set data to a random value */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memmove with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: Set data to a random value */\"]",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */']",
        "[]",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\", '/* Ensure the destination buffer is null terminated */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* convert to int */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[\"/* POTENTIAL FLAW: Read data from the console using fgets() */\", '/* Convert to int */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */']",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'X's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Read data from the console using fgets() */\", \"/* Convert to int */\"]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[\"/* fill with 'A's */\", '/* null terminate */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */\", '/* FIX: Open, but do not close the file in the sink */', \"/* FIX: Don't close file in the sink */\", '/* empty statement needed for some flow variants */']",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 */\", '/* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\\r\\n     * string copies in the sinks  */', '/* null terminate */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "[\"/* POTENTIAL FLAW: Partially initialize data */\", '/* POTENTIAL FLAW: Use data without initializing it */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\", '/* Ensure the destination buffer is null terminated */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* convert to int */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[]",
        "[\"/* fill with 5's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with '0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly */']",
        "[]",
        "[\"/* ensure we won't have an underflow */\", '/* POTENTIAL FLAW: if (data*2) > INT_MAX, this will overflow */']",
        "[]",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* POTENTIAL FLAW: data may not have enough space to hold source string */\"]",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: the value pointed to by pointer is undefined */\"]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "UINT func_699dad1fd8544dcfData;",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* null terminate */\", '/* POTENTIAL FLAW: using length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n         * the sign conversion could result in a very large number */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */', '/* Ensure the destination buffer is null terminated */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* connection successful, do stuff... */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[\"/* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */\", '/* FIX: Use a positive integer less than the char buffer size */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: The value pointed to by pointer is undefined */\"]",
        "[\"/* POTENTIAL FLAW: Set data to a random value */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\", 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00]",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* POTENTIAL FLAW: data may not have enough space to hold source string */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "[\"/* fill with 'A's */\", '/* null terminate */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memmove with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\\r\\n         * This code does check to see if the array index is negative */\", '/* Print the array values */']",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* POTENTIAL FLAW: data may not have enough space to hold source string */\"]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Allocate memory on the heap */\", '/* Initialize and make use of data */', '/* POTENTIAL FLAW: No deallocation */', '/* empty statement needed for some flow variants */']",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data == NULL */']",
        "[]",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[\"/* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value\\r\\n         * so that the for loop doing the initialization causes a buffer overflow */\", '/* Potentially writes beyond the boundary of intPointer */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: If the character entered on the command line is not an int,\\r\\n         * a null value will be returned */\"]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data == NULL */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* FLAW: treating pointer as a char* when it may point to a wide string */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Read data using a socket */\", '/* connection successful */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* POTENTIAL FLAW: Attempt to access an index of the array that is above the upper bound\\r\\n         * This check does not check the upper bounds of the array index */\"]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Partially initialize data */\", '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: Use data without initializing it */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Attempt to access a negative index of the array\\r\\n        * This code does not check to see if the array index is negative */\", '/* Print the array values */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[]",
        "[\"/* fill with L'M's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */\", '/* FLAW: If the fopen failed, data will be NULL here */', '/* POTENTIAL FLAW: Possibly opening a file without closing it */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\", \"/* null terminate */\"]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "[\"/* fill with L's */\", '/* null terminate */', '/* POTENTIAL FLAW: if data * sizeof(data) > SIZE_MAX, overflows to a small value\\r\\n         * so that the for loop doing the initialization causes a buffer overflow */', '/* Potentially writes beyond the boundary of intPointer */']",
        "[]",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */\", '/* FLAW: If the fopen failed, data will be NULL here */', '/* POTENTIAL FLAW: Possibly opening a file without closing it */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\", '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */', '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "[\"/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\"]",
        "[\"/* ensure we won't have an overflow */\", '/* POTENTIAL FLAW: if (data * 2) < INT_MIN, this will underflow */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* INCIDENTAL: CWE-467 (Use of sizeof() on a pointer type) */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* POTENTIAL FLAW: data may not have enough space to hold source string */\"]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: The following removes \\'a\\' from the list.  Because of the possible overflow this\\r\\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\\r\\n     * well.  But this is the prototypical \"write-what-where\" at least from\\r\\n     * the Windows perspective.\\r\\n     *\\r\\n     * linkedListPrev = a->list->prev  WHAT\\r\\n     * linkedListNext = a->list->next  WHERE\\r\\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\\r\\n     *                    next/WHAT\"\\r\\n     *                    aka \"write-what-where\"\\r\\n     * linkedListNext->prev",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Partially initialize data */\", '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: Use data without initializing it */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "[\"/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\", '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */', '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* FLAW: Subtracting the slash pointer from a completely different string, should be slashInString1 - string1 */', '/* print the index of where the slash was found */']",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */']",
        "[\"/* POTENTIAL FLAW: Don't initialize data */\", '/* empty statement needed for some flow variants */', '/* POTENTIAL FLAW: Use data without initializing it */']",
        "[\"/* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\"]",
        "[]",
        "[\"/* fill with 'S's */\", 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', '",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\", '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */', '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: Possibly divide by zero */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* put data in array */']",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* FLAW: treating pointer as a char* when it may point to a wide string */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', \"/* FIX: treating pointer as a wchar_t* */\", '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memmove with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memmove with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Read data from the console using fgets() */\", \"/* Convert to int */\"]",
        "[\"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Allocate memory on the heap */\", '/* Initialize and make use of data */', '/* POTENTIAL FLAW: No deallocation */', '/* empty statement needed for some flow variants */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\", \"/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\"]",
        "[\"/* POTENTIAL FLAW: Read data from the console using fscanf() */\", '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Partially initialize data */\", '/* POTENTIAL FLAW: Use data without initializing it */']",
        "[\"/* POTENTIAL FLAW: Set data to a random value */\", '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'S's */\", 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', 'S', '",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "[\"/* POTENTIAL FLAW: Read data from the network */\", '/* ensure we got a good read */', '/* POTENTIAL FLAW: if (data*2) > INT_MAX, this will overflow */']",
        "[\"/* fill with LFs */\", '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "[\"/* POTENTIAL FLAW: Attempt to access a negative index of the array\\r\\n         * This check does not check to see if the array index is negative */\"]",
        "[\"/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[\"/* fill with L's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: Establishing connection without checking the path */\", '/* connection successful, do stuff... */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Read data using a socket */\", '/* Connection failed */', '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to before the allocated memory buffer */', '/* use the function pointer */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Set data to point to a wide string */', '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* fill with L's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* FLAW: treating pointer as a char* when it may point to a wide string */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "[\"/* POTENTIAL FLAW: Set data to a random value */\", '/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "[\"/* POTENTIAL FLAW: For loop using count as the loop variant and no validation\\r\\n         * This can cause a file to become very large */\"]",
        "[]",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Read data from the console using fscanf() */\", '/* POTENTIAL FLAW: Allocate memory on heap using malloc() with the size of data */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(int) */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Set data to point to a wide string */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memmove with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* null terminate */', '/* POTENTIAL FLAW: using memcpy with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "[\"/* POTENTIAL FLAW: Initialize data to be a fixed string that contains the search character in the sinks */\"]",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to before the allocated memory buffer */', '/* put data in array */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "[\"/* fill with 5's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "[]",
        "[\"/* fill with 'A's */\", '/* null terminate */', 0, 1, 6, 0x75, 0]",
        "[]",
        "[\"/* POTENTIAL FLAW: Set data to point to a wide string */\", '/* FLAW: treating pointer as a char* when it may point to a wide string */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', \"/* FIX: treating pointer as a wchar_t* */\", '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "[\"/* fill with 'A's */\", '/* null terminate */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected."
    ],
    "gt": [
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "",
        "['/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with L'A's */\", '/* null terminate */', '/* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */', \"/* fill with L'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */', '/* Ensure the destination buffer is null terminated */']",
        "['/* POTENTIAL FLAW: For loop using count as the loop variant and no validation\\r\\n         * This can cause a file to become very large */']",
        "['/* Copy length + 1 to include NUL terminator from source */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */', '/* POTENTIAL FLAW: Use of data that may have been freed */', '/* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */']",
        "['/* Initialize data */', '/* FLAW: Use a value input from the console using fscanf() */', '/* Assume we want to allocate a relatively small buffer */', '/* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\\r\\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */', '/* Do something with dataBuffer */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n         * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n     * buffer in various memory copying functions using a \"large\" source buffer. */', '/* put data in array */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Set data to a random value */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n         * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */']",
        "['/* Initialize data */', '/* FLAW: data is allocated on the stack and deallocated in the BadSink */', \"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fgets() */', '/* Convert to int */', '/* POTENTIAL FLAW: if (data*data) > INT_MAX, this will overflow */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */']",
        "['/* Initialize data */', '/* Abort on error or the connection was closed */', '/* FLAW: Use a value input from the network */', '/* NUL-terminate string */', '/* Convert to short - ensure int to short conversion will be successful and if\\r\\n             * not ensure that data will be negative */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n                 * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "[\"/* ensure we won't have an overflow */\", '/* POTENTIAL FLAW: if (data * 2) < INT_MIN, this will underflow */']",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* true */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */', '/* POTENTIAL FLAW: Execute command in data possibly leading to command injection */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with L'A's */\", '/* null terminate */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* Initialize array */', '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "",
        "['/* true */', \"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* Initialize data */', '/* true */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "['/* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/', '/* Ensure the destination buffer is null terminated */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "['/* FLAW: the value pointed to by pointer is undefined */']",
        "['/* FLAW: Copy overlapping memory regions using memcpy() for which the result is undefined */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "['/* define a function pointer */', '/* Initialize data */', '/* FLAW: Use a value input from the console using fgets() */', '/* Convert to short */', '/* use the function pointer */']",
        "['/* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "",
        "",
        "['/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "['/* INCIDENTAL - No check for NULL on malloc() */', \"/* Assign CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad BEFORE\\r\\n             * calling 'signal', because pointer types are not (according to spec), atomic\\r\\n             * with respect to signals.\\r\\n             *\\r\\n             * In practice they are on most (all?) POSIX-y computers, but thems the\\r\\n             * rules\\r\\n             */\", '/* FLAW: This test, free, and set operation is not atomic, so if signal\\r\\n             * delivery occurs (for example) between the free and setting to NULL,\\r\\n             * the signal handler could corrupt the heap, cause an access violation,\\r\\n             * etc\\r\\n             *\\r\\n             * Technically, \"CWE364_Signal_Handler_Race_Condition__basic_08StructSigAtomicBad = 0\" is not atomic on certain theoretical computer\\r\\n             * systems that don\\'t actually exist, but this should trigger on\\r\\n             * theoretical as well as actual computer systems.\\r\\n             */']",
        "['/* POTENTIAL FLAW: No deallocation */', '/* empty statement needed for some flow variants */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n         * buffer in various memory copying functions using a \"large\" source buffer. */', \"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "['/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* NULL terminate */']",
        "",
        "['/* Copy length + 1 to include NUL terminator from source */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "['/* define a function pointer */', '/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to unsigned int */', '/* use the function pointer */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to unsigned int */', '/* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\\r\\n             * for the strcpy() function to not cause a buffer overflow */', '/* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */', '/* Copy a small string into myString */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* null terminate */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */']",
        "",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n     * buffer in various memory copying functions using a \"large\" source buffer. */']",
        "['/* FLAW: Allocate memory without using sizeof(int) */', '/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "['/* Initialize data */', '/* FLAW: data is allocated on the stack and deallocated in the BadSink */', '/* FIX: data is allocated on the heap and deallocated in the BadSink */', '/* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "['/* define a function pointer */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* use the function pointer */']",
        "",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n     * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* wexeclp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */']",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                 * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* null terminate */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */']",
        "['/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Set data to a random value */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n     * memory block not at the start of the buffer */']",
        "['/* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value\\r\\n         * so that the for loop doing the initialization causes a buffer overflow */', '/* Potentially writes beyond the boundary of intPointer */']",
        "['/* FLAW: Use a small buffer */', \"/* fill with 'A's */\", '/* null terminate */', '/* null terminate */', '/* POTENTIAL FLAW: using memmove with the length of the dest where data\\r\\n         * could be smaller than dest causing buffer overread */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* true */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "['/* Initialize data */', '/* FLAW: Use a random value that could be less than 0 */']",
        "['/* true */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* execlp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "",
        "['/* Initialize data */', '/* FLAW: Use a value input from the console using fgets() */', '/* Convert to short */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n             * returned by malloc() so can't safely call free() on it */\"]",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "['/* Restore NUL terminator if fgets fails */', '/* remove newline */', '/* FLAW: Open and write to the file after checking the status information */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* FIX: Use a positive integer less than &InitialDataSize&*/', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* NULL terminate */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */', '/* true */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fgets() */', '/* Convert to int */']",
        "['/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', '/* FIX: Set data pointer to the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: Do not initialize data */', '/* empty statement needed for some flow variants */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* POTENTIAL FLAW: Execute command in data possibly leading to command injection */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Set data to a random value */', '/* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\\r\\n             * for the wcscpy() function to not cause a buffer overflow */', '/* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */', '/* Copy a small string into myString */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "",
        "['/* Abort on error or the connection was closed */', '/* FLAW: Use a value input from the network */', '/* NUL-terminate string */', '/* Convert to short - ensure int to short conversion will be successful and if\\r\\n                 * not ensure that data will be negative */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n         * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "[\"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* copy data out of dataArray */', '/* POTENTIAL FLAW: Possibly divide by zero */']",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n     * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "['/* POTENTIAL FLAW: Partially initialize data */', '/* POTENTIAL FLAW: Use data without initializing it */']",
        "['/* FLAW: Did not leave space for a null terminator */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n         * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* POTENTIAL FLAW: For loop using count as the loop variant and no validation\\r\\n         * This can cause a file to become very large */']",
        "['/* Enter: 1e-50, result should be 0.0 (for bad case)\\r\\n             *\\r\\n             * Note: alternate input\\r\\n             * 999999999999999999999999999999999999999999999999999999999999999\\r\\n             */', '/* Read a double */', '/* FLAW: should not cast without checking if conversion is safe */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* execlp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* define a function pointer */', '/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgetws fails */', '/* use the function pointer */']",
        "['/* Initialize data */', '/* FLAW: data is allocated on the stack and deallocated in the BadSink */', '/* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */']",
        "['/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: Copy overlapping memory regions using memcpy() for which the result is undefined */']",
        "",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', \"/* ensure we won't have an underflow */\", '/* POTENTIAL FLAW: if (data*2) > INT_MAX, this will overflow */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', '/* FIX: Set data pointer to the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "['/* cast void pointer to a pointer of the appropriate type */', '/* dereference dataPtr into data */', '/* Initialize array */', '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "['/* cast void pointer to a pointer of the appropriate type */', '/* dereference dataPtr into data */', '/* POTENTIAL FLAW: this assertion could trigger if n <= ASSERT_VALUE */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n     * memory block not at the start of the buffer */']",
        "['/* Initialize data */', '/* FLAW: Use a value input from the console using fscanf() */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* NULL terminate */']",
        "['/* cast void pointer to a pointer of the appropriate type */', '/* dereference dataPtr into data */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: the value pointed to by pointer is undefined */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* Copy length + 1 to include NUL terminator from source */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "['/* Initialize data */', '/* Abort on error or the connection was closed */', '/* FLAW: Use a value input from the network */', '/* NUL-terminate string */', '/* Convert to short - ensure int to short conversion will be successful and if\\r\\n             * not ensure that data will be negative */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */', '/* Ensure the destination buffer is null terminated */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "['/* cast void pointer to a pointer of the appropriate type */', '/* dereference dataPtr into data */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "['/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */', '/* Ensure the destination buffer is null terminated */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */']",
        "['/* Initialize data */', '/* Abort on error or the connection was closed */', '/* FLAW: Use a number input from the network */', '/* NUL-terminate string */', '/* Convert to short */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: this assertion could trigger if n <= ASSERT_VALUE */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* FLAW: the value pointed to by pointer is undefined */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Set data to a random value */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n     * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\\r\\n         * string copies in the sinks  */', '/* null terminate */', '/* Copy length + 1 to include NUL terminator from source */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "['/* Initialize data */', '/* FLAW: Use a value input from the console using fgets() */', '/* Convert to short */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "['/* POTENTIAL FLAW: For loop using count as the loop variant and no validation\\r\\n         * This can cause a file to become very large */']",
        "",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Use an invalid index */', '/* initialize buffer */', '/* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\\r\\n             * This code does check to see if the array index is negative */', '/* Print the array values */']",
        "['/* Establish that this is a temporary file and that it should be deleted */', \"/* FLAW: We don't unlink */\"]",
        "",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with L'A's */\", '/* null terminate */']",
        "",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* Initialize data */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* FLAW: Use a value input from the network */', '/* NUL-terminate string */', '/* Convert to short - ensure int to short conversion will be successful and if\\r\\n             * not ensure that data will be negative */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n                 * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                     * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */', '/* execl - specify the path where the command is located */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */', '/* Ensure the destination buffer is null terminated */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\\r\\n            * This code does check to see if the array index is negative */', '/* Print the array values */']",
        "",
        "['/* execl - specify the path where the command is located */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "['/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "",
        "['/* POTENTIAL FLAW: No deallocation */', '/* empty statement needed for some flow variants */']",
        "['/* Initialize data */', '/* FLAW: Use a value input from the console using fscanf() */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n     * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */']",
        "[\"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "",
        "['/* cast void pointer to a pointer of the appropriate type */', '/* dereference dataPtr into data */', '/* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\\r\\n         * for the strcpy() function to not cause a buffer overflow */', '/* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */', '/* Copy a small string into myString */']",
        "['/* Print the initial block pointed to by structCharVoid->voidSecond */', '/* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */', '/* null terminate the string */']",
        "",
        "",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* NULL terminate */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* Initialize data */', '/* INCIDENTAL: CWE-467 (Use of sizeof() on a pointer type) */', '/* FLAW: Using sizeof the pointer and not the data type in malloc() */']",
        "['/* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\\r\\n     * string copies in the sinks  */', '/* null terminate */']",
        "",
        "",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                 * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */', '/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgetws fails */', '/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* POTENTIAL FLAW: Allocate memory on the heap */', '/* Initialize and make use of data */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', \"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* POTENTIAL FLAW: Possibly freeing memory twice */']",
        "['/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* NULL terminate */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* Initialize array */', '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value\\r\\n         * so that the for loop doing the initialization causes a buffer overflow */', '/* Potentially writes beyond the boundary of intPointer */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "['/* define a function pointer */', '/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* null terminate */', '/* use the function pointer */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                 * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fscanf() */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* Print the initial block pointed to by structCharVoid->voidSecond */', '/* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */', '/* null terminate the string */']",
        "['/* FLAW: If the character entered on the command line is not an int,\\r\\n         * a null value will be returned */']",
        "['/* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\\r\\n     * string copies in the sinks  */', '/* null terminate */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Use an invalid index */', '/* initialize buffer */', '/* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\\r\\n             * This code does check to see if the array index is negative */', '/* Print the array values */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "['/* copy data out of dataArray */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* INCIDENTAL: CWE-467 (Use of sizeof() on a pointer type) */', '/* FLAW: Using sizeof the pointer and not the data type in malloc() */']",
        "['/* FLAW: the value pointed to by pointer is undefined */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* null terminate */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "['/* copy data out of dataArray */', '/* execl - specify the path where the command is located */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "['/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n     * memory block not at the start of the buffer */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "",
        "['/* cast void pointer to a pointer of the appropriate type */', '/* dereference dataPtr into data */', \"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', \"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\\r\\n             * for the wcscpy() function to not cause a buffer overflow */', '/* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */', '/* Copy a small string into myString */']",
        "",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: Attempt to access an index of the array that is above the upper bound\\r\\n             * This check does not check the upper bounds of the array index */']",
        "['/* FLAW: Using sizeof the pointer and not the data type in malloc() */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                     * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */', \"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fgets() */', '/* Convert to int */', '/* put data in array */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* This simulates a Microsoft-style linked list insertion */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* FLAW: overwrite linked list pointers with data */', '/* POTENTIAL FLAW: The following removes \\'a\\' from the list.  Because of the possible overflow this\\r\\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\\r\\n     * well.  But this is the prototypical \"write-what-where\" at least from\\r\\n     * the Windows perspective.\\r\\n     *\\r\\n     * linkedListPrev = a->list->prev  WHAT\\r\\n     * linkedListNext = a->list->next  WHERE\\r\\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\\r\\n     *                    next/WHAT\"\\r\\n     *                    aka \"write-what-where\"\\r\\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\\r\\n     *                    (because prev is the second field in \\'list\\' hence\\r\\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\\r\\n     */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* execl - specify the path where the command is located */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: Attempt to access a negative index of the array\\r\\n            * This code does not check to see if the array index is negative */', '/* Print the array values */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* null terminate */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to unsigned int */']",
        "['/* Initialize data */', '/* FLAW: data is allocated on the stack and deallocated in the BadSink */', \"/* fill with 'A's */\", '/* null terminate */']",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n         * buffer in various memory copying functions using a \"large\" source buffer. */', '/* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */', \"/* fill with 0's */\", '/* POTENTIAL FLAW: Possible buffer overflow if data < 100 */']",
        "['/* FLAW: Did not leave space for a null terminator */', '/* Copy length + 1 to include NUL terminator from source */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "['/* Initialize data */', '/* FLAW: Set data to a value that will cause an integer overflow in the call to malloc() in the sink */', '/* 1073741825 */', '/* NOTE: This value will cause the sink to only allocate 4 bytes of memory, however\\r\\n         * the for loop will attempt to access indices 0-1073741824 */', '/* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value\\r\\n         * so that the for loop doing the initialization causes a buffer overflow */', '/* Potentially writes beyond the boundary of intPointer */']",
        "",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* true */']",
        "['/* FLAW: Allocate memory without using sizeof(int) */']",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "['/* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\\r\\n            * This code does check to see if the array index is negative */', '/* Print the array values */']",
        "",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgetws fails */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* put data in array */']",
        "",
        "['/* Initialize data */', '/* strncpy() does not null terminate if the string in the src buffer is larger than\\r\\n             * the number of characters being copied to the dest buffer */', '/* FLAW: do not explicitly null terminate dest after the use of strncpy() */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* wexeclp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* FLAW: Did not leave space for a null terminator */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "['/* Initialize data */', '/* FLAW: Use a value input from the console using fgets() */', '/* Convert to short */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n                 * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "['/* FLAW: the value pointed to by pointer is undefined */']",
        "['/* This simulates a Microsoft-style linked list insertion */', '/* POTENTIAL FLAW: The following removes \\'a\\' from the list.  Because of the possible overflow this\\r\\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\\r\\n     * well.  But this is the prototypical \"write-what-where\" at least from\\r\\n     * the Windows perspective.\\r\\n     *\\r\\n     * linkedListPrev = a->list->prev  WHAT\\r\\n     * linkedListNext = a->list->next  WHERE\\r\\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\\r\\n     *                    next/WHAT\"\\r\\n     *                    aka \"write-what-where\"\\r\\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\\r\\n     *                    (because prev is the second field in \\'list\\' hence\\r\\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\\r\\n     */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "['/* This simulates a Microsoft-style linked list insertion */', '/* Abort on error or the connection was closed */', '/* FLAW: overwrite linked list pointers with data */', '/* POTENTIAL FLAW: The following removes \\'a\\' from the list.  Because of the possible overflow this\\r\\n     * causes a \"write-what-where\" aka \"write4\".  It does another write as\\r\\n     * well.  But this is the prototypical \"write-what-where\" at least from\\r\\n     * the Windows perspective.\\r\\n     *\\r\\n     * linkedListPrev = a->list->prev  WHAT\\r\\n     * linkedListNext = a->list->next  WHERE\\r\\n     * linkedListPrev->next = linkedListNext  \"at the address that prev/WHERE points, write\\r\\n     *                    next/WHAT\"\\r\\n     *                    aka \"write-what-where\"\\r\\n     * linkedListNext->prev = linkedListPrev  \"at the address that next/WHAT points plus 4\\r\\n     *                    (because prev is the second field in \\'list\\' hence\\r\\n     *                    4 bytes away on 32b machines), write prev/WHERE\"\\r\\n     */']",
        "['/* define a function pointer */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* use the function pointer */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\\r\\n         * buffer in various memory copying functions using a \"large\" source buffer. */', '/* null terminate */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: subtracting the slash pointer from a completely different string, should be slashInString1 - string1 */', '/* print the index of where the slash was found */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */', '/* null terminate */', \"/* fill with L'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */', '/* Ensure null termination */']",
        "[\"/* POTENTIAL FLAW: Don't initialize data */\", '/* empty statement needed for some flow variants */', '/* POTENTIAL FLAW: Use data without initializing it */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: Adding 1 to data could cause an overflow */']",
        "['/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                 * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "['/* FLAW: Allocate memory without using sizeof(int) */', '/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* true */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: Possibly divide by zero */']",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                 * inserted by fgetws() */', '/* Restore NUL terminator if fgetws fails */']",
        "['/* Initialize data */', '/* FLAW: Use a negative number */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* copy data out of dataArray */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "[\"/* fill with 'A's */\", '/* null terminate */', \"/* fill with 'A's */\", '/* null terminate */', '/* FLAW: Set data pointer to a small buffer */', '/* put data in array */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* execlp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* Initialize data */', '/* Abort on error or the connection was closed */', '/* FLAW: Use a value input from the network */', '/* NUL-terminate string */', '/* Convert to short - ensure int to short conversion will be successful and if\\r\\n                 * not ensure that data will be negative */', '/* FIX: Use a positive integer less than &InitialDataSize&*/', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */']",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */']",
        "['/* Initialize data */', '/* FLAW: data is allocated on the stack and deallocated in the BadSink */', \"/* fill with 'A's */\", '/* null terminate */', '/* put data in array */']",
        "['/* true */', '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "['/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                 * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */', '/* execlp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fgets() */', '/* Convert to int */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* POTENTIAL FLAW: No deallocation */', '/* empty statement needed for some flow variants */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */']",
        "['/* Initialize data */', '/* FLAW: Use a value input from the console using fgets() */', '/* Convert to short */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "['/* Initialize and make use of data */', '/* FLAW: If realloc() fails, the initial memory block will not be freed() */', '/* Reinitialize and make use of data */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fscanf() */', '/* put data in array */']",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */', '/* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fgets() */', '/* Convert to int */', '/* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\\r\\n         * access an index of the array in the sink that is out-of-bounds */', '/* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\\r\\n            * This code does check to see if the array index is negative */', '/* Print the array values */', '/* FIX: Properly validate the array index and prevent a buffer overflow */', '/* Print the array values */']",
        "['/* POTENTIAL FLAW: Partially initialize data */', '/* FIX: Completely initialize data */', '/* POTENTIAL FLAW: Use data without initializing it */', '/* FIX: Ensure data is initialized before use */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "['/* POTENTIAL FLAW: Allocate memory on the heap */', '/* Initialize and make use of data */', '/* true */']",
        "['/* define a function pointer */', '/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* use the function pointer */']",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                     * inserted by fgetws() */', '/* Restore NUL terminator if fgetws fails */', '/* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */']",
        "['/* POTENTIAL FLAW: Attempt to access an index of the array that is above the upper bound\\r\\n         * This check does not check the upper bounds of the array index */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fgets() */', '/* Convert to unsigned int */']",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "['/* Read input from the console */', '/* if there is room in data, read into it from the console */', '/* POTENTIAL FLAW: Read data from the console */', '/* The next few lines remove the carriage return from the string that is\\r\\n                 * inserted by fgets() */', '/* Restore NUL terminator if fgets fails */', '/* INCIDENTAL: CWE 561 Dead Code, the code below will never run */', '/* execlp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "['/* define a function pointer */', '/* FLAW: Use a small buffer */', \"/* fill with 'A's */\", '/* null terminate */', '/* use the function pointer */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fgets() */', '/* Convert to int */', '/* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\\r\\n         * access an index of the array in the sink that is out-of-bounds */', '/* POTENTIAL FLAW: Attempt to access a negative index of the array\\r\\n             * This check does not check to see if the array index is negative */', '/* FIX: Properly validate the array index and prevent a buffer underread */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */', '/* Use data */', '/* POTENTIAL FLAW: No deallocation of memory */', '/* no deallocation */', '/* empty statement needed for some flow variants */']",
        "",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* POTENTIAL FLAW: Execute command in data possibly leading to command injection */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign conversion could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* This simulates a Microsoft-style linked list insertion */', '/* Abort on error or the connection was closed */', '/* FLAW: overwrite linked list pointers with data */']",
        "['/* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */']",
        "['/* copy data out of dataArray */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* NULL terminate */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n                 * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\\r\\n            * This code does check to see if the array index is negative */', '/* Print the array values */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\\r\\n         * memory block not at the start of the buffer */']",
        "The code seems to be well-protected against vulnerabilities and security breaches, with no notable issues detected.",
        "['/* FLAW: Use a small buffer */', \"/* fill with 'A's */\", '/* null terminate */']",
        "['/* define a function pointer */', '/* FLAW: Set data pointer to before the allocated memory buffer */', '/* use the function pointer */']",
        "['/* Initialize data */', '/* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */']",
        "No security vulnerabilities or breaches were found during the evaluation of the code.",
        "['/* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */']",
        "['/* POTENTIAL FLAW: Set data to point to a wide string */', '/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */']",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "From the review conducted, it appears that the code is devoid of any vulnerabilities or security loopholes.",
        "['/* Append input from an environment variable to data */', '/* If there is data in the environment variable */', '/* POTENTIAL FLAW: Read data from an environment variable */', '/* POTENTIAL FLAW: Execute command in data possibly leading to command injection */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */', '/* put data in array */']",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */']",
        "Upon examination, no vulnerabilities or security breaches were detected in the provided code.",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgets fails */', '/* put data in array */']",
        "['/* true */', '/* wexeclp - searches for the location of the command among\\r\\n     * the directories specified by the PATH environment variable */', '/* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */']",
        "['/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fscanf() */', '/* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\\r\\n             * for the wcscpy() function to not cause a buffer overflow */', '/* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */', '/* Copy a small string into myString */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', \"/* INCIDENTAL CWE-401: Memory Leak - data may not point to location\\r\\n         * returned by malloc() so can't safely call free() on it */\"]",
        "['/* Initialize count */', '/* POTENTIAL FLAW: Read count using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* NUL-terminate the string */', '/* Convert to int */', '/* POTENTIAL FLAW: For loop using count as the loop variant and no validation */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */']",
        "There are no apparent vulnerabilities or security breaches present in the analyzed code.",
        "['/* POTENTIAL FLAW: Read data using a connect socket */', '/* Abort on error or the connection was closed, make sure to recv one\\r\\n             * less char than is in the recv_buf in order to append a terminator */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */']",
        "['/* Initialize data */', '/* true */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "After thorough analysis, it seems that the code is free from any vulnerabilities or security risks.",
        "['/* Read input from a file */', '/* if there is room in data, attempt to read the input from a file */', '/* POTENTIAL FLAW: Read data from a file */', '/* Restore NUL terminator if fgetws fails */', \"/* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\", '/* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */', '/* avoid a dead/empty code block issue */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "['/* define a function pointer */', '/* Initialize data */', '/* POTENTIAL FLAW: Read data from the console using fscanf() */', '/* use the function pointer */']",
        "After careful scrutiny, it can be concluded that the code is devoid of any vulnerabilities or potential security threats.",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */']",
        "['/* Initialize data */', '/* Abort on error or the connection was closed */', '/* FLAW: Use a value input from the network */', '/* NUL-terminate string */', '/* Convert to short - ensure int to short conversion will be successful and if\\r\\n                 * not ensure that data will be negative */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "[\"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */', '/* Ensure the destination buffer is null terminated */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', \"/* fill with 'C's */\", '/* null terminate */', '/* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */', '/* Ensure the destination buffer is null terminated */']",
        "['/* POTENTIAL FLAW: No deallocation */', '/* empty statement needed for some flow variants */']",
        "['/* POTENTIAL FLAW: Initialize data to be a fixed string that contains the search character in the sinks */']",
        "['/* FLAW: Set data pointer to before the allocated memory buffer */', '/* put data in array */']",
        "['/* Print the initial block pointed to by structCharVoid.voidSecond */', '/* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */', '/* null terminate the string */']",
        "['/* cast void pointer to a pointer of the appropriate type */', '/* dereference dataPtr into data */', '/* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */']",
        "Based on the assessment, there are no indications of vulnerabilities or security breaches in the code.",
        "",
        "['/* Call the bad helper function */', \"/* free(reversedString);\\r\\n             * This call to free() was removed because we want the tool to detect the use after free,\\r\\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\\r\\n             */\"]",
        "The code seems to be robust and secure, showing no signs of vulnerabilities or security risks.",
        "['/* Initialize data */', '/* FLAW: data is allocated on the stack and deallocated in the BadSink */', '/* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */']",
        "['/* Initialize data */', '/* true */', '/* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\\r\\n             * the sign extension could result in a very large number */', '/* strncpy() does not always NULL terminate */']",
        "The code appears to be secure, with no evident vulnerabilities or potential security breaches.",
        "['/* FLAW: Did not leave space for a null terminator */', '/* Copy length + 1 to include NUL terminator from source */', '/* POTENTIAL FLAW: data may not have enough space to hold source */']",
        "",
        "['/* POTENTIAL FLAW: Read data using a listen socket */', '/* Abort on error or the connection was closed */', '/* Append null terminator */', '/* Eliminate CRLF */']",
        "['/* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */', \"/* fill with 'A's */\", '/* null terminate */']",
        "['/* Initialize data */', '/* FLAW: data is allocated on the stack and deallocated in the BadSink */', '/* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */']"
    ]
}